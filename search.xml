<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>后人乘凉指南</title>
    <url>/2025/07/18/Blog_Using_Guide/</url>
    <content><![CDATA[<p>本博文栽树，以便后人乘凉。</p>
<span id="more"></span>

<p align="center">---------------------------  Part 1  ---------------------------</p>

<h2 id="程序类"><a href="#程序类" class="headerlink" title="程序类"></a>程序类</h2><h3 id="MCU"><a href="#MCU" class="headerlink" title="MCU"></a>MCU</h3><ol>
<li><a href="https://microprism.github.io/2025/07/19/TCP-01-Protocol/">TCP-01-协议详解</a></li>
<li><a href="https://microprism.github.io/2025/07/19/TCP-02-ZYNQ_TCP_Demo_Error/#more">TCP-02-ZYNQ7020 TCP例程自动协商失败解决办法</a></li>
</ol>
<h3 id="FPGA"><a href="#FPGA" class="headerlink" title="FPGA"></a>FPGA</h3><ol>
<li><a href="https://microprism.github.io/2025/04/20/FPGA-01-About_ZYNQ/">FPGA-01-关于ZYNQ </a></li>
<li><a href="https://microprism.github.io/2025/05/29/FPGA-02-Verilog_Syntax/">FPGA-02-Verilog语法 </a></li>
</ol>
<h3 id="Matlab"><a href="#Matlab" class="headerlink" title="Matlab"></a>Matlab</h3><ol>
<li>empty.</li>
</ol>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ol>
<li><a href="https://microprism.github.io/2025/06/17/Git-Using_Guide/">Git-使用指南 </a></li>
</ol>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h3><ol>
<li><a href="https://microprism.github.io/2025/07/19/LeetCode-01-String_Composition/">LeetCode-01-字符串交叉拼接</a></li>
<li><a href="https://microprism.github.io/2025/07/19/LeetCode-02-GCD_Of_String/">LeetCode-02-两字符串寻找最大公因子</a></li>
<li><a href="https://microprism.github.io/2025/07/24/LeetCode-03-Kids_With_Candies">LeetCode-03-寻找糖果数最多的孩子</a></li>
<li><a href="https://microprism.github.io/2025/07/24/LeetCode-04-Can_Place_Flowers/">LeetCode-04-种花问题</a></li>
<li><a href="https://microprism.github.io/2025/08/02/LeetCode-05-Reverse_Vowels/">LeetCode-05-字符串中元音字符翻转</a></li>
<li><a href="https://microprism.github.io/2025/08/03/LeetCode-06-Reverse_Words/">LeetCode-06-字符串中单词顺序反转</a></li>
<li><a href="https://microprism.github.io/2025/08/07/LeetCode-07-Product_ExceptSelf/">LeetCode-07-元素之积</a></li>
</ol>
<p align="center">---------------------------  Part 2  ---------------------------</p>

<h2 id="计算机类"><a href="#计算机类" class="headerlink" title="计算机类"></a>计算机类</h2><ol>
<li><a href="https://www.bilibili.com/video/BV1tNpbekEht/?spm_id_from=333.337.search-card.all.click&vd_source=5465b0f4790ebae45362caa6519f3b79">《数据结构（C 语言描述）》</a></li>
<li><a href="https://space.bilibili.com/517494241?spm_id_from=333.337.0.0">董晓算法的个人空间-董晓算法个人主页-哔哩哔哩视频</a></li>
</ol>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>1. </p>
<p align="center">---------------------------  Part 3  ---------------------------</p>

<h2 id="硬件类"><a href="#硬件类" class="headerlink" title="硬件类"></a>硬件类</h2><h3 id="Altium"><a href="#Altium" class="headerlink" title="Altium"></a>Altium</h3><ol>
<li>empty.</li>
<li><a href="https://microprism.github.io/2025/07/18/Altium-02-Error_And_Solution/">Altium-02-错误与解决办法 </a></li>
</ol>
<h3 id="SI"><a href="#SI" class="headerlink" title="SI"></a>SI</h3><ol>
<li><a href="https://microprism.github.io/2025/07/09/SI-01-Impedance/">SI-01-PCB特性阻抗 </a></li>
</ol>
<p align="center">---------------------------  Part 4  ---------------------------</p>

<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><ol>
<li><a href="https://microprism.github.io/2025/04/09/Hexo-01-Build_Blog/">Hexo-01-博客搭建问题与解决办法 </a></li>
<li><a href="https://microprism.github.io/2025/05/29/Hexo-02-Deploy_Error_And_Solution/">Hexo-02-推送错误(Fatal:502)解决办法</a></li>
<li><a href="https://microprism.github.io/2025/06/04/Hexo-03-Embed_PDF_In_Next/">Hexo-03-Next嵌入PDF</a></li>
</ol>
<h3 id="SpaceDesk"><a href="#SpaceDesk" class="headerlink" title="SpaceDesk"></a>SpaceDesk</h3><ol>
<li><a href="https://microprism.github.io/2025/04/19/SpaceDesk-Secondary_Screen/">SpaceDesk-Win与iPad有线副屏扩展与常见问题</a></li>
</ol>
<p align="center">---------------------------  Part 5  ---------------------------</p>

<h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><h3 id="考研"><a href="#考研" class="headerlink" title="考研"></a>考研</h3><ol>
<li><a href="https://microprism.github.io/2025/06/02/NCU-873_Trends/">NCU-南昌大学873控制专业考研形势</a></li>
</ol>
<p align="center">--------------------------- Part 6 ---------------------------</p>

<h2 id="流量卡"><a href="#流量卡" class="headerlink" title="流量卡"></a>流量卡</h2><ol>
<li><a href="https://microprism.github.io/2025/06/10/Sideline-SIM_Card/">Sideline-流量卡办理</a></li>
</ol>
<p align="center">---------------------------  End  ---------------------------</p>

<blockquote>
<p>前人栽树，后人乘凉。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>数据结构-02-线性表</title>
    <url>/2025/08/10/DS-02-Linear_List/</url>
    <content><![CDATA[<p>本博文基于C语言的内容引入数据结构的时间、空间复杂度，并补充等差数列、累加和数列、等比数列等数学基础。解释顺序表、链表的使用场景和效率提升思路。</p>
<span id="more"></span>

<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote>
<p> 由n(n&gt;&#x3D;0)个数据特性相同的元素构成的有限序列。</p>
</blockquote>
<p>长度定义：线性表中元素个数定义为长度，n&#x3D;0时称空表</p>
<p>非空线性表特性：</p>
<ul>
<li>存在唯一一个“第一个”数据元素</li>
<li>存在唯一一个“最后一个”数据元素</li>
<li>除第一个元素外，每个元素只有一个前驱</li>
<li>除最后一个元素外，每个元素只有一个后继</li>
</ul>
<h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><p>用一组连续的内存单元依次存储线性表各个元素，逻辑上相邻的元素在物理存储空间上也是连续的。</p>
<blockquote>
<p>算法的目的也仅仅是针对某种数据结构高效的增删改查</p>
</blockquote>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE = 100;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType; <span class="comment">//便于后续移植更改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initList</span><span class="params">(SeqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    L-&gt;length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><p>可以将length作为数组索引。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">appendElem</span><span class="params">(SeqList *L, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length &gt;= MAXSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;顺序表已满\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;data[L-&gt;length] = e;</span><br><span class="line">    L-&gt;length ++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历元素"><a href="#遍历元素" class="headerlink" title="遍历元素"></a>遍历元素</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">listElem</span><span class="params">(SeqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; L-&gt;length ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,L-&gt;data[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h2><p>顺序表插入数据需要移动目标位置处后的所有元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertElem</span><span class="params">(SeqList *L,<span class="type">int</span> pos, ElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( L-&gt;length &gt;= MAXSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//表满</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; MAXSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//插入位置出错    </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= L-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= L-&gt;length - <span class="number">1</span>; i&gt;= pos - <span class="number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;data[i+<span class="number">1</span>] = L-&gt;data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        L-&gt;data[pos - <span class="number">1</span>] = *e;</span><br><span class="line">        L-&gt;length ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>顺序表删除数据需要移动目标位置处后的所以元素，但是最后的元素不需清0。因为length-1之后，已经不会再访问该值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deleteElem</span><span class="params">(SeqList *L,<span class="type">int</span> pos, ElemType *e)</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == L-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//空表</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( pos &lt; <span class="number">0</span> || pos &gt; MAXSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//位置错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *e = L-&gt;data[pos<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(pos &lt; L-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=pos; i&lt; L-&gt;length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;data[i<span class="number">-1</span>] = L-&gt;data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     L-&gt;length--;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findElem</span><span class="params">(SeqList *L,ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="number">0</span> == L-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;L-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;data[i] == e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>; <span class="comment">//位置从1开始，索引从0开始</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *data; <span class="comment">//使用指针动态管理空间</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SeqList *<span class="title function_">initList</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SeqList *L = (SeqList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqList));<span class="comment">//结构体指针</span></span><br><span class="line">    L-&gt;data = (Elemype *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType)*MAXSIZE);<span class="comment">//分配数组</span></span><br><span class="line">    L-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h2><p>一组任意的存储单元存储线性表的数据元素，可以是连续的，也可以是不连续的。</p>
<blockquote>
<p> 相对于顺序表，链表村粗的存储单位未必连续。</p>
</blockquote>
<p>每个数据元素除去本身的信息外，还需要存储一个指示后继信息。数据元素称为数据域，后继位置称为指针域，两部分信息共同称为节点。</p>
<p>n个节点组成的线性序列，称为链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span> <span class="comment">//下一个节点地址</span></span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure>

<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>单链表初始化，即初始化一个头节点。后续的节点则不断插入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Node *<span class="title function_">initList</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *head = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    head-&gt;data = <span class="number">0</span>;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入元素-1"><a href="#插入元素-1" class="headerlink" title="插入元素"></a>插入元素</h3><ul>
<li><p>头插法：每次把数据插入在头节点之后</p>
<div>            <!--块级封装-->
    <center>    <!--将图片和文字居中-->
    <img src="1_HeaderInsert.jpg" alt="image can't load." style="zoom:100%"><!-- alt内为提示词-->
    <br>        <!--换行-->
    头插链表<!--标题-->
    </center>
</div>

<p>该方法需要先将新节点链向下一个节点，再将头节点链向新节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertHead</span><span class="params">(Node *L, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = L-&gt;next; </span><br><span class="line">    L-&gt;next = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尾插法</p>
<p>尾插法即插入在尾部，隐藏首先需要获取尾部节点。</p>
<div>            <!--块级封装-->
    <center>    <!--将图片和文字居中-->
    <img src="2_TailInsert.jpg" alt="image can't load." style="zoom:100%"><!-- alt内为提示词-->
    <br>        <!--换行-->
    尾插链表<!--标题-->
    </center>
</div>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Node *<span class="title function_">getTail</span><span class="params">(Node *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p = L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在参数节点后插入新节点，并返回新的尾节点</span></span><br><span class="line">Node *<span class="title function_">insertTail</span><span class="params">(Node *tail, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    tail-&gt;next = p;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>任意位置插入</p>
</li>
</ul>
  <div>			<!--块级封装-->
      <center>	<!--将图片和文字居中-->
      <img src="3_Insert.jpg" alt="image can't load." style="zoom:100%"><!-- alt内为提示词-->
      <br>		<!--换行-->
      任意位置插入<!--标题-->
      </center>
  </div>

  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertNode</span><span class="params">(Node *L, <span class="type">int</span> pos,ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p = L;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; pos<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p= p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="comment">//链表长度不足</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//此处可以做一些其他操作，比如直接插在尾部</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node *new = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    new-&gt;data = e;</span><br><span class="line">    new-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = new;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>遍历</p>
<p>链表遍历不需要知道节点个数，而是以节点是否为NULL为条件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">listNode</span><span class="params">(Node *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h3><p>对于链表，需要找到待删除的节点位置，随后释放内存空间，防止造成内存泄漏。</p>
<p>但在节点删除时，需要注意最后一个节点不能被删除，<code>p-&gt;next</code>为空代表链表结束。</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="4_deleteNode.jpg" alt="image can't load." style="zoom:100%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    删除节点<!--标题-->
    </center>
</div>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deleteNode</span><span class="params">(Node* L,<span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p = L; <span class="comment">//头节点，从头节点之后的节点才称为第一个，第二个</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//p指向待删除节点的前驱</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;pos - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//p-&gt;next待删除节点为NULL</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;位置错误\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//q指向待删除节点</span></span><br><span class="line">    Node *q = p-&gt;next;</span><br><span class="line">    <span class="comment">//删除节点的前驱指向删除节点的后继</span></span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要删除全部链表，可从前向后删除。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deleteNodeList</span><span class="params">(Node *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p = L;</span><br><span class="line">    Node *q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><h4 id="例题1-查找节点"><a href="#例题1-查找节点" class="headerlink" title="例题1:查找节点"></a>例题1:查找节点</h4><p>已知一个带有表头节点的单链表，节点结构为<code>data + link</code>。假设该链表只给出了头指针 list 。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第 k 个位置上的结点（k 为正整数）。若查找成功，算法输出该节点的 data 域的值，并返回 1 ；否则，只返回 0 。要求：</p>
<ul>
<li>描述算法的基本思想；</li>
<li>描述算法的详细实现步骤；</li>
<li>根据设计思想和实现步骤，采用程序设计语言描述算法（使用 C 、C++、或 Java语言实现），关键之处请给出简要注释</li>
</ul>
<p>**解题思路：**使用双指针（快慢指针）。即快指针走k步之后，开始同步移动fast和slow指针，当fast指向NULL节点时，slow即为目标指针。</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="5_doublePointer_gap_k.jpg" alt="image can't load." style="zoom:15%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    快慢指针查值<!--标题-->
    </center>
</div>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findNodeFS</span><span class="params">(Node *L, <span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *fast = L -&gt; next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">NULL</span>) <span class="comment">//链表长度小于k</span></span><br><span class="line">        &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;error 01: list length less than k&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node *slow = L-&gt;next; <span class="comment">//记录慢指针</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast -&gt; next;</span><br><span class="line">        slow = slow -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;success: expect data is %d\n&quot;</span>,slow-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="例题2-合并链表"><a href="#例题2-合并链表" class="headerlink" title="例题2:合并链表"></a>例题2:合并链表</h4><p>假定采用带头节点的单链表保存单词，当两个单词有相同的后缀时，则可共享相同的后缀存储空间，例如，“ending”和“being”的存储映像如下图所示。</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="6_doublePointer_verge_List.jpg" alt="image can't load." style="zoom:15%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    合并尾部结点<!--标题-->
    </center>
</div>

<p>设 str1 和 str2 分别指向两个单词所在单链表的头节点，链表结点结构为<code>data+next</code>请设计一个时间上尽可能高效的算法，找出由 str1 和 str2 所指向两个链表共同后缀的起始位置（如图字符 i 所在结点的位置 p）。要求：</p>
<ul>
<li>描述算法的基本设计思想；</li>
<li>根据设计思想，采用 C 或 C++ 或 Java 语言描述，关键之处给出注释</li>
<li>说明你所设计算法的时间复杂度</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>已知尾部n个字符相等，则需要两个链表先对齐，即长链表后移gap个字节。随后，快慢指针同时移动，直到找到相同的data值。最后将短链表链向长链表的尾缀，并释放短链表后续的结点。</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="6_doublePointer_verge_List_re.jpg" alt="image can't load." style="zoom:15%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    思路<!--标题-->
    </center>
</div>

<ul>
<li>寻找相同data时，需要记录上一个节点，以便链向新节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题2: 合并单词链表，例如being 和ending </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vergeListWithChar</span><span class="params">(Node* list1, Node* list2)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//输入链表为空</span></span><br><span class="line">	<span class="keyword">if</span> (list1 == <span class="literal">NULL</span> || list2 == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> list1_len = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> list2_len = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//计算链表1的长度</span></span><br><span class="line">	Node* fast = list1;</span><br><span class="line">	<span class="keyword">while</span> (fast != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fast = fast-&gt;next;</span><br><span class="line">		list1_len++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算链表2的长度</span></span><br><span class="line">	fast = list2;</span><br><span class="line">	<span class="keyword">while</span> (fast != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fast = fast-&gt;next;</span><br><span class="line">		list2_len++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算链表长度，并设定快慢指针值</span></span><br><span class="line">	Node* slow = fast;</span><br><span class="line">	<span class="type">int</span> gap = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (list1_len &gt; list2_len)</span><br><span class="line">	&#123;</span><br><span class="line">		fast = list1;</span><br><span class="line">		slow = list2;</span><br><span class="line">		gap = list1_len - list2_len;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		fast = list2;</span><br><span class="line">		slow = list1;</span><br><span class="line">		gap = list2_len - list1_len;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//移动快指针</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gap; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fast = fast-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历找到链表中的相同数据</span></span><br><span class="line">	Node* p = slow;</span><br><span class="line">	<span class="keyword">while</span> (fast-&gt;data != slow-&gt;data)</span><br><span class="line">	&#123;</span><br><span class="line">		p = slow;<span class="comment">//保存相同数值的上一节点</span></span><br><span class="line">		fast = fast-&gt;next;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//连接向相同值</span></span><br><span class="line">	p-&gt;next = fast; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//释放剩余节点</span></span><br><span class="line">	<span class="keyword">while</span> (slow != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p = slow;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="例题3-过滤同值"><a href="#例题3-过滤同值" class="headerlink" title="例题3:过滤同值"></a>例题3:过滤同值</h4><p>用单链表保存 n 个整数，结点的结构为 [data][link]，且|data| n(n 为正整数)。现要求设计一个时间复杂度尽可能高效的算法，对于链表中 data 的绝对值相等的节点，仅保留第一次出现的节点而删除其余绝对值相等的结点。例如，若给定单链表<br>head 如下：</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="7_delete_same_node.jpg" alt="image can't load." style="zoom:15%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    操作事例<!--标题-->
    </center>
</div>

<p>要求：</p>
<ul>
<li>给出算法的基本设计思想。</li>
<li>使用 C 或 C++ 语言，给出单链表节点的数据类型定义。</li>
<li>根据设计思想，采用 C 或 C++ 语言描述算法，关键之处给出注释。</li>
<li>说明你所设计算法的时间复杂度和空间复杂度。</li>
</ul>
<p>解题思路：空间换时间</p>
<ul>
<li>已知链表节点内的data最大值小于链表长度n，可创建长度为n（或n+1）的空间作为判断数组，当某个值出现时索引值设为1。</li>
<li>当出现重复值时，将last_node-&gt;next指向current_node-&gt;next，以跳过重复节点。</li>
<li>刷新current_node节点</li>
<li>释放重复节点</li>
</ul>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="7_delete_same_node_re.jpg" alt="image can't load." style="zoom:15%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    操作事例<!--标题-->
    </center>
</div>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题3：删除链表中数值绝对值相同的节点,已知链表长度n</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteRepeatNode</span><span class="params">(Node* header, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	Node* p = header; <span class="comment">//使用current_node更合适</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//建立一个与数组长度相符的空间作为判断数组</span></span><br><span class="line">	<span class="type">int</span>* judgeArray = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (len + <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len + <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		judgeArray[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找值</span></span><br><span class="line">	p = header-&gt;next;</span><br><span class="line">	Node* last_node = <span class="literal">NULL</span>; <span class="comment">// 保存上一节点</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//绝对值首次出现，则标记</span></span><br><span class="line">		<span class="keyword">if</span> (judgeArray[<span class="built_in">abs</span>(p-&gt;data)] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			judgeArray[<span class="built_in">abs</span>(p-&gt;data)] = <span class="number">1</span>;</span><br><span class="line">			last_node = p; <span class="comment">//保存上一个节点</span></span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">//出现重复节点，则释放该节点</span></span><br><span class="line">		&#123;</span><br><span class="line">			last_node-&gt;next = p-&gt;next;  <span class="comment">//将重复值的前移节点链向重复节点的后一个节点</span></span><br><span class="line">			Node* tmp = p;		<span class="comment">// 待释放的重复节点</span></span><br><span class="line">			p = p-&gt;next;		<span class="comment">//更新p节点，不更新上一个节点q</span></span><br><span class="line">			<span class="built_in">free</span>(tmp); <span class="comment">//释放当前节点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(judgeArray);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例题4-反转链表"><a href="#例题4-反转链表" class="headerlink" title="例题4:反转链表"></a>例题4:反转链表</h4><p>假设有以链表结构为：头节点+其他n个节点，每个节点为<code>data+next</code>格式，设计算法将链表内节点顺序反转。</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="8_reverse_list.jpg" alt="image can't load." style="zoom:15%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    链表反转<!--标题-->
    </center>
</div>

<p>解题思路：</p>
<ul>
<li>使用三个指针指向顺序的三个数，当third指向NULL时，表明到达链表尾部</li>
<li>依次修改second节点的next指向，从指向下一个变为指向上一个</li>
<li>将源链表的头节点指向最后一个second节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题4：反转链表顺序</span></span><br><span class="line"><span class="comment">// @param: src - 输入初始链表</span></span><br><span class="line"><span class="comment">// @return: 成功返回0，异常返回其他值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">reverseList</span><span class="params">(Node* src)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//若链表节点数小于2(不含头节点)，则退出</span></span><br><span class="line">	<span class="keyword">if</span> (src == <span class="literal">NULL</span> || src-&gt;next == <span class="literal">NULL</span> || src-&gt;next-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Node* first = <span class="literal">NULL</span>;</span><br><span class="line">	Node* second = src-&gt;next;</span><br><span class="line">	Node* third = src-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//third为NULL时，second指向最后一个节点</span></span><br><span class="line">	<span class="keyword">while</span> (third != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		second-&gt;next = first;</span><br><span class="line">		first = second;</span><br><span class="line">		second = third;</span><br><span class="line">		third = third-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//连接最后一个节点</span></span><br><span class="line">	second-&gt;next = first;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//更新头节点</span></span><br><span class="line">	src-&gt;next = second;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例题5-删除中点"><a href="#例题5-删除中点" class="headerlink" title="例题5:删除中点"></a>例题5:删除中点</h4><p>假设有以链表结构为：头节点+其他n个节点，每个节点为<code>data+next</code>格式，设计算法将链表内中间节点删除。</p>
<p>解题思路：</p>
<ul>
<li>使用快慢指针，slow每移动一个节点，fast移动两次</li>
<li>直到fast指向NULL或者fast-&gt;next指向NULL，则slow为待删除节点的前置节点</li>
</ul>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="9_delete_middle_node.jpg" alt="image can't load." style="zoom:15%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    删除链表中间节点<!--标题-->
    </center>
</div>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题5：删除链表中间节点</span></span><br><span class="line"><span class="comment">// @param: src - 输入初始链表</span></span><br><span class="line"><span class="comment">// @return: 成功返回0，异常返回其他值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteMiddleNode</span><span class="params">(Node* src)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (src == <span class="literal">NULL</span> || src-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置快慢指针初始值</span></span><br><span class="line">	Node* slow = src;</span><br><span class="line">	Node* fast = src-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//快指针移动两个节点，直到其或者其下一个节点为NULL</span></span><br><span class="line">	<span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Node* del = slow-&gt;next;</span><br><span class="line">	slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(del);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例题6-链表重排"><a href="#例题6-链表重排" class="headerlink" title="例题6:链表重排"></a>例题6:链表重排</h4><p>设线性表L&#x3D;(a<del>1</del>, a<del>2</del>, a<del>3</del>, … , a<del>n-2</del>, a<del>n-1</del>, a<del>n</del>)采用带头节点的单链表保存，链表中的节点定义为data+next。</p>
<p>请设计一个空间复杂度为 O(1) 且时间上尽可能高效的算法，重新排列 L 中的各节点，得到线性表L’&#x3D; (a<del>1</del>, a<del>n</del>, a<del>2</del>, a<del>n-1</del>, a<del>3</del>, a<del>n-2</del>, …)。</p>
<p>解题思路：</p>
<ul>
<li>找到中间节点，并断开为两个链表</li>
<li>将后半链表倒序重排</li>
<li>两个链表交叉相连</li>
</ul>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="10_reorder_list.jpg" alt="image can't load." style="zoom:15%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    链表交叉重排<!--标题-->
    </center>
</div>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题6:重排链表节点交叉相连</span></span><br><span class="line"><span class="comment">// @param: src - 输入初始链表</span></span><br><span class="line"><span class="comment">// @return: 成功返回0，异常返回其他值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">reOrderList</span><span class="params">(Node* src)</span></span><br><span class="line">&#123;</span><br><span class="line">	Node* p = src;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span> || p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化快慢指针，寻找中间节点</span></span><br><span class="line">	Node* slow = p;</span><br><span class="line">	Node* fast = p-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//断开尾部链表</span></span><br><span class="line">	Node* tail_list = slow-&gt;next;</span><br><span class="line">	slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重排尾部链表</span></span><br><span class="line">	Node* first = <span class="literal">NULL</span>;</span><br><span class="line">	Node* second = tail_list;</span><br><span class="line">	Node* third = tail_list-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (third != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		second-&gt;next = first;</span><br><span class="line">		first = second;</span><br><span class="line">		second = third;</span><br><span class="line">		third = third-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//后半段链表首个节点tail_list</span></span><br><span class="line">	second-&gt;next = first;</span><br><span class="line">	tail_list = second;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//两个链表交叉重排，直到某段的下一个节点到尾部</span></span><br><span class="line">	p = src-&gt;next;</span><br><span class="line">	Node* q = tail_list;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Node* tmp = p-&gt;next;</span><br><span class="line">		p-&gt;next = q;</span><br><span class="line">		q = q-&gt;next;</span><br><span class="line">		p-&gt;next-&gt;next = tmp;</span><br><span class="line">		p = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将剩余的q连接至p的尾部(q剩余部分一定包含NULL</span></span><br><span class="line">    p-&gt;next = q;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而无论链表长度为奇数还是偶数，前半段的链表一定最先到达尾部NULL节点，因此只需要将new_p的next节点连接至剩余的p即可。</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="10_reorder_list_link.jpg" alt="image can't load." style="zoom:15%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    偶数长度(情况1)与偶数长度(情况2)<!--标题-->
    </center>
</div>

<h2 id="单向循环链表"><a href="#单向循环链表" class="headerlink" title="单向循环链表"></a>单向循环链表</h2><p>在单链表的基础上，尾节点的next不再指向NULL，而是指向链表中任意一个节点时，就构成了闭环。</p>
<blockquote>
<p>适用于单链表的printfList函数就不再适用，因为判断条件不再是cuurent_node-&gt;next &#x3D;&#x3D; NULL。同样的，删除链表的操作也需要预先将环断开。</p>
</blockquote>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="11_cycle_list.jpg" alt="image can't load." style="zoom:15%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    循环链表<!--标题-->
    </center>
</div>

<p>如图列出10个节点的链表，也许在第10个节点next指向NULL，构成单向链表。也许会按照虚线所示指向某个前方节点，构成循环链表。</p>
<p>因此，在确定单向链表疑似存在环之后：</p>
<ol>
<li>确定是否存在环</li>
<li>确定环的长度</li>
<li>找到环的入口(起始节点)</li>
</ol>
<p>针对以上三个目标引申出三个问题：</p>
<ol>
<li><p>如何确定存在环路？–快慢指针</p>
<p>类比成小学数学的赛跑相遇问题，如果AB速度不同，则快着率先到达终点，否则一定会在途中某处相遇。因此问题就具现为快慢指针能否相遇</p>
<div>            <!--块级封装-->
    <center>    <!--将图片和文字居中-->
    <img src="11_cycle_list_is_cycle.jpg" alt="image can't load." style="zoom:15%"><!-- alt内为提示词-->
    <br>        <!--换行-->
    有环终会相遇<!--标题-->
    </center>
</div>
</li>
<li><p>如何确定环的长度？</p>
<p>当确定存在环之后，从相遇节点起始，直至再次遇到相同节点移动的节点数</p>
</li>
<li><p>环的入口？–x+y &#x3D; y+x</p>
<p>当确定环的长度后，再次适用快慢指针思路，起始点先走环长度x，再同步走y个长度，一定会在入口相遇。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题7:判断是否是循环单链表，并且找到循环入口</span></span><br><span class="line"><span class="comment">// @param: src - 输入初始链表</span></span><br><span class="line"><span class="comment">// @return: 存在环，返回环的长度； 链表异常返回-1；链表无环返回-2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isCycleList</span><span class="params">(Node* src)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (src == <span class="literal">NULL</span> || src-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//源链表异常</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Node* fast = src;</span><br><span class="line">	Node* slow = src;</span><br><span class="line">	<span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)<span class="comment">/* fast与slow步进长度不同，当fast与slow有交叉时，证明存在环 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (slow == fast)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> siCycleLenth = <span class="number">1</span>; <span class="comment">/* 计算链表内环的长度 */</span></span><br><span class="line">			fast = fast-&gt;next;</span><br><span class="line">			<span class="keyword">for</span> (siCycleLenth = <span class="number">1</span>; fast != slow; siCycleLenth++)</span><br><span class="line">			&#123;</span><br><span class="line">				fast = fast-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> siCycleLenth;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-2</span>; <span class="comment">//未找到环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @param: src - 输入初始链表</span></span><br><span class="line"><span class="comment">// @return: 正常，返回起始节点地址； 异常，返回NULL</span></span><br><span class="line">Node* <span class="title function_">findStartNodeInCycle</span><span class="params">(Node* src,<span class="type">int</span> cycleLenth)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (src == <span class="literal">NULL</span> || src-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//源链表异常</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Node* fast = src;</span><br><span class="line">	Node* slow = src;</span><br><span class="line">	<span class="comment">/* fast指针向前便宜环个长度 */</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cycleLenth &amp;&amp; fast != <span class="literal">NULL</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fast = fast-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* slow与fast同步移动，直到相遇 */</span></span><br><span class="line">	<span class="keyword">while</span> (slow != fast &amp;&amp; fast != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		fast = fast-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要释放链表，需要增加以下函数断开环：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//释放循环链表</span></span><br><span class="line">Node* <span class="title function_">cutCycleList</span><span class="params">(Node* cycleStartNode)</span></span><br><span class="line">&#123;</span><br><span class="line">	Node* p = cycleStartNode;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != cycleStartNode)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完此函数后，返回指针为最后一个节点，p-&gt;next为NULL。</p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>链式存储结构节点中只有一个指向后继的指针，查找节点的直接前驱，必须从表头出发，时间复杂度为O(n)。</p>
<p>因此为克服单向性的特点，提出双向链表，即prev和next。</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="12_double_list.jpg" alt="image can't load." style="zoom:15%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    双向链表<!--标题-->
    </center>
</div>

<h3 id="添加元素-1"><a href="#添加元素-1" class="headerlink" title="添加元素"></a>添加元素</h3><ul>
<li><p>头插法</p>
<p>相对于单链表，在处理时额外考虑链接前一个节点。</p>
<ol>
<li>优先将下一节点的前置节点prev连接至新节点（也不是必须这么干，但逻辑关系要正确）</li>
<li>将新节点的next连接向头节点的下个节点</li>
<li>将头节点next连接至新节点</li>
<li>新节点prev链接至为头节点</li>
</ol>
<div>            <!--块级封装-->
    <center>    <!--将图片和文字居中-->
    <img src="12_double_list_insert_header.jpg" alt="image can't load." style="zoom:15%"><!-- alt内为提示词-->
    <br>        <!--换行-->
    双向链表头插法<!--标题-->
    </center>
</div></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以头插法插入节点,带值</span></span><br><span class="line">Node* <span class="title function_">insertHeaderWithElem</span><span class="params">(Node* header, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">	Node* p = header;</span><br><span class="line">	Node* m = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	<span class="keyword">if</span> (m == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	m-&gt;data = e;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> EXAMPLE &gt;= 8 		<span class="comment">//EXAMPLE = 8 表示双向链表</span></span></span><br><span class="line">	<span class="comment">/* 链接prev节点 */</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;next-&gt;prev = m;</span><br><span class="line">	&#125;</span><br><span class="line">	m-&gt;prev = header;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	m-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = m;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>尾插法</p>
<p>尾插法只需要将新节点的prev连接至原有的尾节点，其他与单链表一致。</p>
<div>            <!--块级封装-->
    <center>    <!--将图片和文字居中-->
    <img src="12_double_list_insert_tailer.jpg" alt="image can't load." style="zoom:15%"><!-- alt内为提示词-->
    <br>        <!--换行-->
    双向链表尾插法<!--标题-->
    </center>
</div></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以尾插法插入节点,带值</span></span><br><span class="line">Node* <span class="title function_">insertTailWithElem</span><span class="params">(Node* header, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">	Node* p = header;</span><br><span class="line">	<span class="comment">/* 找到尾节点 */</span></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Node* m = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	<span class="keyword">if</span> (m == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> EXAMPLE &gt;= 8</span></span><br><span class="line">	m-&gt;prev = p;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	m-&gt;data = e;</span><br><span class="line">	m-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;next = m;</span><br><span class="line">	<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>任意节点</p>
<p>任意节点插入元素类似于头插法，只需要提前找到目标位置。</p>
</li>
</ul>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>预想删除节点，即：</p>
<ul>
<li><p>找到目标位置的前一个节点</p>
</li>
<li><p>将待删除的节点的后继节点（非空）prev连接至前一节点</p>
</li>
<li><p>释放节点</p>
<div>            <!--块级封装-->
    <center>    <!--将图片和文字居中-->
    <img src="12_double_list_delete_node.jpg" alt="image can't load." style="zoom:15%"><!-- alt内为提示词-->
    <br>        <!--换行-->
    双向链表删除节点<!--标题-->
    </center>
</div></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除指定位置的节点</span></span><br><span class="line">Node* <span class="title function_">deleteNode</span><span class="params">(Node* L, <span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">	Node* p = L;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pos - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Node* q = p-&gt;next;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> EXAMPLE &gt;= 8 </span></span><br><span class="line">	q-&gt;next-&gt;prev = p; <span class="comment">/* 将下一节点的prev链接至前一节点 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	p-&gt;next = q-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实际应用-1"><a href="#实际应用-1" class="headerlink" title="实际应用"></a>实际应用</h3><p>例题1:已知头指针 h 指向一个带头节点的非空单循环链表，节点结构为data+next，其中p是尾指针，q是临时指针，要删除链表的第一个元素，正确的代码为：</p>
<ul>
<li>单向链表</li>
</ul>
<p>常规情况下，如下代码即可完成功能：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">q = h-&gt;next;</span><br><span class="line">h-&gt;next = q-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure>

<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="13_delete_node_in_cycle_1.jpg" alt="image can't load." style="zoom:15%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    单向链表/非单节点自循环链表<!--标题-->
    </center>
</div>

<p>但显然，题干为循环链表，可能出现待删除节点自循环的情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">q = h-&gt;next;</span><br><span class="line">h-&gt;next = q-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(q == p)  <span class="comment">/* 考虑待删除节点是否是尾指针 */</span> </span><br><span class="line">&#123;</span><br><span class="line">    h-&gt;next = h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure>

<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="13_delete_node_in_cycle_2.jpg" alt="image can't load." style="zoom:15%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    单节点自循环链表<!--标题-->
    </center>
</div>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table>
<thead>
<tr>
<th></th>
<th align="center">顺序表</th>
<th align="center">链表</th>
</tr>
</thead>
<tbody><tr>
<td>存储空间</td>
<td align="center">预先分配，可能闲置或溢出</td>
<td align="center">动态分配</td>
</tr>
<tr>
<td>存储密度</td>
<td align="center">1，无需额外存储表示节点逻辑关系</td>
<td align="center">小于1</td>
</tr>
<tr>
<td>存取元素</td>
<td align="center">随机存取，按位置时间复杂度为O(1)</td>
<td align="center">顺序存取，按位置时间复杂度为O(n)</td>
</tr>
<tr>
<td>插入删除</td>
<td align="center">平均移动表内一半元素，时间复杂度O(n)</td>
<td align="center">确定位置时，时间复杂度O(1)</td>
</tr>
<tr>
<td>适用情况</td>
<td align="center">表长变化不大，且能预估变化范围；<br>大多数进行随机访问，而非插入删除；</td>
<td align="center">长度变化大；<br>经常进行插入删除；</td>
</tr>
</tbody></table>
<p>例如常见的RTOS任务调度、TCP状态切换常用链表管理各个TCB控制块、消息缓存区，而具体的UART、CAN等消息接收区使用顺序表。</p>
<p align="center">---------------------------  End  ---------------------------</p>

<blockquote>
<p><em>读书不觉已春深，一寸光阴一寸金。–《白鹿洞二首·其一》</em></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机类</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-01-引言</title>
    <url>/2025/08/09/DS-01-Introduction/</url>
    <content><![CDATA[<p>本博文基于C语言的内容引入数据结构的时间、空间复杂度概念，并补充等差数列、累加和数列、等比数列等数学理论。</p>
<span id="more"></span>

<p>数据结构可以拆分为两个内容，即数据+结构。</p>
<h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><ul>
<li><p><strong>首先，数据从哪儿来？到哪儿去？</strong></p>
<p>数据从生活各处中来，而目的是用数据驱动业务。</p>
</li>
<li><p><strong>结构又是什么？</strong></p>
<p>即数据的组织形式，比如数组、比如链表。</p>
<p><strong>在特定的情境下，以往所用的数据类型无法基于需求合理地组织数据，此时需要自己设计一套新的数据组织形式来解决问题。</strong></p>
<p><strong>数据结构是一种存储、组织数据的方式，旨在方便访问和修改。任何一致数据结构都有各自的优劣。</strong></p>
</li>
</ul>
<h2 id="C基础"><a href="#C基础" class="headerlink" title="C基础"></a>C基础</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>实现某个具体功能的代码块</li>
<li>增加代码复用性</li>
<li>降低编程难度</li>
<li>函数不被调用就不会执行</li>
<li>对内隐藏细节，对外暴露接口</li>
</ul>
<p>基于需求对函数设定参数、设定返回值。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>C语言中的字符串是按照字符数据进行存储的，并没有这种数据类型。</p>
<blockquote>
<p>C#中有string类型</p>
</blockquote>
<ul>
<li><p>存储时字符串尾部带有 <code>\0</code>结束符</p>
</li>
<li><p>可在定义时直接初始化赋值，也可在定义后使用<code>strcpy()</code>赋值</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> arr1[<span class="number">11</span>] = <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line"><span class="type">char</span> arr2[<span class="number">11</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(arr2,<span class="string">&quot;HelloWorld&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>依据冯诺伊曼结构，计算机操作系统通常包括输入&#x2F;输出设备，主存储器、辅存储器、控制器、运算器。</p>
<p><strong>内存条、显卡、适配卡都各自有其存储地址空间。操作系统将设备的存储地址空间抽象为一个巨大的一维数组空间，如常说的32位&#x2F;64位机。</strong></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li>相同数据类型的集合</li>
<li>数组长度在定义时已经确定</li>
<li>n元素的数组下标为0~n-1</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">11</span>];</span><br><span class="line"><span class="type">char</span> b[<span class="number">10</span>][<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>例如以上变量a：</p>
<ul>
<li>a：数组变量</li>
<li>*a：数组首元素</li>
</ul>
<p>再比如变量b：</p>
<ul>
<li>b:数组地址</li>
<li>*b:数组首个行向量地址</li>
<li>**b：数组首个行向量中首个元素地址</li>
</ul>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针与数据在某种程度上可以实现相同的功能，比如 :</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = arr;</span><br></pre></td></tr></table></figure>

<p>则arr[i]和*(p+i)是一致的。指针在进行算术运算时，移动的是i与指针指向数据类型字节长度的乘积。</p>
<p>p+i的实际地址为p向后移动sizeof(int)*i。</p>
<table>
<thead>
<tr>
<th align="center">有符号</th>
<th align="center">无符号</th>
<th align="center">32位</th>
<th align="center">64位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">char</td>
<td align="center">unsigned char</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">unsigned short</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">unsigned  int</td>
<td align="center">4</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">unsigned long</td>
<td align="center">4</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center"></td>
<td align="center">4</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center"></td>
<td align="center">8</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体是一个或多个变量的集合，变量可以是不同的类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常来说，结构体之间的传递也使用指针以提高效率。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> *<span class="title">p</span>;</span></span><br><span class="line">p-&gt;x = <span class="number">1</span>;</span><br><span class="line">(*pp).y = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>有些情况下，为了更清晰的表明结构体的功能，通常会使用别名：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果后续需要用作链表，需要结构体名和别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125; <span class="type">point_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不需要用作链表，可以直接省区结构体名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;<span class="type">point_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><ul>
<li><p>静态&#x2F;全局内存</p>
<p>静态声明的变量和全局变量使用这部分内存，程序开始运行时分配，程序结束才消失</p>
</li>
<li><p>自动内存（栈）</p>
<p>函数内局部变量，函数被调用时才创建</p>
</li>
<li><p>动态内存（堆）</p>
<p>根据需求写代码动态分配内存，需要程序主动释放。</p>
</li>
</ul>
<h2 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h2><h3 id="等差数列"><a href="#等差数列" class="headerlink" title="等差数列"></a>等差数列</h3><p>假设有n项元素，其中a<del>1</del>至a<del>n</del>中每两项之间的差值为d，则其前n项和<br>$$<br>S_n &#x3D; \frac{n(a_1+a_n)}{2}<br>$$<br>由于<br>$$<br>a_n &#x3D; a_1 + (n-1)d<br>$$<br>所以前n项和也可表示为：<br>$$<br>S_n &#x3D; na_1 + \frac{n(n-1)d}{2}<br>$$<br>当a<del>1</del>与d均为1时:<br>$$<br>S_n &#x3D; \frac{n(n+1)}{2}<br>$$</p>
<h3 id="累加和数列"><a href="#累加和数列" class="headerlink" title="累加和数列"></a>累加和数列</h3><p>累加和数列是在等差数列的基础上再度累加。即</p>
<ul>
<li>b<del>1</del> &#x3D; S<del>1</del> &#x3D; a<del>1</del></li>
<li>b<del>2</del> &#x3D; S<del>2</del> &#x3D; a<del>1</del>+a<del>2</del></li>
<li>b<del>3</del> &#x3D; S<del>3</del> &#x3D; a<del>1</del>+a<del>2</del>+a<del>3</del></li>
<li>…</li>
<li>b<del>n</del> &#x3D; S<del>n</del> &#x3D; a<del>1</del>+a<del>2</del>+… + a<del>n</del> &#x3D; n(a<del>1</del>+a<del>n</del>)&#x2F;2</li>
</ul>
<p>我们假设，数列b的前n项和为T<del>n</del>，则有<br>$$<br>T_n &#x3D; \sum_{k&#x3D;1}^nS_k  &#x3D;  \sum_{k&#x3D;1}^n(\frac{k}{2}(2a_1+(k-1)d))<br>$$<br>展开后可得：<br>$$<br>T_n &#x3D;  a_1\sum_{k&#x3D;1}^nk + \frac{d}{2}\sum_{k&#x3D;1}^n(k^2-k)<br>$$</p>
<p>利用求和公式计算得：<br>$$<br>T_n &#x3D;  a_1\frac{n(n+1)}{2} + \frac{d}{2}(\frac{n(n+1)(2n+1)}{6} - \frac{n(n+1)}{2})<br>$$</p>
<p>整理可得：<br>$$<br>T_n &#x3D;  a_1\frac{n(n+1)}{2} + d\frac{n(n+1)(n-1)}{6}<br>$$</p>
<p>合并同类项得：<br>$$<br>T_n &#x3D;  \frac{n(n+1)}{2}(a_1+\frac{d(n-1)}{3})<br>$$<br>我们假设，a<del>1</del> 和d均为1，则数列的前n项和为：<br>$$<br>T_n &#x3D; \frac{n(n+1)(n+2)}{6}<br>$$</p>
<h3 id="等比数列"><a href="#等比数列" class="headerlink" title="等比数列"></a>等比数列</h3><p>数列{a<del>n</del>}满足相邻项的比值为常数q，其通项式为<br>$$<br>a_n &#x3D; a_1q^{n-1}<br>$$<br>因此S<del>n</del>的表达式为：<br>$$<br>S_n &#x3D; a_1 + a_1q + a_1q^2 + .. a_1q^{n-1}<br>$$<br>两端同时成q以后减去上式：<br>$$<br>(q-1)S_n &#x3D; a_1(q^n-1)<br>$$<br>可得：<br>$$<br>S_n &#x3D; a_1\frac{1-q^n}{1-q}<br>$$</p>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><ul>
<li>时间复杂度</li>
<li>空间复杂度</li>
<li>抽象数据类型ADT</li>
</ul>
<p>数据结构与算法存在本质联系。在研究某一类型的数据结构时，总要涉及其上施加的运算，只有通过对定义运算的研究，才能真正理解数据结构的定义与作用。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度，也称渐进复杂度，T(n) &#x3D; O(f(n))。随问题规模n增大，算法执行时间增长率和f(n)增长率成正比。</p>
<p><strong>程序运行时间主要和执行每条语句的耗时、每条语句的执行频率有关。</strong></p>
<p>语句执行要由源程序翻译为目标代码，目标代码再装配执行。每个语句执行一次需要的具体时间和机器的软&#x2F;硬件环节有关。<span style="color:red"><strong>因此，算法分析并非是实际执行时间，而是针对算法中语句执行次数做出估计，得到算法执行时间的信息。</strong></span></p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; i++) <span class="comment">//循环n次，额外1次判断频度为n+1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;=n; j++)<span class="comment">//同上</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k =<span class="number">1</span>; k&lt;=n; k++)<span class="comment">//同上</span></span><br><span class="line">        &#123;</span><br><span class="line">            c[i][j] += a[i][k]* b[k][j]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上方代码的<code>f(n) = n^3</code>，当n&#x3D;1时，<code>f(n) = O(1)</code>。</p>
<p>有以下区分：</p>
<ul>
<li>最好时间复杂度：算法再最好情况下的时间复杂度</li>
<li><strong>最坏时间复杂度：算法在最坏情况下的时间复杂度</strong></li>
<li>平均时间复杂度：算法在所有可能的情况下，按输入实例等概率出现时的加权平均值</li>
</ul>
<p>通常只讨论最坏时间复杂度。</p>
<h4 id="常量阶"><a href="#常量阶" class="headerlink" title="常量阶"></a>常量阶</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x++; <span class="comment">//频度为1</span></span><br><span class="line">s = <span class="number">0</span>; <span class="comment">//频度为1</span></span><br></pre></td></tr></table></figure>

<p><code>f(n) = 1+1;</code>复杂度为O(1)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    x++;</span><br><span class="line">    s = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法执行时间不随问题的规模增长而增长，尽管执行了上万次，其仍然是常量。</p>
<h4 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">	x++; <span class="comment">//频度为n</span></span><br><span class="line">    s=<span class="number">0</span>; <span class="comment">//频度为n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>f(n)=(n+1)+n+n = 3n+1</code>，即复杂度T(n) &#x3D; O(n)。</p>
<h4 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x++; <span class="comment">//频度为n</span></span><br><span class="line">s=<span class="number">0</span>; <span class="comment">//频度为n	</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=n; j++)<span class="comment">//频度为n	</span></span><br><span class="line">    &#123;</span><br><span class="line">        y++;<span class="comment">//频度为n	</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>f(n)=(n+1)*n = n^2+n</code>，即复杂度T(n) &#x3D; O(n^2)。</p>
<h4 id="立方阶"><a href="#立方阶" class="headerlink" title="立方阶"></a>立方阶</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++)<span class="comment">//频度为n</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=i; j++) <span class="comment">//频度为1+2+..+i	</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k =<span class="number">0</span>; k&lt;=j;k++ )<span class="comment">//频度为1+(1+2)+(1+2+3)..+n*(n+1)/2</span></span><br><span class="line">        &#123;</span><br><span class="line">        	y++;<span class="comment">//频度为n*(n+1)*(n+2)/6	</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>f(n)=n*(n*(n+1)/2) = n^2+n</code>，即复杂度T(n) &#x3D; O(n^2)。</p>
<h4 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i=i*<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">	x++; </span><br><span class="line">    s=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">次数</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">t</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">8</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">i</td>
<td align="center">2^0</td>
<td align="center">2^1</td>
<td align="center">2^2</td>
<td align="center">2^3</td>
<td align="center">2^(t-1)</td>
</tr>
</tbody></table>
<p>2^t-1 &gt; n时循环退出，可得t&gt;log<del>2</del>n + 1</p>
<p>即T(n) &#x3D; O(log<del>2</del>n)，故也可以推导出倍数为其他值时的时间复杂度。</p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>1.例如：设n是描述问题规模的非负整数，下面程序片段的时间复杂度是();</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(x&lt;n/<span class="number">2</span>)</span><br><span class="line">    x = <span class="number">2</span>*x;</span><br></pre></td></tr></table></figure>

<p>实现复杂度的核心目的是找到语句的执行频次，也即什么时候退出循环，把每次x的值列出</p>
<table>
<thead>
<tr>
<th align="center">次数</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">t</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i</td>
<td align="center">2^2</td>
<td align="center">2^3</td>
<td align="center">2^4</td>
<td align="center">2^5</td>
<td align="center">2^t+1</td>
</tr>
</tbody></table>
<p>即2^t+1^ &gt; n&#x2F;2，可得t&gt;log<del>2</del>n - 2，时间复杂度为O(log<del>2</del>n)。</p>
<p>2.再如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>, sum =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sum &lt; n) sum += ++i;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的思路，列i与sum的变化表格：</p>
<table>
<thead>
<tr>
<th align="center">次数</th>
<th>1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">t</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i</td>
<td>1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">t</td>
</tr>
<tr>
<td align="center">sum</td>
<td>1</td>
<td align="center">1+2</td>
<td align="center">1+2+3</td>
<td align="center">1+..+4</td>
<td align="center">t(t+1)&#x2F;2</td>
</tr>
</tbody></table>
<p>即t(t+1)&#x2F;2 &gt;&#x3D; n，推知t &gt; n^1&#x2F;2^，时间复杂度为O (n^1&#x2F;2^)。</p>
<p><span style="color:red"><strong>此处曾出现一处误解，即在t次将sum的值计算为n(n+1)&#x2F;2 &gt; n，从而得出复杂度为O(n)。根本原因在于将循环次数与问题规模混用一个n值。</strong></span></p>
<p>3.再如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i*=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">次数</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">t</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i</td>
<td align="center">2^0</td>
<td align="center">2^1</td>
<td align="center">2^2</td>
<td align="center">2^3</td>
<td align="center">2^(t-1)</td>
</tr>
<tr>
<td align="center">内层次数</td>
<td align="center">2^0</td>
<td align="center">2^1</td>
<td align="center">2^2</td>
<td align="center">2^3</td>
<td align="center">2^(t-1)</td>
</tr>
</tbody></table>
<p>其中外层函数的执行次数为2^(t-1) &gt;&#x3D;n ，可得t&gt;log<del>2</del>n + 1。</p>
<p>而内层每次执行执行的次数与外圈i相等，故最内层语句总执行频度为：<br>$$<br>f(n) &#x3D; 2^0 + 2^1  + .. +  2^{t-1} &#x3D; 2\frac{1-2^t}{1-2} &#x3D; 2^{t+1}-2<br>$$<br>带入t&#x3D;log<del>2</del>n得f(n) &#x3D; 2n，故T(n) &#x3D; O(n)；</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>空间复杂度主要描述某个算法对应的程序想在计算机上执行，<strong>除去用来存储代码和输入数据的内存空间外，还需要额外的空间</strong>。</p>
<p>S(n) &#x3D; O(f(n))。</p>
<h3 id="抽象数据类型ADT"><a href="#抽象数据类型ADT" class="headerlink" title="抽象数据类型ADT"></a>抽象数据类型ADT</h3><p>ADT是一种编程概念，用于定义数据类型及其操作，不涉及实现细节。优势是对外隐藏细节，对内隐藏接口。</p>
<p>在C中，ADT通常通过结构体和函数实现。</p>
<p align="center">---------------------------  End  ---------------------------</p>

<blockquote>
<p>算法 + 数据结构 &#x3D; 程序</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机类</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-08-三元递增子序列</title>
    <url>/2025/08/09/LeetCode-08-Increasing_Triplet/</url>
    <content><![CDATA[<p>LeetCode算法题：元素之积。</p>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code> ，判断这个数组中是否存在长度为 <code>3</code> 的递增子序列。</p>
<p>如果存在这样的三元组下标 <code>(i, j, k)</code> 且满足 <code>i &lt; j &lt; k</code> ，使得 <code>nums[i] &lt; nums[j] &lt; nums[k]</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5 * 105</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先区分题干要求，递增三元子序列。由原序列中任意n个元素可组成一个n元子序列，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<p>其中<code>[1,2,4]</code>、<code>[1,4,7]</code>均为a的子序列，如果有顺序要求，则判断条件更广。</p>
<p>因此，最基础的思路是使用三重循环遍历，直至找到，或者遍历完成。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方案A-遍历"><a href="#方案A-遍历" class="headerlink" title="方案Ａ-遍历"></a>方案Ａ-遍历</h3><p>以首元素为i的起点，次元素为j起点，第三个元素为k的起点。但是改方案嵌套三重循环，不适用数据量较大的情况。</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="A.jpg" alt="image can't load." style="zoom:100%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    三循环，时间O(n^3)<!--标题-->
    </center>
</div>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">increasingTriplet</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(numsSize &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numsSize<span class="number">-2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;numsSize - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=j+<span class="number">1</span>; k&lt;numsSize; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&lt;nums[j] &amp;&amp; nums[j]&lt;nums[k])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方案B-贪心"><a href="#方案B-贪心" class="headerlink" title="方案B-贪心"></a>方案B-贪心</h3><p>方案A的时间复杂度较大，换种思路，即三个元素相互对比，其大小关系只有以下几种：</p>
<ul>
<li>i &lt; j &lt; k，单调递增</li>
<li>i &lt; j，i &lt; k &lt; j，新数组在前方两个数据之间</li>
<li>k &lt; i &lt; j，新数据最小</li>
</ul>
<p><strong>因此定义min存储整个序列的最小值，second存储的数据不定，但一定保证前方存在一个数据&lt;second。</strong></p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="B.jpg" alt="image can't load." style="zoom:100%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    贪心，时间O(n)空间O(1)<!--标题-->
    </center>
</div>

<p>如上图，尽管最后的结果使用的是mid2、min3和末尾值，但在mid2之前一定有一个更小的min1（否则mid为初值<code>INT_MAX</code>，不可能有比其更大的值）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">increasingTriplet</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(numsSize &lt; <span class="number">3</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> mid = INT_MIX; <span class="comment">// 初始化为最大值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">     	<span class="comment">// 三元素递增</span></span><br><span class="line">        <span class="keyword">if</span>(mid &lt; nums[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 刷新次最小的元素值，前方一定有比他更小的</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(min &lt; nums[i])</span><br><span class="line">        &#123;</span><br><span class="line">            mid = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            min = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p align="center">---------------------------  End  ---------------------------</p>
>*白日放歌须纵酒，青春作伴好还乡。--《 闻官军收河南河北》*]]></content>
      <tags>
        <tag>C</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-07-元素之积</title>
    <url>/2025/08/07/LeetCode-07-Product_ExceptSelf/</url>
    <content><![CDATA[<p>LeetCode算法题：元素之积。</p>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>LeetCode：<a href="https://leetcode.cn/studyplan/leetcode-75/">LeetCode 75 - 学习计划</a>-07-数组元素除去自身外的乘积</p>
<p>给你一个整数数组 <code>nums</code>，返回 数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积 。</p>
<p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p>
<p>请不要使用除法，且在 <code>O(n)</code> 时间复杂度内完成此题。</p>
<p><strong>进阶：</strong> <code>O(1)</code> 的额外空间复杂度？</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最简易的想法是循环计算所有元素的乘积，随后除去元素自身。</p>
<p>在限制除法后将整个乘积过程拆分为两个：</p>
<ul>
<li>元素左侧的数值之积</li>
<li>元素右侧的数值之积</li>
</ul>
<p>问题即演变为如何最大程度的减小空间复杂度。</p>
<ol>
<li>采用长缓存数组L、R分别存储元素左侧右侧之积，空间复杂度O(2n)</li>
<li>双循环。anwser [i] &#x3D; anwser[i-1]*nums[i]，将计算结果直接存入anwser数组内，额外使用int变量存储右侧之积，空间复杂度O(1)。</li>
<li>单循环。初始化输出数组为全1，额外使用两个int变量L、R存储左右之积，从两侧开始相乘。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方案A-LR数组"><a href="#方案A-LR数组" class="headerlink" title="方案A-LR数组"></a>方案A-LR数组</h3><p>LR数组分别计算并存入新数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">productExceptSelf</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    *returnSize = numSize;</span><br><span class="line">     <span class="type">int</span> *answer = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*numSize);</span><br><span class="line">     <span class="type">int</span> *L = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*numSize);</span><br><span class="line">     <span class="type">int</span> *R = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*numSize);</span><br><span class="line">     L[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">     R[numSize - <span class="number">1</span>] =<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;numSize; i++)</span><br><span class="line">     &#123;</span><br><span class="line">        L[i] = L[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>];</span><br><span class="line">        R[numSize-i<span class="number">-1</span>] = R[numSize - i] * nums[numSize - i];</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;numSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        answer[i] = L[i] * R[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(L);</span><br><span class="line">    <span class="built_in">free</span>(R);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方案B-双循环"><a href="#方案B-双循环" class="headerlink" title="方案B-双循环"></a>方案B-双循环</h3><ul>
<li>首次循环计算元素左侧之积并填入answer</li>
<li>二次循环计算元素右侧之积suffix，并计算新answer</li>
</ul>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="B.jpg" alt="image can't load." style="zoom:100%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    单循环O(1)<!--标题-->
    </center>
</div>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">productExceptSelf</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    *returnSize = numSize;</span><br><span class="line">     <span class="type">int</span> *answer = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*numSize);</span><br><span class="line">    answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> suffix = <span class="number">1</span>; <span class="comment">//右侧之积</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//正向，元素左侧之积存入answer中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;numSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        answer[i] = answer[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//反向，乘右侧之积suffix，并刷新新值    </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=numSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		answer[numSize-i] *= suffix;</span><br><span class="line">        suffix *= nums[numSize-i];</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方案C-单循环"><a href="#方案C-单循环" class="headerlink" title="方案C-单循环"></a>方案C-单循环</h3><p>既然方案B中本身两次循环进行双向计算，故可进一步优化为单循环内从左至右计算两次：</p>
<ul>
<li>使用L、R存储某元素两侧的数值之积，L从左侧计算，R从右侧计算。</li>
<li>answer[i]与answer[n-i-1]正向反向两次计算，则单次循环内实现对数据的两次乘积</li>
</ul>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="C.jpg" alt="image can't load." style="zoom:100%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    单循环O(1)<!--标题-->
    </center>
</div>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">productExceptSelf</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    *returnSize = numSize;</span><br><span class="line">     <span class="type">int</span> *answer = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*numSize);</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; numSize; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         answer[i] = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> L = <span class="number">1</span>, R= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;numSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L *= nums[i - <span class="number">1</span>];</span><br><span class="line">        R *= nums[n - i];</span><br><span class="line">        </span><br><span class="line">        answer[i] *= L;</span><br><span class="line">        answer[n-i<span class="number">-1</span>] *= R;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p align="center">---------------------------  End  ---------------------------</p>

<blockquote>
<p><em>云中谁寄锦书来，雁字回时，月满西楼。–《一剪梅·红藕香残玉簟秋》</em></p>
</blockquote>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-06-Reverse_Words</title>
    <url>/2025/08/03/LeetCode-06-Reverse_Words/</url>
    <content><![CDATA[<p>LeetCode算法题：字符串中单词顺序反转。</p>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>LeetCode：<a href="https://leetcode.cn/studyplan/leetcode-75/">LeetCode 75 - 学习计划</a>-06-反转字符串中的单词</p>
<p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p>
<p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p>
<p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p>
<p>**注意：**输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>从模块的功能看，输入内容可以有以下几种情况：</p>
<ol start="3">
<li>单字符单词、数字</li>
<li>混合数字的多字符单词</li>
</ol>
<p>输出的情况较为固定，单词+空格…</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方案A-双指针"><a href="#方案A-双指针" class="headerlink" title="方案A-双指针"></a>方案A-双指针</h3><p>采用左右指针从输入字符串中从后向前找单词。</p>
<ol>
<li>right &#x3D; left &#x3D; len -1，从最右侧开始，寻找完整单词</li>
<li>以空格为界寻找左边界left</li>
<li>更新right &#x3D; left ，寻找下一个单词</li>
<li>直到right &#x3D; 0地址索引终止。</li>
</ol>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="reverseString_A.jpg" alt="image can't load." style="zoom:100%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    自后向前找单词O(n)<!--标题-->
    </center>
</div>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">reverseWords</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    assert(s);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">char</span>* out_string = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (len + <span class="number">1</span>));</span><br><span class="line">    <span class="type">char</span>* out_idx = out_string;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* right = s + len - <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span>* left = right;</span><br><span class="line">    <span class="comment">//处理单字符</span></span><br><span class="line">    <span class="keyword">if</span> (right == s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="type">void</span>*)out_idx, (<span class="type">void</span>*)left, <span class="keyword">sizeof</span>(<span class="type">char</span>) * (right - left + <span class="number">1</span>));</span><br><span class="line">        out_idx += right - left + <span class="number">1</span>;</span><br><span class="line">        *out_idx = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> out_string;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理多字符</span></span><br><span class="line">    <span class="keyword">while</span> (right &gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (*right == <span class="string">&#x27; &#x27;</span> &amp;&amp; right &gt; s) right--;</span><br><span class="line">        <span class="keyword">if</span> (*right == <span class="string">&#x27; &#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">        left = right;</span><br><span class="line">        <span class="keyword">while</span> (*left != <span class="string">&#x27; &#x27;</span> &amp;&amp; left &gt; s) left--;</span><br><span class="line">        (left != s || (left == s &amp;&amp; *left == <span class="string">&#x27; &#x27;</span>)) ? left += <span class="number">1</span> : <span class="number">0</span>; <span class="comment">//判断是否为首字符，防止越界</span></span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="type">void</span>*)out_idx, (<span class="type">void</span>*)left, <span class="keyword">sizeof</span>(<span class="type">char</span>) * (right - left + <span class="number">1</span>));</span><br><span class="line">        out_idx += right - left + <span class="number">1</span>;</span><br><span class="line">        *(out_idx++) = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        right = left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *(out_idx - <span class="number">1</span>) = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//字符串结束符</span></span><br><span class="line">    <span class="keyword">return</span> out_string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>此方案指针是从后向前移动，需要注意数组越界&#x2F;指针越界。其中leetcode会报错，本地VS可运行成功。</p>
<blockquote>
<p>runtime error: store to address 0x502000000040 with insufficient space for an object of type ‘char’ </p>
</blockquote>
<p>另外此函数使用strlen函数空间复杂度为O(n)，需额外占用部分空间。</p>
<h3 id="方案B-双反转"><a href="#方案B-双反转" class="headerlink" title="方案B-双反转"></a>方案B-双反转</h3><p>由于需要反转字符串内的单词顺序，因此可以分为以下几个步骤：</p>
<ol>
<li>去除首尾空格、去除中间空格</li>
<li>反转整个字符串</li>
<li>反转单个单词</li>
</ol>
<p>此种方案可以在原有字符串上进行改动，空间复杂度为O (1) ，<strong>修减空格、反转函数</strong>进行模块化。</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="reverseString_B.jpg" alt="image can't load." style="zoom:100%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    反转字符串再反转单词O(1)<!--标题-->
    </center>
</div>

<ol>
<li>从前之后滤除空格。遇到单词后的空格&#x2F;尾部结束符时仅输出1次空格，将后方字符前移。将尾部替换为结束符<code>\0 </code>。</li>
<li>反转整个字符串。实现单词位置的反转。</li>
<li>反转单词。以<strong>空格&#x2F;结束符</strong>为提示符查找单个单词进行反转。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trimString</span><span class="params">(<span class="type">char</span>* s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修剪前侧空格</span></span><br><span class="line">    <span class="keyword">while</span> (j&lt;len &amp;&amp; s[j] == <span class="string">&#x27; &#x27;</span>) j++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修建中间空格</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[j] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i++] = s[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            s[i++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; len &amp;&amp; s[j] == <span class="string">&#x27; &#x27;</span>) j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修剪尾部空格</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) i--;</span><br><span class="line">    s[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>* s,<span class="type">int</span> start,<span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = s[start];</span><br><span class="line">        s[start] = s[end];</span><br><span class="line">        s[end] = tmp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">reverseWords</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span> || *s == <span class="string">&#x27;\0&#x27;</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    trimString(s);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转整个字符串</span></span><br><span class="line">    reverseString(s,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span> || s[i] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            reverseString(s, start, i - <span class="number">1</span>);</span><br><span class="line">            start = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p align="center">---------------------------  End  ---------------------------</p>

<blockquote>
<p><em>远上寒山石径斜，白云深处有人家。–《山行》</em></p>
</blockquote>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-05-reverse_Vowels</title>
    <url>/2025/08/02/LeetCode-05-Reverse_Vowels/</url>
    <content><![CDATA[<p>LeetCode算法题：字符串中元音字符翻转。</p>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>LeetCode：<a href="https://leetcode.cn/studyplan/leetcode-75/">LeetCode 75 - 学习计划</a>-05-反转字符串中的元音字母</p>
<p>给你一个字符串 <code>s</code> ，仅反转字符串中的所有元音字母，并返回结果字符串。</p>
<p>元音字母包括 <code>&#39;a&#39;</code>、<code>&#39;e&#39;</code>、<code>&#39;i&#39;</code>、<code>&#39;o&#39;</code>、<code>&#39;u&#39;</code>，且可能以大小写两种形式出现不止一次。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>待查找字符已知，从左右两端搜索对应值即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isVowels</span><span class="params">(<span class="type">char</span> ch)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">reverseVowels</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    assert(s);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* left = s;</span><br><span class="line">    <span class="type">char</span>* right =  s + <span class="built_in">strlen</span>(s) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right - left &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isVowels(*left))</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isVowels(*right))</span><br><span class="line">        &#123;</span><br><span class="line">            right--;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = *left;</span><br><span class="line">            *left = *right;</span><br><span class="line">            *right = tmp;</span><br><span class="line">            left++;</span><br><span class="line">            right--; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> arrVowels[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;U&#x27;</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">isVowels</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(arrVowels)/<span class="keyword">sizeof</span>(<span class="type">char</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arrVowels[i] == ch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方案使用const数组对字符进行封装，适合多次调用时功能的扩展移植。功能采用单个while循环完成，但内部if-else会影响流水线，因此进行优化为双重循环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">reverseVowels</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    assert(s);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* left = s;</span><br><span class="line">    <span class="type">char</span>* right =  s + <span class="built_in">strlen</span>(s) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right - left &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(isVowels(*left))</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(isVowels(*right))</span><br><span class="line">        &#123;</span><br><span class="line">            right--;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = *left;</span><br><span class="line">            *left = *right;</span><br><span class="line">            *right = tmp;</span><br><span class="line">            left++;</span><br><span class="line">            right--; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果向修改isVowels函数，可以调整为如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> arrVowels[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;U&#x27;</span>&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isVowels</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(arrVowels)/<span class="keyword">sizeof</span>(<span class="type">char</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arrVowels[i] == ch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而若调用次数不多，可使用以下代码，逻辑或||相对于逻辑与&amp;&amp;减少判断次数，加快运行时间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isVowels</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if(ch!=&#x27;a&#x27;&amp;&amp; ch!=&#x27;A&#x27;&amp;&amp; ch!=&#x27;o&#x27;&amp;&amp; ch!=&#x27;O&#x27;&amp;&amp; ch!=&#x27;e&#x27;&amp;&amp; ch!=&#x27;E&#x27;&amp;&amp; ch!=&#x27;i&#x27;&amp;&amp; ch!=&#x27;I&#x27;&amp;&amp;ch!=&#x27;u&#x27;&amp;&amp; ch!=&#x27;U&#x27;)</span></span><br><span class="line"><span class="comment">        return 1;</span></span><br><span class="line"><span class="comment">    else </span></span><br><span class="line"><span class="comment">        return 0;   </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      <span class="keyword">return</span> (ch==<span class="string">&#x27;a&#x27;</span>|| ch==<span class="string">&#x27;A&#x27;</span>|| ch==<span class="string">&#x27;o&#x27;</span>|| ch==<span class="string">&#x27;O&#x27;</span>|| ch==<span class="string">&#x27;e&#x27;</span>|| ch==<span class="string">&#x27;E&#x27;</span>|| ch==<span class="string">&#x27;i&#x27;</span>|| ch==<span class="string">&#x27;I&#x27;</span>||ch==<span class="string">&#x27;u&#x27;</span>|| ch==<span class="string">&#x27;U&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p align="center">---------------------------  End  ---------------------------</p>

<blockquote>
<p><em>缺月挂疏桐，漏断人初静。–《卜算子·黄州定慧院寓居作》</em></p>
</blockquote>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-04-种花问题</title>
    <url>/2025/07/24/LeetCode-04-Can_Place_Flowers/</url>
    <content><![CDATA[<p>LeetCode算法题：种花问题。</p>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>LeetCode：<a href="https://leetcode.cn/studyplan/leetcode-75/">LeetCode 75 - 学习计划</a>-04-种花问题</p>
<p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给你一个整数数组 <code>flowerbed</code> 表示花坛，由若干 <code>0</code> 和 <code>1</code> 组成，其中 <code>0</code> 表示没种植花，<code>1</code> 表示种植了花。另有一个数 <code>n</code> ，能否在不打破种植规则的情况下种入 <code>n</code> 朵花？能则返回 <code>true</code> ，不能则返回 <code>false</code> 。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>花不能相邻，则可用连续三块地无花进行分析。即<code>i-1,i,i+1</code>均为空。</p>
<p>但需考虑几个特殊情况：</p>
<ul>
<li>待插花数n&#x3D;0</li>
<li>花坛长度为1、2或其他长度（可直接判断插花或不插）</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方案A"><a href="#方案A" class="headerlink" title="方案A"></a>方案A</h3><p>分别考虑特殊情况和长度大于2时的通用情况，遍历所有情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">canPlaceFlowers</span><span class="params">(<span class="type">int</span>* flowerbed, <span class="type">int</span> flowerbedSize, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    assert(flowerbed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 待插入0 */</span></span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 花圃仅一块 */</span></span><br><span class="line">    <span class="keyword">if</span>(flowerbedSize == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        flowerbed[<span class="number">0</span>]==<span class="number">0</span>? (n--):<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> n&gt;<span class="number">0</span>?<span class="literal">false</span>:<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向两端插花 */</span></span><br><span class="line">    <span class="keyword">if</span>(flowerbed[<span class="number">0</span>]+flowerbed[<span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        flowerbed[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flowerbed[flowerbedSize<span class="number">-1</span>]+flowerbed[flowerbedSize<span class="number">-2</span>] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        flowerbed[flowerbedSize<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 循环在中间插花 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; flowerbedSize &gt; <span class="number">2</span> &amp;&amp; i&lt; flowerbedSize<span class="number">-1</span> &amp;&amp; n &gt; <span class="number">0</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((flowerbed[i<span class="number">-1</span>] | flowerbed[i] | flowerbed[i+<span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flowerbed[i++] = <span class="number">1</span>; <span class="comment">/* 插花后向后跳 */</span></span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方案B"><a href="#方案B" class="headerlink" title="方案B"></a>方案B</h3><div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="slip_window.jpg" alt="image can't load." style="zoom:100%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    滑动窗逻辑<!--标题-->
    </center>
</div>

<p>使用滑动窗口逻辑，设定</p>
<ul>
<li>起始左窗口<code>left = -1,right = 0</code>。</li>
<li>检索到right内的值为1时，刷新左右边界值</li>
<li>左右边界间距大于3时，可插入一个</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">canPlaceFlowers</span><span class="params">(<span class="type">int</span>* flowerbed, <span class="type">int</span> flowerbedSize, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    assert(flowerbed);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left=<span class="number">-1</span>,right=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(flowerbedSize==<span class="number">1</span>)	<span class="comment">//考虑待插入数组只有一个空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        flowerbed[<span class="number">0</span>] == <span class="number">0</span> ? (n--):<span class="number">0</span>;	</span><br><span class="line">        <span class="keyword">return</span>  n&lt;=<span class="number">0</span>;		<span class="comment">//需考虑n=0的情况</span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right &lt; flowerbedSize &amp;&amp; n&gt;<span class="number">0</span>) <span class="comment">/* 未到达右边界，且无新花需要插入 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flowerbed[right] == <span class="number">1</span>)	<span class="comment">/* 刷新左边界 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = right+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        right ++;   </span><br><span class="line"></span><br><span class="line">        <span class="comment">/*分别判断在中间或花圃右边界是否能插入新花*/</span></span><br><span class="line">        <span class="keyword">if</span>(right-left&gt;=<span class="number">3</span> || (right == flowerbedSize &amp;&amp; (right-left)&gt;<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            n--;</span><br><span class="line">            left += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n&lt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p align="center">---------------------------  End  ---------------------------</p>

<blockquote>
<p><em>星星之火</em></p>
</blockquote>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-03-最多糖果的孩子</title>
    <url>/2025/07/24/LeetCode-03-Kids_With_Candies/</url>
    <content><![CDATA[<p>LeetCode算法题：寻找糖果数最多的孩子。</p>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>LeetCode：<a href="https://leetcode.cn/studyplan/leetcode-75/">LeetCode 75 - 学习计划</a>-03-拥有最多糖果的孩子</p>
<p>有 <code>n</code> 个有糖果的孩子。给你一个数组 <code>candies</code>，其中 <code>candies[i]</code> 代表第 <code>i</code> 个孩子拥有的糖果数目，和一个整数 <code>extraCandies</code> 表示你所有的额外糖果的数量。</p>
<p>返回一个长度为 <code>n</code> 的布尔数组 <code>result</code>，如果把所有的 <code>extraCandies</code> 给第 <code>i</code> 个孩子之后，他会拥有所有孩子中 <strong>最多</strong> 的糖果，那么 <code>result[i]</code> 为 <code>true</code>，否则为 <code>false</code>。</p>
<p>注意，允许有多个孩子同时拥有 <strong>最多</strong> 的糖果数目。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p> 题目简单，两次循环即可。首次遍历出最大值，二次将变化后的累加值与最大值比较。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以下代码时间复杂度为O(n)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span>* <span class="title function_">kidsWithCandies</span><span class="params">(<span class="type">int</span>* candies, <span class="type">int</span> candiesSize, <span class="type">int</span> extraCandies, <span class="type">int</span>* returnSize)</span> </span><br><span class="line">&#123;</span><br><span class="line">    assert(candies);</span><br><span class="line">    assert(returnSize);</span><br><span class="line">    <span class="type">bool</span> *result = (<span class="type">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>)*candiesSize);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> candiesMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; candiesSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        candiesMax &lt; candies[i]? ( candiesMax = candies[i] ):<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>; i&lt;candiesSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         result[i] = (candies[i] + extraCandies &gt;= candiesMax)?  <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = candiesSize;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p align="center">---------------------------  End  ---------------------------</p>

<blockquote>
<p><em>有理想</em></p>
</blockquote>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP-02-ZYNQ7020 TCP例程自动协商失败解决办法</title>
    <url>/2025/07/19/TCP-02-ZYNQ_TCP_Demo_Error/</url>
    <content><![CDATA[<p>本博文介绍ZYNQ SDK默认Lwip Demo自动协商失败问题解决办法，如有相同情况，请先检查网线是不是千兆网…</p>
<span id="more"></span>

<h2 id="场景复现"><a href="#场景复现" class="headerlink" title="场景复现"></a>场景复现</h2><ul>
<li>开发环境：Xilinx Vivado 18.3 SDK</li>
<li>芯片：ZYNQ 7020</li>
<li>调试工具：串口调试助手</li>
<li>接线：开发板直连PC口</li>
</ul>
<p>使用SDK工具新建TCP echo server模板项目后，板验证报错信息如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Start PHY autonegotiation </span><br><span class="line">Waiting <span class="keyword">for</span> PHY to complete autonegotiation.</span><br><span class="line">Auto negotiation error  </span><br><span class="line">Phy setup error  </span><br><span class="line">Assert due to phy setup failure </span><br></pre></td></tr></table></figure>

<p>博主在手动设定速率后重新配置为自动协商试图复现异常，但是结果却又协商成功了？如下图。</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="image-20250719222443418.png" alt="image can't load." style="zoom:75%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    重新配置为自动协商<!--标题-->
    </center>
</div>

<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>优先放置解决办法，感兴趣的可以向下翻阅原因分析。</p>
<p>1.修改BSP配置</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="image-20250719191118162.png" alt="image can't load." style="zoom:55%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    phy link speed<!--标题-->
    </center>
</div>

<p>2.手动指定连接速度-100Mbps</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="image-20250719191417696.png" alt="image can't load." style="zoom:55%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    BSP's Setting<!--标题-->
    </center>
</div>

<p>3.注释掉<code>platform_zynq.c</code>文件中定时器回调函数<code>time_callback</code>中代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* For detecting Ethernet phy link status periodically */</span></span><br><span class="line">	<span class="comment">/* if (DetectEthLinkStatus == ETH_LINK_DETECT_INTERVAL) &#123;</span></span><br><span class="line"><span class="comment">		eth_link_detect(echo_netif);</span></span><br><span class="line"><span class="comment">		DetectEthLinkStatus = 0;</span></span><br><span class="line"><span class="comment">	&#125;	*/</span></span><br></pre></td></tr></table></figure>

<p>4.配置ip</p>
<ul>
<li><p>ZYNQ</p>
<div>            <!--块级封装-->
    <center>    <!--将图片和文字居中-->
    <img src="image-20250719192756638.png" alt="image can't load." style="zoom:75%"><!-- alt内为提示词-->
    <br>        <!--换行-->
   ZYNQ Config<!--标题-->
    </center>
</div>
</li>
<li><p>PC</p>
<div>            <!--块级封装-->
    <center>    <!--将图片和文字居中-->
    <img src="image-20250719192930341.png" alt="image can't load." style="zoom:75%"><!-- alt内为提示词-->
    <br>        <!--换行-->
   PC Config<!--标题-->
    </center>
</div></li>
</ul>
<p>5.串口调试工具配置</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="image-20250719193107631.png" alt="image can't load." style="zoom:65%"><!-- alt内为提示词-->
    <br>		<!--换行-->
   串口工具<!--标题-->
    </center>
</div>

<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><h3 id="IP配置错误？"><a href="#IP配置错误？" class="headerlink" title="IP配置错误？"></a>IP配置错误？</h3><p>最先考虑的是PC与ZYNQ开发板的ip地址不在同一网段，但将ip均配置在<code>192.168.1.xx</code>网段下之后仍然出现异常。</p>
<h3 id="PC端速度限制？"><a href="#PC端速度限制？" class="headerlink" title="PC端速度限制？"></a>PC端速度限制？</h3><div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="image-20250719223948825.png" alt="image can't load." style="zoom:65%"><!-- alt内为提示词-->
    <br>		<!--换行-->
   PC端网口速度<!--标题-->
    </center>
</div>

<p>众所周知，PC机在连接以太网之后可以更改连接速度。参考<a href="https://blog.csdn.net/wsnd123321/article/details/129457547">资料3</a>手动将PC端网口速率从自动协商指定为1Gbps，喜提<span style="color:red"><strong>网络未连接</strong></span>。</p>
<p>速度和双工配置重新调整为自动协商后，连接状态变为上图100Mbps。</p>
<h3 id="劣质网线…"><a href="#劣质网线…" class="headerlink" title="劣质网线…"></a>劣质网线…</h3><p>破案，是劣质网线不支持1000Mbps…</p>
<p><span style="color:red"><strong>从水晶头看到线芯颜色是银白色，胶皮标识为CAT5E超五类，找到订单查材质是铝镁合金、商品名为百兆网线…</strong></span></p>
<p>5m长的网线费用高达3.39，他能跑百兆我应该夸它耐造….</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://www.amengcc.cn/index.php/archives/1258/">zynq调试网口所遇到的问题记录 | AMENG</a></li>
<li><a href="https://www.amengcc.cn/index.php/archives/1260/">ZYNQ lwip 自适应网络速率 | AMENG</a></li>
<li><a href="https://blog.csdn.net/wsnd123321/article/details/129457547">修复 win10&#x2F;11 以太网网速被限制在 100Mbps_win11千兆网卡只有100mbps | CSDN博客</a></li>
</ol>
<p align="center">---------------------------  End  ---------------------------</p>

<blockquote>
<p><em>“少无适俗韵，性本爱丘山。”– 《 归园田居·其一》</em></p>
</blockquote>
]]></content>
      <categories>
        <category>ZYNQ</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP-01-TCP/IP协议详解</title>
    <url>/2025/07/19/TCP-01-Protocol/</url>
    <content><![CDATA[<p>本篇博文主要介绍TCP&#x2F;IP协议特性…。</p>
<span id="more"></span>

<h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><p>TCP&#x2F;IP协议族常用的应用层协议包括：</p>
<ul>
<li>HTTP(Hyper Text Transfer Protocol)：超文本传输协议，&lt;客户端-服务端&gt;形式。<span style="color:red"><strong>属于单向同步协议，耗费资源多，不适合实时控制场合。</strong></span></li>
<li>FTP(File Transfer Protocl):文件传输协议，多个设备间共享文件，如文件上传&#x2F;下载、目录操作、权限设置等。</li>
<li>MQTT(Messege Queue Telemerty Transport):消息队列遥测传输，用于推送消息，实时聊天等。</li>
</ul>
<p>按照OSI模型，TCP&#x2F;IP协议被分为7层：物理层、网络层、链路层、传输层、会话层、表示层。<strong>但实际使用时常用5层表示，由下至上分别为：</strong></p>
<ul>
<li><strong>物理层: PHY</strong></li>
<li><strong>链路层: MAC</strong></li>
<li><strong>网络层: IP、ICMP、ARP</strong></li>
<li><strong>传输层: TCP、UDP</strong></li>
<li><strong>应用层: DNS、HTTP、FTP、SMTP</strong></li>
</ul>
<h2 id="TCP协议特性"><a href="#TCP协议特性" class="headerlink" title="TCP协议特性"></a>TCP协议特性</h2><p><strong>TCP是采用数据流形式传输的全双工通信方式，传输过程中，发送方将数据起始编号与长度放在TCP报文中，接收方将所有数据按编号拼接后返回确认，传输双方的数据标号互相独立。</strong></p>
<h3 id="连接、确认与重传"><a href="#连接、确认与重传" class="headerlink" title="连接、确认与重传"></a>连接、确认与重传</h3><p>TCP是面向连接的协议，传输前必须有双方IP地址与端口号进行连接验证。传输中接收方在收到数据后必须返回确认结果，否则超时未确认后发送方认为发送失败，进行数据重传。由于IP层是无连接的。数据和确认都可能丢失，因此发送端在超时还未收到确认时进行重传。</p>
<blockquote>
<p>类似于IIC或者CAN协议穿插在数据流中的应答位，TCP为附在其他报文中的确认机制</p>
</blockquote>
<p>TCP协议连接包括传输层与应用层的连接，每个主机有IP的主机可以提供不同Web、FTP、SMTP等不同线程，通过不同端口来实现线程区分。</p>
<blockquote>
<p>类似RTOS中多个任务有各自独特的TCB</p>
</blockquote>
<ul>
<li>20&#x2F;21：FTP，文件传输协议</li>
<li>23：Telnet，远程登录终端协议</li>
<li>25：SMTP，简单邮件传输协议</li>
<li>69：TFTP，普通文件传输协议</li>
<li>80：HTTP，超文本传输协议</li>
<li>110：POP3，邮局协议版本3</li>
</ul>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>两个主机连接以后，由客户端A建立连接。A首先向B发送空包，通过3个包判断A、B两端的seqno和ackno序号是否一致判断是否连接成功。过程如下：</p>
<ol>
<li><p>A向B发序号，B收到并将其+1作为应答序号，回送给A;	</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&gt;    B知晓A-&gt;B连通</p>
</li>
<li><p>A判断B发送的应答序号，同时将B的序号+1作为应答序号，回送给B；</p>
<p>A的seqno &#x3D; B的ackno &#x3D;&#x3D;&#x3D;&#x3D;&gt;    A知晓A-&gt;B、B-&gt;A连通</p>
</li>
<li><p>B收到A的应答序号；</p>
<p>A的ackno &#x3D; B的seqno &#x3D;&#x3D;&#x3D;&#x3D;&gt;    B知晓B-&gt;A联通</p>
</li>
</ol>
<p>同时引入SYN同步头标志与ACK应答标志，附加自己窗口大小(用于流量控制)，得流程简图如下：</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="build_link.jpg" alt="image can't load." style="zoom:100%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    TCP三次握手<!--标题-->
    </center>
</div>

<p>实际抓包结果如下:</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="image-20250720181903491.png" alt="image can't load." style="zoom:60%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    Wireshrak三次握手抓包<!--标题-->
    </center>
</div>

<ol>
<li>PC-&gt;ZYNQ: SYN &#x3D; 1，发起同步；seqno &#x3D; ..0698</li>
<li>ZYNQ-&gt;PC: SYN &#x3D; 1，发起同步；ACK &#x3D; 1，应答上一报文； seqno &#x3D; 16326，ackno &#x3D; seqno + 1 &#x3D; ..00699；</li>
<li>PC-&gt;ZYNQ: SYN &#x3D; 0，同步结束；ACK &#x3D; 1，应答上一报文； seqno &#x3D; ..00699，ackno &#x3D; seqno + 1 &#x3D; 16327；</li>
</ol>
<p>执行无误后即同步完成，双方建立连接。</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>通常来说，TCP协议断开时是四次挥手，分别断开两个主机间的两条信号通路。大致过程如下：</p>
<ul>
<li><p>C向D发送断开连接报文，D接收并应答</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&gt;    D端知晓C端主动断开发送的请求</p>
</li>
<li><p>C收到D端应答</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&gt;    断开C-&gt;D的报文发送流向</p>
</li>
<li><p>D向C发送断开连接报文，C接收并应答</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&gt;    C端知晓D端主动断开发送的请求</p>
</li>
<li><p>D收到C端应答</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&gt;    断开D-&gt;C的报文流向</p>
</li>
</ul>
<p>类似SYN同步头，引入FIN标志作为中止连接表示。</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="break_link.jpg" alt="image can't load." style="zoom:100%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    TCP四次挥手<!--标题-->
    </center>
</div>

<p><strong>为什么是四次挥手？</strong></p>
<p>下方小节提到，TCP通信双方均会设置一个缓存区，例如本例中PC端为65535、ZYNQ端为2048。有可能ZYNQ在主动断开连接后PC端的数据尚未完全发送，仍然有PC-&gt;ZYNQ方向的报文帧，ZYNQ停止发送但仍保持接收。直到PC端数据发送完成，PC主动断开连接，ZYNQ发送应答。共计4次。</p>
<h4 id="三次挥手-TCP延时应答"><a href="#三次挥手-TCP延时应答" class="headerlink" title="三次挥手?TCP延时应答"></a>三次挥手?TCP延时应答</h4><p>在实际测试过程中PC端断开TCP连接只发现3次挥手？似乎与常说的4次不符合，如下图。</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="image-20250720215038251.png" alt="image can't load." style="zoom:75%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    TCP三次挥手<!--标题-->
    </center>
</div>

<p>查阅TCP协议标准参考文档<a href="https://www.rfc-editor.org/rfc/rfc793">RFC 793</a>第3.5节有关Close Connection的说明，其介绍了3种情况:</p>
<blockquote>
<p>There are essentially three cases:</p>
<ol>
<li>The user initiates by telling the TCP to CLOSE the connection</li>
<li>The remote TCP initiates by sending a FIN control signal</li>
<li>Both users CLOSE simultaneously</li>
</ol>
</blockquote>
<p>无论是单端关闭TCP还是双端同时关闭，均与实测结果不同。但网络上能查找到类似现象的解析，例如<a href="https://zorrozou.github.io/docs/tcp/wavehand/TCP_Wavehand.html">参考资料5</a>中对Linux下的源码进行分析，其中提到了<strong>延时应答机制</strong>。所以LwIP协议栈应当有类似的措施或解决办法，查阅<a href="https://www.cnblogs.com/lizhuming/p/17438743.html">参考资料6</a>中对LwIP的源码分析。</p>
<p>找到<code>tcp.c</code>文件中的<code>tcp_fasttmr()</code>函数：该函数用于每250ms处理被应用层拒绝的数据并且发送延时应答。</p>
<blockquote>
<p>Is called every TCP_FAST_INTERVAL (250 ms) and process data previously “refused” by upper layer (application) and sends delayed ACKs.</p>
</blockquote>
<p>其中有以下代码段：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pcb-&gt;flags &amp; TF_ACK_DELAY) <span class="comment">//到达延迟时间</span></span><br><span class="line">&#123;</span><br><span class="line">    LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_fasttmr: delayed ACK\n&quot;</span>));</span><br><span class="line">    tcp_ack_now(pcb);</span><br><span class="line">    tcp_output(pcb);</span><br><span class="line">    pcb-&gt;flags &amp;= ~(TF_ACK_DELAY | TF_ACK_NOW); <span class="comment">//ACK复位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即在每250ms时刻调用<code>tcp_ack_now(pcb)</code>函数使能立即发送延时ACK，并使用对外输出函数<code>tcp_output()</code>向外输出。函数<code>tcp_output()</code>中定义了延时ACK的处理方式：</p>
<ul>
<li><strong>如果TF_ACK_NOW使能且没有数据待发送，则组一个空的ACK报文立即发送</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* If the TF_ACK_NOW flag is set and no data will be sent (either</span></span><br><span class="line"><span class="comment"> * because the -&gt;unsent queue is empty or because the window does</span></span><br><span class="line"><span class="comment"> * not allow it), construct an empty ACK segment and send it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If data is to be sent, we will just piggyback the ACK (see below).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (pcb-&gt;flags &amp; TF_ACK_NOW &amp;&amp;</span><br><span class="line">   (seg == <span class="literal">NULL</span> ||</span><br><span class="line">    lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len &gt; wnd)) &#123;</span><br><span class="line">   <span class="keyword">return</span> tcp_send_empty_ack(pcb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="防御性设计"><a href="#防御性设计" class="headerlink" title="防御性设计"></a>防御性设计</h3><ul>
<li><p>缓存</p>
<p>由于发送方的数据大小、类型不定，TCP提供缓存机制处理数据。<strong>数据量过小时，TCP将数据存储在缓存中，等到数据量够大时发送，待接收方应答后再删除(便于无应答时重传)</strong>。</p>
<blockquote>
<p>​    类似于CAN短帧以8字节为单位发送</p>
</blockquote>
</li>
<li><p>流量控制</p>
<p>**两种控制方式本质是希望匹配收发双方和中间路由的传输速度。**TCP 提供了流量控制服务（flow-control service）以消除发送方使接收方缓冲区溢出的可能性。</p>
<p>**流量控制是速度匹配，用于匹配收发双方读写速率。**TCP 通过让发送方维护一个称为接收窗口（receive window）的变量来提供流量控制，用于给发送方指示：接收方还能接收多少数据，接收方会将此窗口值放在TCP 报文的首部中的窗口字段传递给发送方，窗口大小是在发送数据时动态调整的。</p>
<blockquote>
<p>如果接收方窗口为0，则发送方发送只有1个字节的报文段，直到缓存清空并在确认报文中包含一个非0的接收窗口值。</p>
</blockquote>
<p><strong>在确定接收方窗口值之后，发送方可动态调整窗口大小对外发送数据。</strong></p>
<blockquote>
<p>滑动窗口思路</p>
</blockquote>
</li>
<li><p>拥塞控制</p>
<p>如果两个千兆主机之间经过百兆路由，即便双方主机均有能力处理500Mbps的数据，但仍收到路由的限制，因此发送方需要实现自适应机制，对发送方成为拥塞机制。<strong>流量控制限制单次通信数据量，拥塞控制协调设备间速率。</strong></p>
</li>
<li><p>差错控制</p>
<p>或者说是校验机制。<strong>TCP协议采用校验和进行校验，主机接收时丢弃重复报文、重组乱序报文、请求重发丢失报文。</strong></p>
</li>
</ul>
<h2 id="TCP报文结构"><a href="#TCP报文结构" class="headerlink" title="TCP报文结构"></a>TCP报文结构</h2><p>TCP是基于字节流方式的传输，各个协议层之间数据传输均会增删各层的数据头：</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="osi.jpg" alt="image can't load." style="zoom:75%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    TCP/IP协议栈报文封装<!--标题-->
    </center>
</div>

<p>在LwIP协议栈中<code>lwip-2.0.2/src/include/lwip/port/tcp.h</code>中，<code>tcp_hdr</code>定义TCP报文帧的组成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_hdr</span> &#123;</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u16_t</span> src);	<span class="comment">/* 源端口 */</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u16_t</span> dest);<span class="comment">/* 目标端口 */</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u32_t</span> seqno);<span class="comment">/* 序号 */</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u32_t</span> ackno);<span class="comment">/* 确认序号 */</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u16_t</span> _hdrlen_rsvd_flags);<span class="comment">/* 首部长度+保留位+标志 */</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u16_t</span> wnd);<span class="comment">/* 窗口大小 */</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u16_t</span> chksum);<span class="comment">/* 校验和 */</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u16_t</span> urgp); <span class="comment">/* 紧急指针 */</span></span><br><span class="line">&#125; PACK_STRUCT_STRUCT;</span><br></pre></td></tr></table></figure>

<p>可以与下方的TCP报文结构对应：</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="tcp_msg.jpg" alt="image can't load." style="zoom:100%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    TCP报文<!--标题-->
    </center>
</div>

<ul>
<li>src、dst：源端、目标端的端口</li>
<li>seqno：发送端起始字节位置码，方便对数据进行管理</li>
<li>ackno：上次已成功收到数据的最后一个字节序号+1，ACK&#x3D;1时有效。<strong>ackno通常会封装在反向数据报文中。</strong></li>
<li>wnd：窗口大小。起始端配置seqno确定发送字节数，实现流量控制。接收方返回wnd&#x3D;0时，发送端停止发送。</li>
<li>chksum：校验值。覆盖TCP所有数据。</li>
<li>urgp：紧急指针。相对于seqno的正偏移量，表示前urgp个数据为紧急数据。</li>
</ul>
<p>标志位说明：</p>
<ul>
<li><p>hdrlen：首部字节数，4bit，单位为字。最大60Byte。</p>
</li>
<li><p>rsvd：保留值</p>
</li>
<li><p>URG：urgp使能</p>
</li>
<li><p>ACK：ackno使能</p>
</li>
<li><p>PSH：push使能。&#x3D;1时尽快将报文端推送给应用层</p>
</li>
<li><p>RST：复位tcp连接</p>
</li>
<li><p>SYN：首次建立新连接时，SYN&#x3D;1，序号字段包含主机随机的初始序号ISN。该主机发送数据的第一个字节序号为ISN+1。</p>
</li>
<li><p>FIN：中止连接</p>
</li>
</ul>
<blockquote>
<p>与CAN类似，源节点+目标节点+应答+数据+校验，但多了窗口值、序号、应答序号、紧急指针。CAN可以8Byte为单帧进行收发。</p>
</blockquote>
<p>PC与ZYNQ建立连接时首次的“握手”的帧为例：</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="image-20250720175218054.png" alt="image can't load." style="zoom:60%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    PC建立连接<!--标题-->
    </center>
</div>

<ul>
<li>src: 61816</li>
<li>dst: 7</li>
<li>seqno: ..1677</li>
<li>ackno: 0</li>
<li>hdrlen: 32</li>
<li>SYN: 1</li>
<li>wnd: 65535</li>
<li>chksum: 0x7407</li>
<li>urgp: 0</li>
</ul>
<h2 id="TCP连接状态"><a href="#TCP连接状态" class="headerlink" title="TCP连接状态"></a>TCP连接状态</h2><p>LwIP协议中，<code>lwip-2.0.2/src/core/tcp.c</code>文件内定义了TCP协议中11种状态。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 限制初始报文发送段最大长度为536B，后续可在SYN连接里动态修改. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_MSS &gt; 536</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INITIAL_MSS 536</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INITIAL_MSS TCP_MSS</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* 11种连接状态 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> tcp_state_str[] = &#123;</span><br><span class="line">  <span class="string">&quot;CLOSED&quot;</span>,			<span class="comment">//关闭状态-无连接</span></span><br><span class="line">  <span class="string">&quot;LISTEN&quot;</span>,			<span class="comment">//监听态</span></span><br><span class="line">  <span class="string">&quot;SYN_SENT&quot;</span>,		<span class="comment">//发起SYN</span></span><br><span class="line">  <span class="string">&quot;SYN_RCVD&quot;</span>,		<span class="comment">//收到SYN</span></span><br><span class="line">  <span class="string">&quot;ESTABLISHED&quot;</span>, 	<span class="comment">//稳定连接</span></span><br><span class="line">  <span class="string">&quot;FIN_WAIT_1&quot;</span>,		<span class="comment">//单向终止</span></span><br><span class="line">  <span class="string">&quot;FIN_WAIT_2&quot;</span>,		<span class="comment">//对方应答终止</span></span><br><span class="line">  <span class="string">&quot;CLOSE_WAIT&quot;</span>,		<span class="comment">//等待终止</span></span><br><span class="line">  <span class="string">&quot;CLOSING&quot;</span>,		<span class="comment">//两端同时关闭</span></span><br><span class="line">  <span class="string">&quot;LAST_ACK&quot;</span>,		<span class="comment">//服务器等待对方关闭</span></span><br><span class="line">  <span class="string">&quot;TIME_WAIT&quot;</span>		<span class="comment">//关闭成功-2MSL等待状态</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于TCP为全双工通信，客户端与服务端的行为基本一致，通过以下流程图介绍客户端与服务器的状态变迁，其中，蓝色实线与红色实线是序号对应，可以组成一次完整的连接过程。红色虚线则表示特殊情况，即客户端与服务器同时发送SYN，使得客户端进入TCP_RSVD状态，如果此时：</p>
<ul>
<li>收到ACK，进入ESTABLISHED</li>
<li>收到RST，恢复LISTEN</li>
<li>内存不足导致客户端进程结束，或服务端ACK应答超时，进入FIN_WAIT_1</li>
</ul>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="tcp_state_change.jpg" alt="image can't load." style="zoom:60%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    TCP状态切换<!--标题-->
    </center>
</div>

<h2 id="TCP数据结构"><a href="#TCP数据结构" class="headerlink" title="TCP数据结构"></a>TCP数据结构</h2><p>类比FreeRTOS任务的任务控制块TCB，LwIP中有同样的协议控制块PCB：</p>
<p>IP块：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IP_PCB \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* ip addresses in network byte order */</span> \</span></span><br><span class="line"><span class="meta">  ip_addr_t local_ip; \</span></span><br><span class="line"><span class="meta">  ip_addr_t remote_ip; \</span></span><br><span class="line"><span class="meta">   <span class="comment">/* Socket options */</span>  \</span></span><br><span class="line"><span class="meta">  u8_t so_options;      \</span></span><br><span class="line"><span class="meta">   <span class="comment">/* Type Of Service */</span> \</span></span><br><span class="line"><span class="meta">  u8_t tos;              \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* Time To Live */</span>     \</span></span><br><span class="line"><span class="meta">  u8_t ttl               \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* link layer address resolution hint */</span> \</span></span><br><span class="line"><span class="meta">  IP_PCB_ADDRHINT</span></span><br></pre></td></tr></table></figure>

<p>本地端口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* members common to struct tcp_pcb and struct tcp_listen_pcb */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_PCB_COMMON(type) \</span></span><br><span class="line"><span class="meta">  type *next; <span class="comment">/* for the linked list */</span> \</span></span><br><span class="line"><span class="meta">  void *callback_arg; \</span></span><br><span class="line"><span class="meta">  enum tcp_state state; <span class="comment">/* TCP state */</span> \</span></span><br><span class="line"><span class="meta">  u8_t prio; \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* ports are in host byte order */</span> \</span></span><br><span class="line"><span class="meta">  u16_t local_port</span></span><br></pre></td></tr></table></figure>

<p>TCP协议控制块定义(部分)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** TCP protocol control block */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> &#123;</span></span><br><span class="line"><span class="comment">/** 通用PCB成员 */</span></span><br><span class="line">  IP_PCB;</span><br><span class="line"><span class="comment">/** 特定PCB成员 */</span></span><br><span class="line">  TCP_PCB_COMMON(<span class="keyword">struct</span> tcp_pcb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 服务端口号 */</span></span><br><span class="line">  <span class="type">u16_t</span> remote_port;</span><br><span class="line">	...</span><br><span class="line">  <span class="comment">/* the rest of the fields are in host byte order</span></span><br><span class="line"><span class="comment">     as we have to do some math with them */</span></span><br><span class="line">  <span class="comment">/* Timers */</span></span><br><span class="line">  <span class="type">u8_t</span> polltmr, pollinterval;</span><br><span class="line">  <span class="type">u8_t</span> last_timer; <span class="comment">/* 控制块最后一次被处理的时间 */</span></span><br><span class="line">  <span class="type">u32_t</span> tmr;</span><br><span class="line">  <span class="comment">/* receiver variables */</span></span><br><span class="line">  <span class="type">u32_t</span> rcv_nxt;   <span class="comment">/* 下一次期望收到的seqno */</span></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> rcv_wnd;   <span class="comment">/* 接收窗口大小 */</span></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> rcv_ann_wnd; <span class="comment">/* 告知对方的接收窗大小 */</span></span><br><span class="line">  <span class="type">u32_t</span> rcv_ann_right_edge; <span class="comment">/* 通知窗口右边缘 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Retransmission timer. */</span></span><br><span class="line">  <span class="type">s16_t</span> rtime;</span><br><span class="line">  <span class="type">u16_t</span> mss;   <span class="comment">/* maximum segment size */</span></span><br><span class="line">	....</span><br><span class="line">  <span class="comment">/* fast retransmit/recovery */</span></span><br><span class="line">  <span class="type">u8_t</span> dupacks;	<span class="comment">/* 快速重传 */</span></span><br><span class="line">  <span class="type">u32_t</span> lastack;<span class="comment">/* 最近一次确认序号 */</span> <span class="comment">/* Highest acknowledged seqno. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* congestion avoidance/control variables */</span></span><br><span class="line">  <span class="comment">/* 避免拥塞/流量控制 */</span></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> cwnd;		<span class="comment">/* 连接当前的窗口大小*/</span></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> ssthresh;	<span class="comment">/* 拥塞避免算法启动的阈值 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* sender variables */</span> <span class="comment">/* 发送方变量 */</span></span><br><span class="line">  <span class="type">u32_t</span> snd_nxt;   <span class="comment">/* next new seqno to be sent */</span></span><br><span class="line">  <span class="type">u32_t</span> snd_wl1, snd_wl2; <span class="comment">/* Sequence and acknowledgement numbers of last</span></span><br><span class="line"><span class="comment">                             window update. */</span></span><br><span class="line">  <span class="type">u32_t</span> snd_lbb;       <span class="comment">/* Sequence number of next byte to be buffered. */</span></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> snd_wnd;   <span class="comment">/* sender window */</span></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> snd_wnd_max; <span class="comment">/* the maximum sender window announced by the remote host */</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="comment">/* 保持空闲的控制变量 */</span></span><br><span class="line">  <span class="comment">/* idle time before KEEPALIVE is sent */</span></span><br><span class="line">  <span class="type">u32_t</span> keep_idle;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_TCP_KEEPALIVE</span></span><br><span class="line">  <span class="type">u32_t</span> keep_intvl;</span><br><span class="line">  <span class="type">u32_t</span> keep_cnt;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_TCP_KEEPALIVE */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Persist timer counter */</span></span><br><span class="line">  <span class="type">u8_t</span> persist_cnt;</span><br><span class="line">  <span class="comment">/* Persist timer back-off */</span></span><br><span class="line">  <span class="type">u8_t</span> persist_backoff;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* KEEPALIVE counter */</span> <span class="comment">/* 保活报文的发送次数 */</span></span><br><span class="line">  <span class="type">u8_t</span> keep_cnt_sent;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_WND_SCALE</span></span><br><span class="line">  <span class="type">u8_t</span> snd_scale;</span><br><span class="line">  <span class="type">u8_t</span> rcv_scale;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在两个ip的设备建立连接前，设备处于LISTEN监听态而非ESTABLISHED连接态，LwIP为节省资源定义了<code>tcp_pcb_listen</code>控制块，其中仅保留通用pcb块，在建立连接后将<code>tcp_pcb_listen</code>接入<code>tcp_pcb</code>即可。<code>tcp_pcb_listen</code>块定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** the TCP protocol control block for listening pcbs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb_listen</span> &#123;</span></span><br><span class="line"><span class="comment">/** Common members of all PCB types */</span></span><br><span class="line">  IP_PCB;</span><br><span class="line"><span class="comment">/** Protocol specific PCB members */</span></span><br><span class="line">  TCP_PCB_COMMON(<span class="keyword">struct</span> tcp_pcb_listen);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_CALLBACK_API</span></span><br><span class="line">  <span class="comment">/* Function to call when a listener has been connected. */</span></span><br><span class="line">  tcp_accept_fn accept;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_CALLBACK_API */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_LISTEN_BACKLOG</span></span><br><span class="line">  <span class="type">u8_t</span> backlog;</span><br><span class="line">  <span class="type">u8_t</span> accepts_pending;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_LISTEN_BACKLOG */</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>LwIP中管理各个PCB的链表如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The TCP PCB lists. */</span></span><br><span class="line"><span class="comment">/** List of all TCP PCBs bound but not yet (connected || listening) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">tcp_bound_pcbs</span>;</span></span><br><span class="line"><span class="comment">/** List of all TCP PCBs in LISTEN state */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">tcp_listen_pcbs_t</span> <span class="title">tcp_listen_pcbs</span>;</span></span><br><span class="line"><span class="comment">/** List of all TCP PCBs that are in a state in which</span></span><br><span class="line"><span class="comment"> * they accept or send data. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">tcp_active_pcbs</span>;</span></span><br><span class="line"><span class="comment">/** List of all TCP PCBs in TIME-WAIT state */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">tcp_tw_pcbs</span>;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>无连接时，<code>tcp_bound_pcbs</code>管理；</li>
<li>处于监听态时，<code>tcp_listen_pcbs</code>管理；</li>
<li>其他状态，<code>tcp_active_pcbs</code>管理；</li>
<li>Time-Wait态，<code>tcp_tw_pcbs</code>管理，主动关闭连接后进入；</li>
</ul>
<blockquote>
<p>同样类比FreeRTOS任务管理，阻塞态、就绪态、运行态、挂起态分别使用不同的链表控制，基本能按顺序一一对应。</p>
</blockquote>
<h2 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h2><p>TCP是基于字节流的传输方式，每字节都有对应的seq号，窗口则是能发送&#x2F;接收的segment字段。包括发送方窗口、接收方窗口，目的是利用收发双方的字节序号进行缓存区数据收发的流量控制与重传，设计上是一个滑动窗口。</p>
<h3 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h3><div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="rcv_wnd.jpg" alt="image can't load." style="zoom:100%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    TCP接收窗<!--标题-->
    </center>
</div>

<p>LwIP中关于接收窗的几个变量：</p>
<ul>
<li>rcv_wnd：received window，接收窗大小</li>
<li>rcv_ann_wnd：received annonce window，通知发送方接收窗大小</li>
<li>rcv_nxt：下次期望收到的seqno</li>
<li>rcv_ann_right_edge：通知发送方的窗口右边界</li>
</ul>
<p>收到对端数据后，接收窗口会减小；应用层读走数据后接收窗口会增加。但是窗口的每次增减并不总是会告知对方。</p>
<h3 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h3><div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="snd_wnd.jpg" alt="image can't load." style="zoom:100%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    TCP发送窗<!--标题-->
    </center>
</div>

<p>LwIP中关于发送窗的几个变量：</p>
<ul>
<li>lastack：接收方应答回来的seq序号</li>
<li>snd_wnd：发送方窗口大小</li>
<li>snd_nxt：待发送的下一字节的seq</li>
<li>snd_lbb：load byte to buffer，装载到缓冲区的下一字节seq</li>
</ul>
<p><strong>发送窗口会存在“飞行数据”的情况，即发送端已发送，但未收到确认&#x2F;应答。<span style="color:red">此时发送窗并不会做出其他操作，直到收到接收方的ackno，随后更新lastack、snd_wnd、snd_nxt、snd_lbb等变量。</span></strong></p>
<h3 id="糊涂窗口？"><a href="#糊涂窗口？" class="headerlink" title="糊涂窗口？"></a>糊涂窗口？</h3><p>TCP的窗口采用动态刷新的滑动窗口机制，变量的更改不仅与己方有关，也需要对端的ackno。那么假设一种可能：</p>
<ol>
<li>rcv端窗口接收后应用层一直未读取，直到rcv_wnd与rcv_ann_wnd缩小至20B</li>
<li>snd端收到rcv应答，snd_wnd设为20B，随后发送20B报文</li>
<li>rcv端应用层收到20B，rcv_wnd变为0，向snd应答</li>
<li>rcv端应用层读取20B，随后重复1-4。</li>
</ol>
<p>**简单说，当rcv端通告小窗，snd端立即填充小窗，应用层继续读取少量数据，则会出现糊涂窗口综合征SWS (Silly WindowSyndrome) 。**这种状况将导致大量TCP报文帧只有少量(20B)有效数据，而大量的小包会降低网络利用率甚至造成网络拥塞，降低网络性能。</p>
<p>产生原因有两个：</p>
<ul>
<li>接收端通告较小的rcv_wnd</li>
<li>发送端收到较小的rcv_wnd时，立即响应发出对应小包。</li>
</ul>
<p>按照RFC1122协议，避免SWS的措施：</p>
<ul>
<li><p>对于接收端要避免通告小窗口</p>
<p>避免以小的增量来推进接收窗的右边沿(rcv_nxt+rcv_wnd)，即使接收的数据包都是小包。只有当接收窗口的增量大于min( Fr * rcv_buff, snd_mss )的时候才通告新的窗口。其中Fr是一个分数因子，协议建议值为1&#x2F;2，snd_mss为对端的发送最大段长。</p>
</li>
<li><p>对于发送端来说在不超出对端接收窗口的前提下至少满足下列三个条件中的一个才能发送数据：</p>
<ol>
<li>一个full-sized的数据包(即大小满足snd_mss)可以被发送；</li>
<li>数据包的大小超过对端曾经通告过的rcv_ann_wnd的一半；</li>
<li>TCP发送端禁用了Nagle算法；</li>
<li>所有发出的数据都已经被对端ACK确认；</li>
</ol>
</li>
</ul>
<h2 id="TCP报文段"><a href="#TCP报文段" class="headerlink" title="TCP报文段"></a>TCP报文段</h2><h3 id="报文段缓冲队列"><a href="#报文段缓冲队列" class="headerlink" title="报文段缓冲队列"></a>报文段缓冲队列</h3><p>tcp_pcb块维护发送&#x2F;接收端的缓冲区队列指针，定义tcp_seg管理所有未发送、已发送未确认、或已收到的无序报文。</p>
<p>tcp_seg的结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This structure represents a TCP segment on the unsent, unacked and ooseq queues */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_seg</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_seg</span> *<span class="title">next</span>;</span>    <span class="comment">/* 链向下一个报文段 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">p</span>;</span>          <span class="comment">/* 报文段pbuf - buffer containing data + TCP header */</span></span><br><span class="line">  <span class="type">u16_t</span> len;               <span class="comment">/* the TCP length of this segment */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_OVERSIZE_DBGCHECK</span></span><br><span class="line">  <span class="type">u16_t</span> oversize_left;     <span class="comment">/* 当前 未发送数据队列（unsent） 中最后一个 pbuf 的 超出MSS（最大报文段大小）的字节数。 */</span> </span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_OVERSIZE_DBGCHECK */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_CHECKSUM_ON_COPY</span></span><br><span class="line">  <span class="type">u16_t</span> chksum;</span><br><span class="line">  <span class="type">u8_t</span>  chksum_swapped;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_CHECKSUM_ON_COPY */</span></span></span><br><span class="line">  <span class="type">u8_t</span>  flags;			<span class="comment">/* 报文段标志属性 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TF_SEG_OPTS_MSS         (u8_t)0x01U <span class="comment">/* Include MSS option. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TF_SEG_OPTS_TS          (u8_t)0x02U <span class="comment">/* Include timestamp option. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TF_SEG_DATA_CHECKSUMMED (u8_t)0x04U <span class="comment">/* ALL data (not the header) is</span></span></span><br><span class="line"><span class="comment"><span class="meta">                                               checksummed into &#x27;chksum&#x27; */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TF_SEG_OPTS_WND_SCALE   (u8_t)0x08U <span class="comment">/* Include WND SCALE option */</span></span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_hdr</span> *<span class="title">tcphdr</span>;</span>  <span class="comment">/* the TCP header */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>tcp_pcb块中需要维护三个指针，在其定义里有：</p>
<ul>
<li>unsent：未发送的报文段缓冲队列</li>
<li>unacked：已发送但未确认的缓冲队列</li>
<li>ooseq：已收到的无序报文队列</li>
</ul>
<p><strong>可以这么理解，最顶层的tcp_active_pcb变量管理CLOSED、LISTEN、Time-Wait以外状态的tcp_pcb块变量。各个tcp_pcb块包含不同的ip和port，管理各自的unsent、unacked、ooseq链表，每个链表又包含多个不同的tcp_seg报文段，同样用链表管理。</strong></p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="tcp_cache_queue.jpg" alt="image can't load." style="zoom:100%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    TCP缓存队列<!--标题-->
    </center>
</div>

<h3 id="报文段发送"><a href="#报文段发送" class="headerlink" title="报文段发送"></a>报文段发送</h3><p>若使用NETCONN API编程，当数据到达传输层后，会调用<code>lwip_netconn_do_writemore()</code>函数对发送数据，处理TCP报文段缓存操作是在<code>tcp_write()</code>函数中。LwIP在将数据写入缓冲区，利用Nagle算法进行发送，最后调用<code>tcp_output()</code> 函数将数据传输至IP层，tcp_out源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">err_t</span></span><br><span class="line"><span class="title function_">tcp_output</span><span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_seg</span> *<span class="title">seg</span>, *<span class="title">useg</span>;</span></span><br><span class="line">  <span class="type">u32_t</span> wnd, snd_nxt;</span><br><span class="line">  <span class="type">err_t</span> err;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netif</span> *<span class="title">netif</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_CWND_DEBUG</span></span><br><span class="line">  <span class="type">s16_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_CWND_DEBUG */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* pcb-&gt;state LISTEN not allowed here */</span></span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;don&#x27;t call tcp_output for listen-pcbs&quot;</span>,</span><br><span class="line">    pcb-&gt;state != LISTEN);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 当前控制块正在处理输入数据，则退出 */</span></span><br><span class="line">  <span class="keyword">if</span> (tcp_input_pcb == pcb) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERR_OK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 获取发送窗snd_wnd与流量/拥塞控制窗cwnd中较小的 */</span></span><br><span class="line">  wnd = LWIP_MIN(pcb-&gt;snd_wnd, pcb-&gt;cwnd);</span><br><span class="line">  <span class="comment">/* 报文段切换为pcb中未发送的unsent链表 */</span></span><br><span class="line">  seg = pcb-&gt;unsent;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* flag中ACK被置位为立即发送，但是 </span></span><br><span class="line"><span class="comment">   * 1)无数据待发</span></span><br><span class="line"><span class="comment">   * 2)本次发送的报文段占据的序列号空间seqno-lastack +len大于接收方窗口大小wnd，接收方没有能力接收</span></span><br><span class="line"><span class="comment">   * 立即发送一个空包ACK</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;flags &amp; TF_ACK_NOW &amp;&amp;</span><br><span class="line">     (seg == <span class="literal">NULL</span> ||</span><br><span class="line">      lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len &gt; wnd)) &#123;</span><br><span class="line">     <span class="keyword">return</span> tcp_send_empty_ack(pcb);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* useg指向最近一次发送但未应答队列unacked报文段，便于超时重传 */</span></span><br><span class="line">  useg = pcb-&gt;unacked;</span><br><span class="line">  <span class="keyword">if</span> (useg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; useg-&gt;next != <span class="literal">NULL</span>; useg = useg-&gt;next);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 底层调用ip4_route函数进行路由查找，检查网口是否可用（UP+链路+IP），匹配子网或路由 */</span></span><br><span class="line">  netif = ip_route(&amp;pcb-&gt;local_ip, &amp;pcb-&gt;remote_ip);</span><br><span class="line">  <span class="keyword">if</span> (netif == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERR_RTE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 若pcb未绑定本地ip，调用ip_netif_get_local_ip从netif中获取ip */</span></span><br><span class="line">  <span class="keyword">if</span> (ip_addr_isany(&amp;pcb-&gt;local_ip)) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">ip_addr_t</span> *local_ip = ip_netif_get_local_ip(netif, &amp;pcb-&gt;remote_ip);</span><br><span class="line">    <span class="keyword">if</span> (local_ip == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ERR_RTE;</span><br><span class="line">    &#125;</span><br><span class="line">    ip_addr_copy(pcb-&gt;local_ip, *local_ip);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_OUTPUT_DEBUG</span></span><br><span class="line">  <span class="keyword">if</span> (seg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, (<span class="string">&quot;tcp_output: nothing to send (%p)\n&quot;</span>,</span><br><span class="line">                                   (<span class="type">void</span>*)pcb-&gt;unsent));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_OUTPUT_DEBUG */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_CWND_DEBUG</span></span><br><span class="line">  <span class="keyword">if</span> (seg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    LWIP_DEBUGF(TCP_CWND_DEBUG, (<span class="string">&quot;tcp_output: snd_wnd %&quot;</span>TCPWNDSIZE_F</span><br><span class="line">                                 <span class="string">&quot;, cwnd %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;, wnd %&quot;</span>U32_F</span><br><span class="line">                                 <span class="string">&quot;, seg == NULL, ack %&quot;</span>U32_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                                 pcb-&gt;snd_wnd, pcb-&gt;cwnd, wnd, pcb-&gt;lastack));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LWIP_DEBUGF(TCP_CWND_DEBUG,</span><br><span class="line">                (<span class="string">&quot;tcp_output: snd_wnd %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;, cwnd %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;, wnd %&quot;</span>U32_F</span><br><span class="line">                 <span class="string">&quot;, effwnd %&quot;</span>U32_F<span class="string">&quot;, seq %&quot;</span>U32_F<span class="string">&quot;, ack %&quot;</span>U32_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                 pcb-&gt;snd_wnd, pcb-&gt;cwnd, wnd,</span><br><span class="line">                 lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len,</span><br><span class="line">                 lwip_ntohl(seg-&gt;tcphdr-&gt;seqno), pcb-&gt;lastack));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_CWND_DEBUG */</span></span></span><br><span class="line">    <span class="comment">/* 处理不适合窗口的报文段 */</span></span><br><span class="line">  <span class="keyword">if</span> (seg != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">      lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len &gt; wnd &amp;&amp;</span><br><span class="line">      wnd &gt; <span class="number">0</span> &amp;&amp; wnd == pcb-&gt;snd_wnd &amp;&amp; pcb-&gt;unacked == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* 启动persist持久化定时器 */</span></span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;persist_backoff == <span class="number">0</span>) &#123;</span><br><span class="line">      pcb-&gt;persist_cnt = <span class="number">0</span>;</span><br><span class="line">      pcb-&gt;persist_backoff = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> output_done; <span class="comment">//跳转至最后</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 数据可用且窗口允许发送，while直到发送完成 */</span></span><br><span class="line">  <span class="keyword">while</span> (seg != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">         lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len &lt;= wnd) </span><br><span class="line">  &#123;</span><br><span class="line">        LWIP_ASSERT(<span class="string">&quot;RST not expected here!&quot;</span>,</span><br><span class="line">                    (TCPH_FLAGS(seg-&gt;tcphdr) &amp; TCP_RST) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* tcp_do_output_nagel(pcb)检查nagle算法是否允许发送,1允许，0禁止。在Nagle禁止时</span></span><br><span class="line"><span class="comment">       * 1)若Nagle内存出错，及时发送ACK</span></span><br><span class="line"><span class="comment">       * 2)FIN已在队列中，终端连接</span></span><br><span class="line"><span class="comment">       * RST不使用tcp_output发送</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">if</span> ((tcp_do_output_nagle(pcb) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">          ((pcb-&gt;flags &amp; (TF_NAGLEMEMERR | TF_FIN)) == <span class="number">0</span>)) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> TCP_CWND_DEBUG</span></span><br><span class="line">        LWIP_DEBUGF(TCP_CWND_DEBUG, (<span class="string">&quot;tcp_output: snd_wnd %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;, cwnd %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;, wnd %&quot;</span>U32_F<span class="string">&quot;, effwnd %&quot;</span>U32_F<span class="string">&quot;, seq %&quot;</span>U32_F<span class="string">&quot;, ack %&quot;</span>U32_F<span class="string">&quot;, i %&quot;</span>S16_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                                pcb-&gt;snd_wnd, pcb-&gt;cwnd, wnd,</span><br><span class="line">                                lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) + seg-&gt;len -</span><br><span class="line">                                pcb-&gt;lastack,</span><br><span class="line">                                lwip_ntohl(seg-&gt;tcphdr-&gt;seqno), pcb-&gt;lastack, i));</span><br><span class="line">        ++i;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_CWND_DEBUG */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 未处于建立连接的SYN态，需要在tcp结构里置位ACK，捎带应答 */</span></span><br><span class="line">        <span class="keyword">if</span> (pcb-&gt;state != SYN_SENT) &#123;</span><br><span class="line">          TCPH_SET_FLAG(seg-&gt;tcphdr, TCP_ACK); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> TCP_OVERSIZE_DBGCHECK</span></span><br><span class="line">        seg-&gt;oversize_left = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_OVERSIZE_DBGCHECK */</span></span></span><br><span class="line">        <span class="comment">/* IP传输层使用ip_output_if函数，发送当前pcb块中的unsent报文段 */</span></span><br><span class="line">        err = tcp_output_segment(seg, pcb, netif);</span><br><span class="line">        <span class="keyword">if</span> (err != ERR_OK) &#123;</span><br><span class="line">          <span class="comment">/* 无论何种原因，报文段未发送 */</span></span><br><span class="line">          pcb-&gt;flags |= TF_NAGLEMEMERR; <span class="comment">/* Nagle 存储错误 */</span></span><br><span class="line">          <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pcb-&gt;unsent = seg-&gt;next; <span class="comment">/* 未发送链表指向下一个seg段 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pcb-&gt;state != SYN_SENT) &#123;</span><br><span class="line">          pcb-&gt;flags &amp;= ~(TF_ACK_DELAY | TF_ACK_NOW);<span class="comment">/* 发送完后设定延时应答状态 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 计算下一个snd_nxt新序列号 seq+length(seq) */</span></span><br><span class="line">        snd_nxt = lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) + TCP_TCPLEN(seg); </span><br><span class="line">        <span class="keyword">if</span> (TCP_SEQ_LT(pcb-&gt;snd_nxt, snd_nxt)) &#123;</span><br><span class="line">          pcb-&gt;snd_nxt = snd_nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 本段有效长度大于0放入unacked链表，等待rcv端ACK */</span></span><br><span class="line">        <span class="keyword">if</span> (TCP_TCPLEN(seg) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          seg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">          <span class="comment">/* unacked list is empty? */</span></span><br><span class="line">          <span class="keyword">if</span> (pcb-&gt;unacked == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pcb-&gt;unacked = seg;</span><br><span class="line">            useg = seg;</span><br><span class="line">          <span class="comment">/* unacked list is not empty? */</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 如果当前报文段seq序号小于未收到应答unacked链表最近的seq序号，需要对链表进行重排(按序) */</span></span><br><span class="line">            <span class="keyword">if</span> (TCP_SEQ_LT(lwip_ntohl(seg-&gt;tcphdr-&gt;seqno), lwip_ntohl(useg-&gt;tcphdr-&gt;seqno))) 			&#123;</span><br><span class="line">              <span class="comment">/* 将报文段按顺序增加在中间位置 */</span></span><br><span class="line">              <span class="keyword">struct</span> tcp_seg **cur_seg = &amp;(pcb-&gt;unacked);</span><br><span class="line">              <span class="comment">/* 找到unacked中第一个seqno ≥ 当前发送报文段seqno的节点 */</span></span><br><span class="line">              <span class="keyword">while</span> (*cur_seg &amp;&amp;</span><br><span class="line">                TCP_SEQ_LT(lwip_ntohl((*cur_seg)-&gt;tcphdr-&gt;seqno), lwip_ntohl(seg-&gt;tcphdr-&gt;seqno))) 	   &#123;</span><br><span class="line">                  cur_seg = &amp;((*cur_seg)-&gt;next );</span><br><span class="line">              &#125;</span><br><span class="line">              seg-&gt;next = (*cur_seg); <span class="comment">/*seg-&gt;next 指向原序列较大seq的节点（*cur_seg）*/</span></span><br><span class="line">              (*cur_seg) = seg; <span class="comment">/* 原序列较大seq的节点（*cur_seg）的前驱节点的 next 指针指向 seg */</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">/* seg插入unacked尾部 */</span></span><br><span class="line">              useg-&gt;next = seg;</span><br><span class="line">              useg = useg-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">/* 报文段len=0的空包 */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          tcp_seg_free(seg);</span><br><span class="line">        &#125;</span><br><span class="line">        seg = pcb-&gt;unsent; <span class="comment">/* 下一个报文段，直到循环结束所有seg发送完毕 */</span></span><br><span class="line">  &#125;</span><br><span class="line">output_done:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_OVERSIZE</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;unsent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* last unsent has been removed, reset unsent_oversize */</span></span><br><span class="line">    pcb-&gt;unsent_oversize = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_OVERSIZE */</span></span></span><br><span class="line"></span><br><span class="line">  pcb-&gt;flags &amp;= ~TF_NAGLEMEMERR;</span><br><span class="line">  <span class="keyword">return</span> ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="报文段接收"><a href="#报文段接收" class="headerlink" title="报文段接收"></a>报文段接收</h3><p>类似应用层向传输层发送接口<code>tcp_output()</code>,还有传输层(IP层)向应用层发送<code>tcp_input()</code>函数，其源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">tcp_input</span><span class="params">(<span class="keyword">struct</span> pbuf *p, <span class="keyword">struct</span> netif *inp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">pcb</span>, *<span class="title">prev</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb_listen</span> *<span class="title">lpcb</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SO_REUSE</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">lpcb_prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb_listen</span> *<span class="title">lpcb_any</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SO_REUSE */</span></span></span><br><span class="line">  <span class="type">u8_t</span> hdrlen_bytes;</span><br><span class="line">  <span class="type">err_t</span> err;</span><br><span class="line"></span><br><span class="line">  LWIP_UNUSED_ARG(inp);</span><br><span class="line"></span><br><span class="line">  PERF_START;</span><br><span class="line"></span><br><span class="line">  TCP_STATS_INC(tcp.recv);</span><br><span class="line">  MIB2_STATS_INC(mib2.tcpinsegs);</span><br><span class="line"></span><br><span class="line">  tcphdr = (<span class="keyword">struct</span> tcp_hdr *)p-&gt;payload;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_INPUT_DEBUG</span></span><br><span class="line">  tcp_debug_print(tcphdr);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 报文段是否有有效数据 */</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;len &lt; TCP_HLEN) &#123;</span><br><span class="line">    <span class="comment">/* 没有就丢弃报文段 */</span></span><br><span class="line">    LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: short packet (%&quot;</span>U16_F<span class="string">&quot; bytes) discarded\n&quot;</span>, p-&gt;tot_len));</span><br><span class="line">    TCP_STATS_INC(tcp.lenerr);</span><br><span class="line">    <span class="keyword">goto</span> dropped;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 不处理传入的广播/多播报文段 */</span></span><br><span class="line">  <span class="keyword">if</span> (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||</span><br><span class="line">      ip_addr_ismulticast(ip_current_dest_addr())) &#123;</span><br><span class="line">    TCP_STATS_INC(tcp.proterr);</span><br><span class="line">    <span class="keyword">goto</span> dropped;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CHECKSUM_CHECK_TCP</span></span><br><span class="line">  IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_TCP) &#123;</span><br><span class="line">    <span class="comment">/* Verify TCP checksum. */</span></span><br><span class="line">    <span class="type">u16_t</span> chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p-&gt;tot_len,</span><br><span class="line">                               ip_current_src_addr(), ip_current_dest_addr());</span><br><span class="line">    <span class="keyword">if</span> (chksum != <span class="number">0</span>) &#123;</span><br><span class="line">        LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: packet discarded due to failing checksum 0x%04&quot;</span>X16_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">          chksum));</span><br><span class="line">      tcp_debug_print(tcphdr);</span><br><span class="line">      TCP_STATS_INC(tcp.chkerr);</span><br><span class="line">      <span class="keyword">goto</span> dropped;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CHECKSUM_CHECK_TCP */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* TCP报文段首部长度 */</span></span><br><span class="line">  hdrlen_bytes = TCPH_HDRLEN(tcphdr) * <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">if</span> ((hdrlen_bytes &lt; TCP_HLEN) || (hdrlen_bytes &gt; p-&gt;tot_len)) &#123;</span><br><span class="line">     <span class="comment">/* uint16 溢出，无法处理*/</span></span><br><span class="line">    LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: invalid header length (%&quot;</span>U16_F<span class="string">&quot;)\n&quot;</span>, (<span class="type">u16_t</span>)hdrlen_bytes));</span><br><span class="line">    TCP_STATS_INC(tcp.lenerr);</span><br><span class="line">    <span class="keyword">goto</span> dropped;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将pbuf指针从tcp header指向data区 */</span></span><br><span class="line">  tcphdr_optlen = hdrlen_bytes - TCP_HLEN;</span><br><span class="line">  tcphdr_opt2 = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;len &gt;= hdrlen_bytes) &#123;</span><br><span class="line">    <span class="comment">/* all options are in the first pbuf */</span></span><br><span class="line">    tcphdr_opt1len = tcphdr_optlen;</span><br><span class="line">    pbuf_header(p, -(<span class="type">s16_t</span>)hdrlen_bytes); <span class="comment">/* cannot fail */</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">u16_t</span> opt2len;</span><br><span class="line">    <span class="comment">/* TCP header fits into first pbuf, options don&#x27;t - data is in the next pbuf */</span></span><br><span class="line">    <span class="comment">/* there must be a next pbuf, due to hdrlen_bytes sanity check above */</span></span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;p-&gt;next != NULL&quot;</span>, p-&gt;next != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* advance over the TCP header (cannot fail) */</span></span><br><span class="line">    pbuf_header(p, -TCP_HLEN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* determine how long the first and second parts of the options are */</span></span><br><span class="line">    tcphdr_opt1len = p-&gt;len;</span><br><span class="line">    opt2len = tcphdr_optlen - tcphdr_opt1len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* options continue in the next pbuf: set p to zero length and hide the</span></span><br><span class="line"><span class="comment">        options in the next pbuf (adjusting p-&gt;tot_len) */</span></span><br><span class="line">    pbuf_header(p, -(<span class="type">s16_t</span>)tcphdr_opt1len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check that the options fit in the second pbuf */</span></span><br><span class="line">    <span class="keyword">if</span> (opt2len &gt; p-&gt;next-&gt;len) &#123;</span><br><span class="line">      <span class="comment">/* drop short packets */</span></span><br><span class="line">      LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: options overflow second pbuf (%&quot;</span>U16_F<span class="string">&quot; bytes)\n&quot;</span>, p-&gt;next-&gt;len));</span><br><span class="line">      TCP_STATS_INC(tcp.lenerr);</span><br><span class="line">      <span class="keyword">goto</span> dropped;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remember the pointer to the second part of the options */</span></span><br><span class="line">    tcphdr_opt2 = (<span class="type">u8_t</span>*)p-&gt;next-&gt;payload;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* advance p-&gt;next to point after the options, and manually</span></span><br><span class="line"><span class="comment">        adjust p-&gt;tot_len to keep it consistent with the changed p-&gt;next */</span></span><br><span class="line">    pbuf_header(p-&gt;next, -(<span class="type">s16_t</span>)opt2len);</span><br><span class="line">    p-&gt;tot_len -= opt2len;</span><br><span class="line"></span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;p-&gt;len == 0&quot;</span>, p-&gt;len == <span class="number">0</span>);</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;p-&gt;tot_len == p-&gt;next-&gt;tot_len&quot;</span>, p-&gt;tot_len == p-&gt;next-&gt;tot_len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 提取tcp头部各字段的值 */</span></span><br><span class="line">  tcphdr-&gt;src = lwip_ntohs(tcphdr-&gt;src);</span><br><span class="line">  tcphdr-&gt;dest = lwip_ntohs(tcphdr-&gt;dest);</span><br><span class="line">  seqno = tcphdr-&gt;seqno = lwip_ntohl(tcphdr-&gt;seqno);</span><br><span class="line">  ackno = tcphdr-&gt;ackno = lwip_ntohl(tcphdr-&gt;ackno);</span><br><span class="line">  tcphdr-&gt;wnd = lwip_ntohs(tcphdr-&gt;wnd);</span><br><span class="line"></span><br><span class="line">  flags = TCPH_FLAGS(tcphdr);</span><br><span class="line">  tcplen = p-&gt;tot_len + ((flags &amp; (TCP_FIN | TCP_SYN)) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Demultiplex an incoming segment. First, we check if it is destined</span></span><br><span class="line"><span class="comment">     for an active connection. */</span></span><br><span class="line">  prev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历活跃的tcp_active_pcbs寻找对应TCP控制块 */</span></span><br><span class="line">  <span class="keyword">for</span> (pcb = tcp_active_pcbs; pcb != <span class="literal">NULL</span>; pcb = pcb-&gt;next) &#123;</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;tcp_input: active pcb-&gt;state != CLOSED&quot;</span>, pcb-&gt;state != CLOSED);</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;tcp_input: active pcb-&gt;state != TIME-WAIT&quot;</span>, pcb-&gt;state != TIME_WAIT);</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;tcp_input: active pcb-&gt;state != LISTEN&quot;</span>, pcb-&gt;state != LISTEN);</span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;remote_port == tcphdr-&gt;src &amp;&amp;</span><br><span class="line">        pcb-&gt;local_port == tcphdr-&gt;dest &amp;&amp;</span><br><span class="line">        ip_addr_cmp(&amp;pcb-&gt;remote_ip, ip_current_src_addr()) &amp;&amp;</span><br><span class="line">        ip_addr_cmp(&amp;pcb-&gt;local_ip, ip_current_dest_addr())) &#123;</span><br><span class="line">      <span class="comment">/* Move this PCB to the front of the list so that subsequent</span></span><br><span class="line"><span class="comment">         lookups will be faster (we exploit locality in TCP segment</span></span><br><span class="line"><span class="comment">         arrivals). */</span></span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;tcp_input: pcb-&gt;next != pcb (before cache)&quot;</span>, pcb-&gt;next != pcb);</span><br><span class="line">      <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        prev-&gt;next = pcb-&gt;next;</span><br><span class="line">        pcb-&gt;next = tcp_active_pcbs;</span><br><span class="line">        tcp_active_pcbs = pcb;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TCP_STATS_INC(tcp.cachehit);</span><br><span class="line">      &#125;</span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;tcp_input: pcb-&gt;next != pcb (after cache)&quot;</span>, pcb-&gt;next != pcb);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    prev = pcb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pcb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* 如果没找到active连接，则检查TW(Time-Wait)状态连接 */</span></span><br><span class="line">    <span class="keyword">for</span> (pcb = tcp_tw_pcbs; pcb != <span class="literal">NULL</span>; pcb = pcb-&gt;next) &#123;</span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;tcp_input: TIME-WAIT pcb-&gt;state == TIME-WAIT&quot;</span>, pcb-&gt;state == TIME_WAIT);</span><br><span class="line">      <span class="keyword">if</span> (pcb-&gt;remote_port == tcphdr-&gt;src &amp;&amp;</span><br><span class="line">          pcb-&gt;local_port == tcphdr-&gt;dest &amp;&amp;</span><br><span class="line">          ip_addr_cmp(&amp;pcb-&gt;remote_ip, ip_current_src_addr()) &amp;&amp;</span><br><span class="line">          ip_addr_cmp(&amp;pcb-&gt;local_ip, ip_current_dest_addr())) &#123;</span><br><span class="line">        <span class="comment">/* We don&#x27;t really care enough to move this PCB to the front</span></span><br><span class="line"><span class="comment">           of the list since we are not very likely to receive that</span></span><br><span class="line"><span class="comment">           many segments for connections in TIME-WAIT. */</span></span><br><span class="line">        LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: packed for TIME_WAITing connection.\n&quot;</span>));</span><br><span class="line">        tcp_timewait_input(pcb); <span class="comment">/* 有匹配的ip和端口 */</span></span><br><span class="line">        pbuf_free(p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若仍未找到，则在LISTENING态的网口中查找连接. */</span></span><br><span class="line">    prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != <span class="literal">NULL</span>; lpcb = lpcb-&gt;next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (lpcb-&gt;local_port == tcphdr-&gt;dest) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IP_IS_ANY_TYPE_VAL(lpcb-&gt;local_ip)) &#123;</span><br><span class="line">          <span class="comment">/* found an ANY TYPE (IPv4/IPv6) match */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SO_REUSE</span></span><br><span class="line">          lpcb_any = lpcb;</span><br><span class="line">          lpcb_prev = prev;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* SO_REUSE */</span></span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SO_REUSE */</span></span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IP_ADDR_PCB_VERSION_MATCH_EXACT(lpcb, ip_current_dest_addr())) &#123;</span><br><span class="line">          <span class="keyword">if</span> (ip_addr_cmp(&amp;lpcb-&gt;local_ip, ip_current_dest_addr())) &#123;</span><br><span class="line">            <span class="comment">/* found an exact match */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ip_addr_isany(&amp;lpcb-&gt;local_ip)) &#123;</span><br><span class="line">            <span class="comment">/* found an ANY-match */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SO_REUSE</span></span><br><span class="line">            lpcb_any = lpcb;</span><br><span class="line">            lpcb_prev = prev;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* SO_REUSE */</span></span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SO_REUSE */</span></span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      prev = (<span class="keyword">struct</span> tcp_pcb *)lpcb;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SO_REUSE</span></span><br><span class="line">    <span class="comment">/* first try specific local IP */</span></span><br><span class="line">    <span class="keyword">if</span> (lpcb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">/* only pass to ANY if no specific local IP has been found */</span></span><br><span class="line">      lpcb = lpcb_any;</span><br><span class="line">      prev = lpcb_prev;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SO_REUSE */</span></span></span><br><span class="line">    <span class="keyword">if</span> (lpcb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">/* Move this PCB to the front of the list so that subsequent</span></span><br><span class="line"><span class="comment">         lookups will be faster (we exploit locality in TCP segment</span></span><br><span class="line"><span class="comment">         arrivals). */</span></span><br><span class="line">      <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ((<span class="keyword">struct</span> tcp_pcb_listen *)prev)-&gt;next = lpcb-&gt;next;</span><br><span class="line">              <span class="comment">/* our successor is the remainder of the listening list */</span></span><br><span class="line">        lpcb-&gt;next = tcp_listen_pcbs.listen_pcbs;</span><br><span class="line">              <span class="comment">/* put this listening pcb at the head of the listening list */</span></span><br><span class="line">        tcp_listen_pcbs.listen_pcbs = lpcb;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TCP_STATS_INC(tcp.cachehit);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: packed for LISTENing connection.\n&quot;</span>));</span><br><span class="line">      tcp_listen_input(lpcb);</span><br><span class="line">      pbuf_free(p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_INPUT_DEBUG</span></span><br><span class="line">  LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;+-+-+-+-+-+-+-+-+-+-+-+-+-+- tcp_input: flags &quot;</span>));</span><br><span class="line">  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));</span><br><span class="line">  LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n&quot;</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_INPUT_DEBUG */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pcb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* The incoming segment belongs to a connection. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_INPUT_DEBUG</span></span><br><span class="line">    tcp_debug_print_state(pcb-&gt;state);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_INPUT_DEBUG */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up a tcp_seg structure. */</span></span><br><span class="line">    inseg.next = <span class="literal">NULL</span>;</span><br><span class="line">    inseg.len = p-&gt;tot_len;</span><br><span class="line">    inseg.p = p;</span><br><span class="line">    inseg.tcphdr = tcphdr;</span><br><span class="line"></span><br><span class="line">    recv_data = <span class="literal">NULL</span>;</span><br><span class="line">    recv_flags = <span class="number">0</span>;</span><br><span class="line">    recv_acked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; TCP_PSH) &#123;</span><br><span class="line">      p-&gt;flags |= PBUF_FLAG_PUSH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If there is data which was previously &quot;refused&quot; by upper layer */</span></span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;refused_data != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((tcp_process_refused_data(pcb) == ERR_ABRT) ||</span><br><span class="line">        ((pcb-&gt;refused_data != <span class="literal">NULL</span>) &amp;&amp; (tcplen &gt; <span class="number">0</span>))) &#123;</span><br><span class="line">        <span class="comment">/* pcb has been aborted or refused data is still refused and the new</span></span><br><span class="line"><span class="comment">           segment contains data */</span></span><br><span class="line">        <span class="keyword">if</span> (pcb-&gt;rcv_ann_wnd == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">/* this is a zero-window probe, we respond to it with current RCV.NXT</span></span><br><span class="line"><span class="comment">          and drop the data segment */</span></span><br><span class="line">          tcp_send_empty_ack(pcb);</span><br><span class="line">        &#125;</span><br><span class="line">        TCP_STATS_INC(tcp.drop);</span><br><span class="line">        MIB2_STATS_INC(mib2.tcpinerrs);</span><br><span class="line">        <span class="keyword">goto</span> aborted;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tcp_input_pcb = pcb;</span><br><span class="line">    err = tcp_process(pcb);</span><br><span class="line">    <span class="comment">/* A return value of ERR_ABRT means that tcp_abort() was called</span></span><br><span class="line"><span class="comment">       and that the pcb has been freed. If so, we don&#x27;t do anything. */</span></span><br><span class="line">    <span class="keyword">if</span> (err != ERR_ABRT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (recv_flags &amp; TF_RESET) &#123;</span><br><span class="line">        <span class="comment">/* TF_RESET means that the connection was reset by the other</span></span><br><span class="line"><span class="comment">           end. We then call the error callback to inform the</span></span><br><span class="line"><span class="comment">           application that the connection is dead before we</span></span><br><span class="line"><span class="comment">           deallocate the PCB. */</span></span><br><span class="line">        TCP_EVENT_ERR(pcb-&gt;state, pcb-&gt;errf, pcb-&gt;callback_arg, ERR_RST);</span><br><span class="line">        tcp_pcb_remove(&amp;tcp_active_pcbs, pcb);</span><br><span class="line">        memp_free(MEMP_TCP_PCB, pcb);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = ERR_OK;</span><br><span class="line">        <span class="comment">/* If the application has registered a &quot;sent&quot; function to be</span></span><br><span class="line"><span class="comment">           called when new send buffer space is available, we call it</span></span><br><span class="line"><span class="comment">           now. */</span></span><br><span class="line">        <span class="keyword">if</span> (recv_acked &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="type">u16_t</span> acked16;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_WND_SCALE</span></span><br><span class="line">          <span class="comment">/* recv_acked is u32_t but the sent callback only takes a u16_t,</span></span><br><span class="line"><span class="comment">             so we might have to call it multiple times. */</span></span><br><span class="line">          <span class="type">u32_t</span> acked = recv_acked;</span><br><span class="line">          <span class="keyword">while</span> (acked &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            acked16 = (<span class="type">u16_t</span>)LWIP_MIN(acked, <span class="number">0xffffu</span>);</span><br><span class="line">            acked -= acked16;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">          &#123;</span><br><span class="line">            acked16 = recv_acked;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            TCP_EVENT_SENT(pcb, (<span class="type">u16_t</span>)acked16, err);</span><br><span class="line">            <span class="keyword">if</span> (err == ERR_ABRT) &#123;</span><br><span class="line">              <span class="keyword">goto</span> aborted;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          recv_acked = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (recv_flags &amp; TF_CLOSED) &#123;</span><br><span class="line">          <span class="comment">/* The connection has been closed and we will deallocate the</span></span><br><span class="line"><span class="comment">             PCB. */</span></span><br><span class="line">          <span class="keyword">if</span> (!(pcb-&gt;flags &amp; TF_RXCLOSED)) &#123;</span><br><span class="line">            <span class="comment">/* Connection closed although the application has only shut down the</span></span><br><span class="line"><span class="comment">               tx side: call the PCB&#x27;s err callback and indicate the closure to</span></span><br><span class="line"><span class="comment">               ensure the application doesn&#x27;t continue using the PCB. */</span></span><br><span class="line">            TCP_EVENT_ERR(pcb-&gt;state, pcb-&gt;errf, pcb-&gt;callback_arg, ERR_CLSD);</span><br><span class="line">          &#125;</span><br><span class="line">          tcp_pcb_remove(&amp;tcp_active_pcbs, pcb);</span><br><span class="line">          memp_free(MEMP_TCP_PCB, pcb);</span><br><span class="line">          <span class="keyword">goto</span> aborted;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE</span></span><br><span class="line">        <span class="keyword">while</span> (recv_data != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">rest</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">          pbuf_split_64k(recv_data, &amp;rest);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE */</span></span></span><br><span class="line">        <span class="keyword">if</span> (recv_data != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE */</span></span></span><br><span class="line"></span><br><span class="line">          LWIP_ASSERT(<span class="string">&quot;pcb-&gt;refused_data == NULL&quot;</span>, pcb-&gt;refused_data == <span class="literal">NULL</span>);</span><br><span class="line">          <span class="keyword">if</span> (pcb-&gt;flags &amp; TF_RXCLOSED) &#123;</span><br><span class="line">            <span class="comment">/* received data although already closed -&gt; abort (send RST) to</span></span><br><span class="line"><span class="comment">               notify the remote host that not all data has been processed */</span></span><br><span class="line">            pbuf_free(recv_data);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE</span></span><br><span class="line">            <span class="keyword">if</span> (rest != <span class="literal">NULL</span>) &#123;</span><br><span class="line">              pbuf_free(rest);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE */</span></span></span><br><span class="line">            tcp_abort(pcb);</span><br><span class="line">            <span class="keyword">goto</span> aborted;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Notify application that data has been received. */</span></span><br><span class="line">          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);</span><br><span class="line">          <span class="keyword">if</span> (err == ERR_ABRT) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE</span></span><br><span class="line">            <span class="keyword">if</span> (rest != <span class="literal">NULL</span>) &#123;</span><br><span class="line">              pbuf_free(rest);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE */</span></span></span><br><span class="line">            <span class="keyword">goto</span> aborted;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* If the upper layer can&#x27;t receive this data, store it */</span></span><br><span class="line">          <span class="keyword">if</span> (err != ERR_OK) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE</span></span><br><span class="line">            <span class="keyword">if</span> (rest != <span class="literal">NULL</span>) &#123;</span><br><span class="line">              pbuf_cat(recv_data, rest);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE */</span></span></span><br><span class="line">            pcb-&gt;refused_data = recv_data;</span><br><span class="line">            LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: keep incoming packet, because pcb is \&quot;full\&quot;\n&quot;</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Upper layer received the data, go on with the rest if &gt; 64K */</span></span><br><span class="line">            recv_data = rest;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE */</span></span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If a FIN segment was received, we call the callback</span></span><br><span class="line"><span class="comment">           function with a NULL buffer to indicate EOF. */</span></span><br><span class="line">        <span class="keyword">if</span> (recv_flags &amp; TF_GOT_FIN) &#123;</span><br><span class="line">          <span class="keyword">if</span> (pcb-&gt;refused_data != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Delay this if we have refused data. */</span></span><br><span class="line">            pcb-&gt;refused_data-&gt;flags |= PBUF_FLAG_TCP_FIN;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* correct rcv_wnd as the application won&#x27;t call tcp_recved()</span></span><br><span class="line"><span class="comment">               for the FIN&#x27;s seqno */</span></span><br><span class="line">            <span class="keyword">if</span> (pcb-&gt;rcv_wnd != TCP_WND_MAX(pcb)) &#123;</span><br><span class="line">              pcb-&gt;rcv_wnd++;</span><br><span class="line">            &#125;</span><br><span class="line">            TCP_EVENT_CLOSED(pcb, err);</span><br><span class="line">            <span class="keyword">if</span> (err == ERR_ABRT) &#123;</span><br><span class="line">              <span class="keyword">goto</span> aborted;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tcp_input_pcb = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">/* Try to send something out. */</span></span><br><span class="line">        tcp_output(pcb);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_INPUT_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_DEBUG</span></span><br><span class="line">        tcp_debug_print_state(pcb-&gt;state);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_DEBUG */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_INPUT_DEBUG */</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).</span></span><br><span class="line"><span class="comment">       Below this line, &#x27;pcb&#x27; may not be dereferenced! */</span></span><br><span class="line">aborted:</span><br><span class="line">    tcp_input_pcb = <span class="literal">NULL</span>;</span><br><span class="line">    recv_data = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* give up our reference to inseg.p */</span></span><br><span class="line">    <span class="keyword">if</span> (inseg.p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      pbuf_free(inseg.p);</span><br><span class="line">      inseg.p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If no matching PCB was found, send a TCP RST (reset) to the</span></span><br><span class="line"><span class="comment">       sender. */</span></span><br><span class="line">    LWIP_DEBUGF(TCP_RST_DEBUG, (<span class="string">&quot;tcp_input: no PCB match found, resetting.\n&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (!(TCPH_FLAGS(tcphdr) &amp; TCP_RST)) &#123;</span><br><span class="line">      TCP_STATS_INC(tcp.proterr);</span><br><span class="line">      TCP_STATS_INC(tcp.drop);</span><br><span class="line">      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),</span><br><span class="line">        ip_current_src_addr(), tcphdr-&gt;dest, tcphdr-&gt;src);</span><br><span class="line">    &#125;</span><br><span class="line">    pbuf_free(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;tcp_input: tcp_pcbs_sane()&quot;</span>, tcp_pcbs_sane());</span><br><span class="line">  PERF_STOP(<span class="string">&quot;tcp_input&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">dropped:</span><br><span class="line">  TCP_STATS_INC(tcp.drop);</span><br><span class="line">  MIB2_STATS_INC(mib2.tcpinerrs);</span><br><span class="line">  pbuf_free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>正常接收处理的数据，如果收到的报文段是复位报文或终止连接应答报文，则释放pbuf，终止连接；</li>
<li>TCP 协议确认报文段是新数据，调用带参宏TCP_EVENT_SENT（sent 的回调函数）处理；</li>
<li>如果报文段中包含有效的数据，就调用TCP_EVENT_RECV 去处理；</li>
<li>如果是收到FIN 报文，则调用TCP_EVENT_CLOSED 去处理；</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://blog.csdn.net/2301_76144863/article/details/139028540?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-139028540-blog-120524798.235%5Ev43%5Epc_blog_bottom_relevance_base5&spm=1001.2101.3001.4242.2&utm_relevant_index=3">TCP协议_tcp全双工-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/zjcjava/article/details/103133607?ops_request_misc=&request_id=&biz_id=&utm_medium=distribute.pc_search_result.none-task-blog-2~all~es_rank~default-2-103133607.pc_search_all_es&utm_term=%E4%B8%BA%E4%BB%80%E4%B9%88tcp%E6%8C%A5%E6%89%8B%E5%8F%AA%E6%9C%89%E4%B8%89%E6%AC%A1&spm=1018.2226.3001.4187">tcp&#x2F;ip 只有四次挥手？还有三次挥手_四次挥手中会出现只有3此的情况嘛-CSDN博客</a></li>
<li>[linux - What is the reason and how to avoid the <a href="https://stackoverflow.com/questions/15182106/what-is-the-reason-and-how-to-avoid-the-fin-ack-rst-and-rst-ack">FIN, ACK] , [RST] and [RST, ACK] - Stack Overflow</a></li>
<li><a href="https://blog.csdn.net/weixin_40803011/article/details/121794141">Wireshark抓包分析TCP，发现居然只有三次挥手_只抓到三次挥手-CSDN博客</a></li>
<li><a href="https://zorrozou.github.io/docs/tcp/wavehand/TCP_Wavehand.html">Linux的TCP实现之：四次挥手 | Zorro’s Linux Book</a></li>
<li><a href="https://www.cnblogs.com/lizhuming/p/17438743.html">【lwip】14-TCP协议之可靠传输的实现（TCP干货） - 李柱明 - 博客园</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc793#section-3.5">RFC 793: Transmission Control Protocol-S3.5</a></li>
<li><a href="https://www.cnblogs.com/lizhuming/p/16883586.html">【lwip】12-一文解决TCP原理 - 李柱明 - 博客园</a></li>
<li><a href="https://www.cnblogs.com/lshs/p/6038658.html">TCP系列33—窗口管理&amp;流控—7、Silly Window Syndrome(SWS) - lshs - 博客园</a></li>
<li><a href="https://www.cnblogs.com/lizhuming/p/17438682.html">【lwip】13-TCP协议分析之源码篇 - 李柱明 - 博客园</a></li>
</ol>
]]></content>
      <categories>
        <category>TCP/IP</category>
        <category>Protocol</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-02-字符串寻找最大公因子</title>
    <url>/2025/07/19/LeetCode-02-GCD_Of_String/</url>
    <content><![CDATA[<p>LeetCode算法题：字符串找最大公因子。</p>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>LeetCode：<a href="https://leetcode.cn/studyplan/leetcode-75/">LeetCode 75 - 学习计划</a>-02-字符串最大公因子</p>
<p>对于字符串 <code>s</code> 和 <code>t</code>，只有在 <code>s = t + t + t + ... + t + t</code>（<code>t</code> 自身连接 1 次或多次）时，我们才认定 “<code>t</code> 能除尽 <code>s</code>”。</p>
<p>给定两个字符串 <code>str1</code> 和 <code>str2</code> 。返回 <em>最长字符串 <code>x</code>，要求满足 <code>x</code> 能除尽 <code>str1</code> 且 <code>x</code> 能除尽 <code>str2</code></em> 。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果存在最大公因子，最长的相同元素一定是str1与str2中短的那个。</p>
<p>方案A： <strong>若存在字符串最大公因子，则str1或str2必定只有x元素。即str1与str2之间辗转对比一定能找到最终的x，否则不存在最大公因子。</strong></p>
<p>方案B：字符串的公因子是按照长度定义，只需要找到字符串str1与str2长度的最大公因子，以次长度为基准，比对str1与str2的元素。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方案A"><a href="#方案A" class="headerlink" title="方案A"></a>方案A</h3><p>辗转相除，以较短的字符串为基准，不断向后移动并缩减比对字符串的长度，也是希望找到<strong>长度的最大公因子</strong>。</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="image-20250719114305253.png" alt="image can't load." style="zoom:55%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    长度上辗转相除	<!--标题-->
    </center>
</div>

 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">gcdOfStrings</span><span class="params">(<span class="type">char</span>* str1, <span class="type">char</span>* str2)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="built_in">strlen</span>(str1);</span><br><span class="line">    <span class="type">int</span> n2 = <span class="built_in">strlen</span>(str2);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n1==n2 &amp;&amp; <span class="built_in">strncmp</span>(str1,str2,n1)==<span class="number">0</span> ) <span class="comment">//字符串长度相等</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> str1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n1&gt;n2 &amp;&amp; <span class="built_in">strncmp</span>(str1,str2,n2)==<span class="number">0</span>) <span class="comment">//str1长，向后移动</span></span><br><span class="line">        &#123;</span><br><span class="line">            str1 += n2;</span><br><span class="line">            n1 -= n2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n1&lt;n2 &amp;&amp; <span class="built_in">strncmp</span>(str1,str2,n1)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            str2 += n1;</span><br><span class="line">            n2 -= n1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方案B"><a href="#方案B" class="headerlink" title="方案B"></a>方案B</h3><p>如果考虑不到方案A的辗转相除，那么可以尝试找到长度公因子，并使用长度对应的元素分别与str1和str2后续的字符做比较，理论上应当完全一致。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//int gcd = iGcd(6,4);</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">iGcd</span><span class="params">(<span class="type">int</span> len1,<span class="type">int</span> len2)</span>;</span><br><span class="line"><span class="comment">//int result = (&quot;ABABAB&quot;,&quot;AB&quot;,2);</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">iCheck</span><span class="params">(<span class="type">char</span> *str1, <span class="type">char</span> *str2, <span class="type">int</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">gcdOfStrings</span><span class="params">(<span class="type">char</span>* str1, <span class="type">char</span>* str2)</span> &#123;</span><br><span class="line">     <span class="comment">//str1与str2前n个元素不同</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str1[i] &amp;&amp; str2[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str1[i]!=str2[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n1 = <span class="built_in">strlen</span>(str1);</span><br><span class="line">    <span class="type">int</span> n2 = <span class="built_in">strlen</span>(str2);</span><br><span class="line">    <span class="type">int</span> result = iGcd(n1,n2);<span class="comment">//找到长度最大公因子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len =result;len&gt;<span class="number">0</span>;len--) <span class="comment">//例如偶数可能是4、2、1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n1%len || n2%len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(iCheck(str1,str2,len)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            str1[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> str1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找长度的最大公因子</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">iGcd</span><span class="params">(<span class="type">int</span> len1,<span class="type">int</span> len2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(len1!=len2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(len1 &gt; len2)</span><br><span class="line">        &#123;</span><br><span class="line">            len1 -= len2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            len2 -= len1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">iCheck</span><span class="params">(<span class="type">char</span> *str1, <span class="type">char</span> *str2, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//str1前len长度字符与后续对比</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=len; str1[j] ;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str1[i]!=str1[j]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i = (i+<span class="number">1</span>)%len;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//str1前len长度字符与str2后续字符对比	</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=len; str2[j] ;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str1[i]!=str2[j]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i = (i+<span class="number">1</span>)%len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p align="center">---------------------------  End  ---------------------------</p>

<blockquote>
<p><em>“天长地久有时尽，此恨绵绵无绝期。”– 《长恨歌》</em></p>
</blockquote>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-01-String_Composition</title>
    <url>/2025/07/19/LeetCode-01-String_Composition/</url>
    <content><![CDATA[<p>LeetCode算法题：字符串交叉拼接。</p>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>LeetCode：<a href="https://leetcode.cn/studyplan/leetcode-75/">LeetCode 75 - 学习计划 </a>-1-交替合并字符串</p>
<p>题目简述：给你两个字符串 <code>word1</code> 和 <code>word2</code> 。请你从 <code>word1</code> 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。</p>
<p>返回 <strong>合并后的字符串</strong> 。</p>
<ul>
<li><code>1 &lt;= word1.length, word2.length &lt;= 100</code></li>
<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>从题干中可得到以下关键信息：</p>
<ul>
<li>两字符串不等长</li>
<li>交替添加</li>
</ul>
<p>因此推论出两个要点：</p>
<ul>
<li>strlen计算输入字符串长度</li>
<li>读取时可共用同一索引值&#x2F;双指针</li>
</ul>
<p>因此可根据输入字符串长度动态分配内存，随后循环读取两数组的元素。</p>
<ul>
<li>malloc分配内存长度应为len1+len2+1，末尾存放’\0’;</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方案A"><a href="#方案A" class="headerlink" title="方案A"></a>方案A</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">mergeAlternately</span><span class="params">(<span class="type">char</span>* word1, <span class="type">char</span>* word2)</span> &#123;</span><br><span class="line">    assert(word1);</span><br><span class="line">    assert(word2);</span><br><span class="line">    <span class="type">int</span> word1_len = <span class="built_in">strlen</span>(word1);</span><br><span class="line">    <span class="type">int</span> word2_len = <span class="built_in">strlen</span>(word2);</span><br><span class="line">    <span class="type">int</span> word_rd_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> string_wr_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* string_out = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (word1_len + word2_len + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span> ((word_rd_idx &lt; word1_len) || (word_rd_idx &lt; word2_len))</span><br><span class="line">    &#123;</span><br><span class="line">        word_rd_idx &lt; word1_len ? (string_out[string_wr_idx++] = word1[word_rd_idx]) : <span class="number">0</span>;</span><br><span class="line">        word_rd_idx &lt; word2_len ? (string_out[string_wr_idx++] = word2[word_rd_idx]) : <span class="number">0</span>;</span><br><span class="line">        word_rd_idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    string_out[string_wr_idx] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> string_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方案A中无论哪个字符串更长，while中均会判断两次。如果AB长度差异过大影响效率。</p>
<h3 id="方案B"><a href="#方案B" class="headerlink" title="方案B"></a>方案B</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">mergeAlternately</span><span class="params">(<span class="type">char</span>* word1, <span class="type">char</span>* word2)</span> &#123;</span><br><span class="line">    assert(word1);</span><br><span class="line">    assert(word2);</span><br><span class="line">    <span class="type">int</span> word1_len = <span class="built_in">strlen</span>(word1);</span><br><span class="line">    <span class="type">int</span> word2_len = <span class="built_in">strlen</span>(word2);</span><br><span class="line">    <span class="type">int</span> word_rd_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> string_wr_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* string_out = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (word1_len + word2_len + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span> ((word_rd_idx &lt; word1_len) &amp;&amp; (word_rd_idx &lt; word2_len))</span><br><span class="line">    &#123;</span><br><span class="line">        word_rd_idx &lt; word1_len ? (string_out[string_wr_idx++] = word1[word_rd_idx]) : <span class="number">0</span>;</span><br><span class="line">        word_rd_idx &lt; word2_len ? (string_out[string_wr_idx++] = word2[word_rd_idx]) : <span class="number">0</span>;</span><br><span class="line">        word_rd_idx++;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(word1_len&gt;=word2_len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (word_rd_idx &lt; word1_len)</span><br><span class="line">        &#123;</span><br><span class="line"> 			string_out[string_wr_idx++] = word1[word_rd_idx];</span><br><span class="line">            word_rd_idx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (word_rd_idx &lt; word2_len)</span><br><span class="line">        &#123;</span><br><span class="line"> 			string_out[string_wr_idx++] = word2[word_rd_idx];</span><br><span class="line">            word_rd_idx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string_out[string_wr_idx] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> string_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方案C"><a href="#方案C" class="headerlink" title="方案C"></a>方案C</h3><p>采用双指针，进一步减少定义变量的个数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">mergeAlternately</span><span class="params">(<span class="type">char</span>* word1, <span class="type">char</span>* word2)</span> &#123;</span><br><span class="line">    assert(word1);</span><br><span class="line">    assert(word2);</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(word1) + <span class="built_in">strlen</span>(word2) + <span class="number">1</span>));<span class="comment">//起始指针</span></span><br><span class="line">    <span class="type">char</span> *string_out = p;<span class="comment">//写入字符的移动指针</span></span><br><span class="line">    <span class="keyword">while</span>(*word1 &amp;&amp; *word2)</span><br><span class="line">    &#123;</span><br><span class="line">        *string_out++=*word1++;</span><br><span class="line">        *string_out++=*word2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*word1)</span><br><span class="line">    &#123;</span><br><span class="line">        *string_out++=*word1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*word2)</span><br><span class="line">    &#123;</span><br><span class="line">        *string_out++=*word2++;</span><br><span class="line">    &#125;</span><br><span class="line">    *string_out = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>方案ABC的复杂度一致，<strong>时间复杂度为O(n+m)</strong>:源于strlen(word1)与strlen(word2)。<strong>空间复杂度为O(n+m)</strong>:源于malloc分配内存</p>
<p align="center">---------------------------  End  ---------------------------</p>

<blockquote>
<p><em>“试玉要烧三日满，辨材须待七年期。”– 《放言五首·其三》</em></p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Altium-02-异常与解决办法</title>
    <url>/2025/07/18/Altium-02-Error_And_Solution/</url>
    <content><![CDATA[<p>本博客记录Altium Designer设计PCB时遇到的各种问题与解决办法，按照原理图与PCB进行归类…</p>
<span id="more"></span>

<h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><p>None.</p>
<h2 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h2><h3 id="器件位置类"><a href="#器件位置类" class="headerlink" title="器件位置类"></a>器件位置类</h3><ol>
<li><p>器件无法拖动到原点左侧和下方</p>
<p>如下图。绝对原点限制了器件摆放位置。</p>
<div>            <!--块级封装-->
    <center>    <!--将图片和文字居中-->
    <img src="image-20250718094118825.png" alt="image can't load." style="zoom:40%"><!-- alt内为提示词-->
    <br>        <!--换行-->
    辅助中心    <!--标题-->
    </center>
</div>


<p>Re:使用<code>EJA</code>跳转至绝对原点，若板框距离原点有差距，选中所有器件移动至合适位置即可。</p>
</li>
</ol>
<p align="center">---------------------------  End  ---------------------------</p>

<blockquote>
<p><em>“我住长江头，君住长江尾。”–卜算子·我住长江头</em></p>
</blockquote>
]]></content>
      <categories>
        <category>Hardware</category>
        <category>High Speed</category>
      </categories>
      <tags>
        <tag>Altium Designer</tag>
        <tag>PCB</tag>
      </tags>
  </entry>
  <entry>
    <title>SI-01-PCB特性阻抗</title>
    <url>/2025/07/09/SI-01-Impedance/</url>
    <content><![CDATA[<p>本博客记录PCB阻抗与叠层设计的参考思路。</p>
<span id="more"></span>

<h2 id="特性阻抗"><a href="#特性阻抗" class="headerlink" title="特性阻抗"></a>特性阻抗</h2><p><span style="color:red"><strong>特性阻抗为高频信号在均匀传输线上的等效阻抗。</strong></span>信号线在传输信号时会与参考平面（地平面、电源平面）建立电场产生瞬间电流，由电压电流<em>V&#x2F;I</em>得等效阻值<em>Z<del>0</del></em>，具体取决于介电常数<em>ε<del>0</del></em>与每单位长度的电容<em>C<del>L</del></em>。<br>$$<br>Z_0&#x3D;\frac{83}{C_L}\sqrt{ε_0}<br>$$<br>对于非均匀传输线，称为“瞬时阻抗”，而非特征阻抗。**对一条线宽变化的传输线，瞬时阻抗没有意义。**线宽不变时，信号传输时的阻抗就是固定的，但PCB上的铜线也有厚度，比如常见的1oz、0.5oz铜厚，所以更准确的说法是横截面不变时，阻抗是固定的（<strong>一般同一层的铜厚一致，所以可以说线宽影响阻抗</strong>）。</p>
<p>而根据产生电场的条件，传输介质介电常数<em>ε<del>0</del></em>不变的情况下，信号传输线与参考平面的距离<em>d</em>越近&#x2F;面积（线宽）<em>S</em>越大，等效电容（寄生电容）<em>C</em>越大，进而等效阻抗<em>Z<del>0</del></em>越小。<br>$$<br>C&#x3D;ε_0\ast S&#x2F;d<br>$$</p>
<p>$$<br>Z_0&#x3D;\frac{83d}{S\sqrt{ε_0}}<br>$$</p>
<p>根据上式也能得出结论，对于电源&#x2F;地两个参考平面，其截面大阻抗低（约1Ω），对于带状线与微带线线宽窄阻抗高（约60-90Ω）。</p>
<p>特征阻抗的影响因素包括线宽、铜厚、板厚、层数、基板材料、表面工艺，可根据实际的阻抗设计值、阻抗公差计算线宽线距。<strong>介质越厚、线距越大阻抗越大；介电常数、铜厚、线宽、阻焊厚度越大阻抗越小。</strong></p>
<ul>
<li><p>介电常数</p>
<p>对FR-4，介电常数为3.9-4.5；</p>
<p>对聚四氟乙烯，介电常数为2.2-3.9；</p>
</li>
<li><p>阻焊厚度</p>
<p>刷绿油&#x2F;黑油（阻焊）一次使单端阻抗降低2Ω，差分阻抗降低8Ω。两次时翻倍，三次时不再变化。</p>
</li>
</ul>
<h2 id="阻抗计算"><a href="#阻抗计算" class="headerlink" title="阻抗计算"></a>阻抗计算</h2><p>传输线就像水管，水管粗细突变时水流会被阻拦。同样，一根传输线上阻抗突变意味着信号会发生反射，进而产生噪声干扰正常信号。</p>
<p>**做阻抗的目的就是减少信号反射点，降低传输损耗。*<em>一般在设计</em>f<del>clock</del>&gt;100MHz*的高速电路时就需要做阻抗。</p>
<p>可使用<a href="https://tools.jlc.com/jlcTools/index.html#/impedanceCalculatenew">嘉立创阻抗计算</a>或者SI9000输入参数进行线宽线距计算。以嘉立创为例，计算时需要区分单端&#x2F;差分阻抗与共面单端&#x2F;共面差分阻抗。</p>
<ul>
<li><p>单端阻抗：单根信号线与参考平面之间的阻抗</p>
</li>
<li><p>差分阻抗：差分线对间、与相邻参考层间的耦合阻抗。</p>
</li>
<li><p>共面单端阻抗：单根信号线与参考平面间（尽量完整参考地）、以及<strong>与同层两侧地铜皮的耦合阻抗。</strong></p>
<div>            <!--块级封装-->
    <center>    <!--将图片和文字居中-->
    <img src="image-20250712230625507.png" alt="image can't load." style="zoom:55%"><!-- alt内为提示词-->
    <br>        <!--换行-->
    共面单端阻抗    <!--标题-->
    </center>
</div>
</li>
<li><p>共面差分阻抗：差分信号线现对间、与参考平面间（尽量完整参考地）、**与同层两侧地铜皮的的耦合阻抗。**共面差分则与之类似。</p>
</li>
</ul>
<p>**共面地是为了抑制串扰、增加回流路径。**对于多层板，可利用单端阻抗和差分阻抗计算设计，但是对于以下情况，通常需要使用共面单端与共面差分：</p>
<ul>
<li>两层板。板厚过大，根据公式限制较小阻抗时线宽较大(可能达到100mil)，而且两层板通常没有完整的参考地。</li>
<li>射频天线</li>
<li>高速信号</li>
</ul>
<h2 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2><ul>
<li>RS232:可不做（低频高压摆特性）</li>
<li>LVDS：100Ω差分</li>
<li>CAN：100Ω差分</li>
<li>USB：90Ω差分</li>
<li>SATA：90Ω差分</li>
<li>Ethernet:CAN：100Ω差分</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://blog.csdn.net/yinuoheqian123/article/details/129390510">传输线的物理基础（四）：传输线的特征阻抗-CSDN博客</a></li>
<li><a href="https://tools.jlc.com/jlcTools/index.html#/impedanceCalculatenew">嘉立创阻抗计算</a></li>
<li><a href="https://www.bilibili.com/video/BV1idAhe2E3a/?spm_id_from=333.337.search-card.all.click&vd_source=5465b0f4790ebae45362caa6519f3b79">如何理解共面差分阻抗，共面单端阻抗？有哪些影响因素？如何用嘉立创阻抗计算神器计算阻抗值？哔哩哔哩</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/520196609">差分走线有5个常见误区，你是否出现？ - 知乎</a></li>
<li><a href="https://wwwangguan.github.io/2023/08/10/dian-zi-dian-li/layout-yao-qiu/chang-yong-tong-xin-zu-kang-yao-qiu/">常用通信阻抗要求 | WwWangGuan</a></li>
</ol>
<p align="center">---------------------------  End  ---------------------------</p>

<blockquote>
<p><em>“没有调查，没有发言权。”–毛泽东《反对本本主义》</em></p>
</blockquote>
]]></content>
      <categories>
        <category>SI</category>
      </categories>
      <tags>
        <tag>PCB</tag>
        <tag>Impedance</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-使用指南</title>
    <url>/2025/06/17/Git-Using_Guide/</url>
    <content><![CDATA[<p>本博客存放Git使用过程中的指令与配置。</p>
<span id="more"></span>

<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ol>
<li><p>查看配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="LF与CRLF换行"><a href="#LF与CRLF换行" class="headerlink" title="LF与CRLF换行"></a>LF与CRLF换行</h3><h4 id="具体措施"><a href="#具体措施" class="headerlink" title="具体措施"></a>具体措施</h4><p>使用Hexo博客工具在推送至Github时，Bash内弹出大量警告：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">warning: <span class="keyword">in</span> the working copy of <span class="string">&#x27;tags/.../index.html&#x27;</span>, LF will be replby CRLF the next <span class="keyword">time</span> Git touches it</span><br></pre></td></tr></table></figure>

<p>查阅网络资料，发现<code>LF(\n)</code>与<code>CRLF(\r\n)</code>分别是Linux与Windows下的换行符。Git Bash为Linux环境，Git工作区默认CRLF。最终push到远程仓库时git会统一格式全部转化为用<code>CRLF</code>作为换行符。</p>
<p>使用如下指令禁用如下转换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf <span class="literal">false</span> //禁用自动转换</span><br></pre></td></tr></table></figure>

<p>对于每一类文件的转换配置可以在 <code>.gitattributes</code>内配置，可见参考资料3。因目前未涉及不同文件，暂时不做其他调整。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol>
<li><a href="https://www.jianshu.com/p/783f7736e77e">解决hexo deploy时出现的警告：LF will be replaced by CRLF - 简书</a></li>
<li><a href="https://stackoverflow.com/questions/17628305/windows-git-warning-lf-will-be-replaced-by-crlf-is-that-warning-tail-backwar">Windows git “warning: LF will be replaced by CRLF”, is that warning tail backward? - Stack Overflow</a></li>
<li><a href="https://juejin.cn/post/6942320745494085669">Git 优雅处理行结束符 - 掘金</a></li>
<li><a href="https://www.cnblogs.com/youpeng/p/11243871.html">git core.autocrlf配置说明 - Youpeng - 博客园</a></li>
</ol>
<p align="center">---------------------------  End  ---------------------------</p>

<blockquote>
<p><em>人越脱离自然便越发恐惧孤独。</em></p>
</blockquote>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Sideline-手机流量卡</title>
    <url>/2025/06/10/Sideline-SIM_Card/</url>
    <content><![CDATA[<p>本博客存放博主个人觉得不错的流量卡办理链接，赚一点点外快…</p>
<p>每周三、周五晚上9:00更新链接，如有需要请在办理链接处自行挑选办理。</p>
<span id="more"></span>

<h2 id="订单查询"><a href="#订单查询" class="headerlink" title="订单查询"></a>订单查询</h2><p><a href="https://vip.777haoka.cn/cha?k=bHJ1MGp0Vlg0RW89">点击查询订单状态</a></p>
<h2 id="办理链接-2025-08-24更新"><a href="#办理链接-2025-08-24更新" class="headerlink" title="办理链接(2025.08.24更新)"></a>办理链接(2025.08.24更新)</h2><p>该链接主要放一些博主觉得不错的全国发货的流量卡，部分流量卡限制收货地所在省份，此处并未放置。如果有需求，也可以<a href="https://space.bilibili.com/405856572?spm_id_from=333.788.0.0">点击此处</a>在B站私信我。</p>
<p><span style="color:red"><strong>注意：下单之前请点击链接内的详细资料一栏，判断是否是禁发送区域，如果是则会审核失败，可以更换另外的链接…</strong></span></p>
<h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><ol>
<li><a href="https://vip.777haoka.cn/order/index.php?uid=bHJ1MGp0Vlg0RW89&pid=2436">新移动淘气卡【选号后报单发货】29元100G通用+80G定向+200分钟+权益会员(自主激活，18-26岁,没有视频会员)</a></li>
<li></li>
<li></li>
</ol>
<h3 id="联通"><a href="#联通" class="headerlink" title="联通"></a>联通</h3><ol>
<li><a href="https://vip.777haoka.cn/order/index.php?uid=bHJ1MGp0Vlg0RW89&pid=2455">联通小豹卡【三照下单】19元150G通用+300分钟(到期可续，18-25，自主激活,限量)</a></li>
<li><a href="https://vip.777haoka.cn/order/index.php?uid=bHJ1MGp0Vlg0RW89&pid=2494">联通叮当卡26元125G【全国发货】无短信，自主激活(全国发货无禁区,自主激活,无短信功能,佣金可合追溯)</a></li>
<li><a href="https://vip.777haoka.cn/order/index.php?uid=bHJ1MGp0Vlg0RW89&pid=2305">联通沃派卡【发货快】39元280G通用+100分钟+会员权益(自主激活，全国发货，18-26)</a></li>
<li><a href="https://vip.777haoka.cn/order/index.php?uid=bHJ1MGp0Vlg0RW89&pid=2306">联通沃龙卡29元150G通用+300分钟(自主激活，18-25岁)</a></li>
<li><a href="https://vip.777haoka.cn/order/index.php?uid=bHJ1MGp0Vlg0RW89&pid=2298">联通水花卡T2【四照发货】29元230G通用+300分钟+会员权益(自主激活，需上传一证通查发货,18-30)</a></li>
<li></li>
</ol>
<h3 id="电信"><a href="#电信" class="headerlink" title="电信"></a>电信</h3><p>2. </p>
<h2 id="自用截图"><a href="#自用截图" class="headerlink" title="自用截图"></a>自用截图</h2><p>博主个人自用移动保号套餐+联通流量卡，未出现流量限速和网络丢失的情况。</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="image-20250610141933596.png" alt="image can't load." style="zoom:55%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    自用套餐	<!--标题-->
    </center>
</div>


<p align="center">---------------------------  End  ---------------------------</p>

<blockquote>
<p><em>若待上林花似锦，出门俱是看花人。–城东早春</em></p>
</blockquote>
]]></content>
      <categories>
        <category>Sideline</category>
        <category>SIM Card</category>
      </categories>
      <tags>
        <tag>SIM Card</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-03-Next嵌入PDF</title>
    <url>/2025/06/04/Hexo-03-Embed_PDF_In_Next/</url>
    <content><![CDATA[<p>本文介绍在使用Hexo Next主题搭建个人博客时使用hexo-pdf插件或PDF.js工具在博客内嵌入显示pdf文件的解决方案，便于进行手机和电脑双端在线浏览。</p>
<span id="more"></span>

<h2 id="博文目的"><a href="#博文目的" class="headerlink" title="博文目的"></a>博文目的</h2><p>博主在使用Hexo的过程中发现除去可以插入图像文件外，还可以插入pdf文件进行在线预览。类似以下样例，一个网页内插入了一个方框显示pdf内容：</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="image-20250604084524431.png" alt="image can't load." style="zoom:75%"><!-- alt内为提示词-->
    <br>		<!--换行-->
    PDF预览(参考资料1)	<!--标题-->
    </center>
</div>

<p>因此博主预期在Next主题下实现类似功能。</p>
<h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><p>首先在<code>next/_config.yml</code>主题配置文件内使能pdf配置。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pdf:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="string">enable</span></span><br><span class="line">  <span class="comment"># Default height</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">600px</span></span><br></pre></td></tr></table></figure>

<h3 id="hexo-pdf插件（不推荐）"><a href="#hexo-pdf插件（不推荐）" class="headerlink" title="hexo-pdf插件（不推荐）"></a>hexo-pdf插件（不推荐）</h3><p>通过搜索其他人搭建个人博客的经验，部分作者使用<code>hexo-pdf</code>插件用于显示pdf文件，尝试该方案。</p>
<ul>
<li><p>在博文根目录下安装插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install --save hexo-pdf</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>source</code>文件夹内创建pdf文件夹，在<code>.md</code>文档内插入以下语句。</p>
<p><strong>此方式在本地生成后弹出了IDM文件下载链接，未出现预览窗口，如下图。如果显示<code>Cannot GET /2025/06/04/Test.pdf</code>说明文件路径有问题</strong></p>
 <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% pdf  /pdf/Test.pdf %&#125;</span><br></pre></td></tr></table></figure>

<div>            <!--块级封装-->
    <center>    <!--将图片和文字居中-->
    <img src="image-20250604091556759.png" alt="image can't load." style="zoom:75%"><!-- alt内为提示词-->
    <br>        <!--换行-->
    弹出下载界面，无预览    <!--标题-->
    </center>
</div>
</li>
<li><p>尝试更改文件夹，在<code>_post</code>文件夹下创建与<code>.md</code>同名的文件夹 ，在<code>.md</code>文档内插入以下两句语句。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% pdf ./Test.pdf %&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% pdf  Test.pdf %&#125;</span><br></pre></td></tr></table></figure>

<p>结果与第2步放入<code>source</code>文件夹类似，本地预览弹出文件下载框，但是无法加载出内容。</p>
<p>该方案推送至Github后可正常浏览，效果如下：</p>
<div class="pdf-container" data-target="Test.pdf" data-height="400px"></div></li>
</ul>
<p><strong>缺点：该方案只能在部署到服务器后在PC端预览，手机端查看博文则会显示文件丢失。也无法在本地生成后查看效果。</strong></p>
<h3 id="PDF-js工具（推荐）"><a href="#PDF-js工具（推荐）" class="headerlink" title="PDF.js工具（推荐）"></a>PDF.js工具（推荐）</h3><p>有很多博主在个人博客使用这个pdf工具，但多数应用主题是butterfly或者fluid主题，博主希望尝试应用在next主题上，便于在手机与电脑端实现双端浏览。</p>
<ol>
<li><p><a href="https://mozilla.github.io/pdf.js/getting_started/#download">下载PDF.js</a>工具包，博主选择下载modern browsers v5.3.31版本，<a href="https://github.com/mozilla/pdf.js/tags">点击此处下载其他版本</a></p>
</li>
<li><p>在next主题\source下建立一个文件夹pdfjs，存放解压文件</p>
</li>
<li><p>在博客根目录的 <code>_config.yml</code>文件中设置，取消渲染</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">skip_render:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">pdfjs/**/*</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用以下代码插入pdf，其中<code>src</code>参量的<code>/pdfjs/web/viewer.html</code>为预览窗口，后面紧跟的<code>file=https://MicroPrism.github.io/2025/06/04/Hexo-Next主题嵌入pdf显示/Test.pdf&quot;</code>是Github上的文件路径。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">&quot;/pdfjs/web/viewer.html?file=https://MicroPrism.github.io/2025/06/04/Hexo-Next主题嵌入pdf显示/Test.pdf&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">width</span>=<span class="string">&quot;80%&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">height</span>=<span class="string">&quot;750&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此种方式部署到Github之后出现404 File Not Found的文件无法加载的错误，如下图：</p>
<div>            <!--块级封装-->
    <center>    <!--将图片和文字居中-->
    <img src="image-20250609113753049.png" alt="image can't load." style="zoom:50%"><!-- alt内为提示词-->
    <br>        <!--换行-->
    404 File Not Found    <!--标题-->
    </center>
</div>


<p>最初博主误认为是和大多数博主一样出现的文件<strong>跨域问题</strong>，但发现<code>https://MicroPrism.github.io/2025/06/04/Hexo-Next主题嵌入pdf显示/Test.pdf</code>网页可以单独打开，因此推测可能是文件加载路径出错，也就是<code>viewer.html</code>路径出错。</p>
<p>查找原因时发现该路径被博主多写了一个 <code>pdfjs/pdfjs/..</code>，而正确路径需要和pdfjs的存储路径对应，应为 <code>pdfjs/web/viewer.html</code>，至此问题解决。</p>
</li>
<li><p>查看<code>viewer.html</code>源码，能看到PDF.js工具在4.0版本开始后引用了<code>pdf.mjs</code>和<code>viewer.mjs</code>两个资源文件，如下图：</p>
<div>            <!--块级封装-->
    <center>    <!--将图片和文字居中-->
    <img src="image-20250609120409051.png" alt="image can't load." style="zoom:50%"><!-- alt内为提示词-->
    <br>        <!--换行-->
    v5.3.31 viewer.html资源引用    <!--标题-->
    </center>
</div></li>
</ol>
<p>在此之前的版本则使用<code>.js</code>资源文件，如下图：</p>
   <div>			<!--块级封装-->
       <center>	<!--将图片和文字居中-->
       <img src="image-20250609164024819.png" alt="image can't load." style="zoom:50%"><!-- alt内为提示词-->
       <br>		<!--换行-->
       v3.11.174 viewer.html资源引用	<!--标题-->
       </center>
   </div>


<p>   效果预览如下：</p>
   <iframe src="/pdfjs/web/viewer.html?file=https://MicroPrism.github.io/2025/06/04/Hexo-03-Embed_PDF_In_Next/Test.pdf" width="80%" height="750" frameborder="0">
   </iframe>


<ol start="6">
<li><p>打开<code>web/viewer.mjs</code>资源文件，更改以下两个配置值为 <code>true</code>：</p>
<figure class="highlight mjs"><table><tr><td class="code"><pre><span class="line"><span class="attr">disableAutoFetch</span>: &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">kind</span>: <span class="title class_">OptionKind</span>.<span class="property">API</span> + <span class="title class_">OptionKind</span>.<span class="property">PREFERENCE</span></span><br><span class="line">&#125;,</span><br><span class="line">  <span class="attr">disableStream</span>: &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">kind</span>: <span class="title class_">OptionKind</span>.<span class="property">API</span> + <span class="title class_">OptionKind</span>.<span class="property">PREFERENCE</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>该措施可以实现pdf文件的按需加载，提升观感与加载速度。</p>
</li>
</ol>
<ul>
<li><p>注意事项：</p>
<p>其他人的博客上有提到文件跨域导致的文件无法显示，但截止目前，博主没有遇到此问题，如果遇到，请参考第6条参考资料。</p>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://awesomeyouthzhang.github.io/2020/02/05/hexo%20%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8F%92%E5%85%A5pdf%E6%8F%92%E4%BB%B6/">hexo 中如何插入pdf | 智贤</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/550626417">hexo中插入PDF |知乎</a></li>
<li><a href="https://www.poetyin.com/posts/4a17b156/">The Details Usage of the Hexo Next-Theme Plugin <code>next-pdf</code> | Poetry Continent</a></li>
<li><a href="https://jiqiren116.github.io/2024/03/24/hexo%E5%8D%9A%E5%AE%A2%E6%98%BE%E7%A4%BApdf/">hexo博客显示pdf | robot-x Blog</a></li>
<li><a href="https://www.bilibili.com/opus/771629864647131138">Hexo内嵌PDF.js | 哔哩哔哩</a></li>
<li><a href="https://blog.csdn.net/weixin_44657449/article/details/119894091">pdf.js｜CSDN博客</a></li>
</ol>
<p align="center">---------------------------  End  ---------------------------</p>

<blockquote>
<p><em>有情芍药含春泪，无力蔷薇卧晓枝。– 春日</em></p>
</blockquote>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Next</tag>
        <tag>Pdf</tag>
      </tags>
  </entry>
  <entry>
    <title>NCU-873控制专业考研形势</title>
    <url>/2025/06/02/NCU-873_Trends/</url>
    <content><![CDATA[<p>本篇博文简要介绍南昌大学控制科学与工程、控制工程截止2025年的考研形式…</p>
<span id="more"></span>

<p>整理的考情如下：</p>
<iframe src="/pdfjs/web/viewer.html?file=https://MicroPrism.github.io/2025/06/02/NCU-873_Trends/NCU873.pdf" width="80%" height="750" frameborder="0">
</iframe>


<p align="center">---------------------------  End  ---------------------------</p>

<blockquote>
<p><em>寒来暑往，来日方长。</em></p>
</blockquote>
]]></content>
      <categories>
        <category>NCU</category>
        <category>873</category>
      </categories>
      <tags>
        <tag>NCU</tag>
        <tag>Postgrad</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA-02-Verilog语法</title>
    <url>/2025/05/29/FPGA-02-Verilog_Syntax/</url>
    <content><![CDATA[<p>本文介绍Verilog HDL基本语法，主要将该代码与类似的C&#x2F;C#语言代码进行对比，根据架构的不同强调表示形式的差异。</p>
<span id="more"></span>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="逻辑值"><a href="#逻辑值" class="headerlink" title="逻辑值"></a>逻辑值</h3><p>FPGA内逻辑值除0、1外新增高阻态Z，表示无驱动。而实际运行中还可能出现亚稳态。</p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符用于定义常数、变量、信号、端口、子模块或参数名称，大小写则为不同变量。自定义标识符需要为数字、字母、下划线、$等，且首字母需要为字母或者下划线。</p>
<blockquote>
<p>类似于C语言的关键字，如int、void、const等等。自定义标识符不能与关键字冲突。</p>
</blockquote>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>Verilog中不变的值，分为整形、实型、字符串型。</p>
<p>在表示整形数据时可以有以下几种：</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span>    <span class="comment">//位宽32的整数</span></span><br><span class="line"><span class="number">8&#x27;hab</span> <span class="comment">//8位hex值0xab</span></span><br><span class="line"><span class="number">8&#x27;d171</span><span class="comment">//8位dec值171</span></span><br><span class="line"><span class="number">8&#x27;o253</span><span class="comment">//8位oct值0253</span></span><br><span class="line"><span class="number">8&#x27;b101</span><span class="comment">//8位bin值</span></span><br></pre></td></tr></table></figure>

<p><span style="color:red"> 类似于C语言存在整形提升或数据截断，Verilog也存在此种问题。</span></p>
<p>例如，C语言使用<code>uint8_t data_a = 0x123;uint8_t data_b =0x1;</code>定义两个变量，数据类型为8bit位宽，显然前者溢出而后者补足。类比到Verilog中只是修改了表述方式，在赋值时赋予位宽，而且不用按8bit对齐：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">a = <span class="number">8&#x27;h123</span>; <span class="comment">//溢出，随后截断为0x23</span></span><br><span class="line">b = <span class="number">12&#x27;h1</span>;	<span class="comment">//不足，补充为0x001</span></span><br></pre></td></tr></table></figure>

<p>实型数据，说白了就是浮点型，小数，可以采用<code>123.45e2</code>表示数值12345。</p>
<p>字符串指双信号中的字符序列，与C一致，存储的ASCII码值。例如下方字符串 <code>Open log file.</code>可以用C的printf输出，同样可以在verilog内用$display输出 :</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> * log_str = <span class="string">&quot;Open log file.&quot;</span>;</span><br><span class="line">pringtf(<span class="string">&quot;%s&quot;</span>,log_str);</span><br><span class="line">...</span><br><span class="line">$display(<span class="string">&quot;Open log file.&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>Verilog的变量类型基于FPGA的结构基础。FPGA可以抽象成若干门电路，其内部是<strong>电路的连接</strong>，因此定义变量时即分为：</p>
<ul>
<li>线网：<strong>物理电路层面的通路</strong>，wire；</li>
<li>寄存器：<strong>软件层面的变量</strong>，reg；</li>
</ul>
<p>always或initial中被赋值的量数据reg量，assign分配的量属于wire型量。</p>
<blockquote>
<p>C语言最底层的设计最多是操作硬件IO，大多数是存储在堆、栈里的软件量，进行软件层面的运算。Verilog是直接基于电路，搭的是电路，软件量用于进行辅佐运算。</p>
</blockquote>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>此处参数是指module块内部的参数，用于定义状态机的状态、数据位宽和计数器计数个数大小等。例如下方定义的的<code>CNT_MAX</code>：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Parameter CNT_MAX = <span class="number">25&#x27;d24_999_999</span></span><br></pre></td></tr></table></figure>

<p>在实例化模块时可以配置参数：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">counter </span><br><span class="line">#( </span><br><span class="line">    <span class="variable">.CNT_MAX</span> (<span class="number">25&#x27;d24</span> ) <span class="comment">//实例化时参数可修改 </span></span><br><span class="line"> )</span><br><span class="line">counter_inst </span><br><span class="line">(</span><br><span class="line">    <span class="variable">.sys_clk</span> (sys_clk ), <span class="comment">//input sys_clk</span></span><br><span class="line">    <span class="variable">.sys_rst_n</span> (sys_rst_n ), <span class="comment">//input sys_rst_n</span></span><br><span class="line">	<span class="variable">.led_out</span> (led_out ) <span class="comment">//output led_out </span></span><br><span class="line">);          </span><br></pre></td></tr></table></figure>

<p>那么我们可以这么类比C语言，一个module可以当做一个函数，如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test(</span><br><span class="line">	<span class="keyword">input</span> a,</span><br><span class="line">    <span class="keyword">inout</span> b,</span><br><span class="line">    <span class="keyword">output</span> c</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在不管内部如何处理的情况下，其中的输入、输出、输入输出就可以类似为下方的a、b、c，只不过所处的位置不同，修饰也更加直观:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a,<span class="type">int</span> * b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c = a + *b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>此处应当注意，Verliog中包括 <code>=</code>以及<code>&lt;=</code>两种符号。首先思考其底层结构——门电路，搭建的不同的物理电路当然可以执行多个程序流（目前还没学到，暂时这么称呼），也就是常说的<strong>并行逻辑</strong>。</p>
<blockquote>
<p>MCU则是顺序执行逻辑，从上至下，从外至内逐步执行。为了达到类似的并行效果，衍生出了FreeRTOS、uCOSIII等操作系统，频繁切换线程达到并行的假象。</p>
</blockquote>
<p>MCU上有顺序转并行的方案，FPGA上也有类似的顺序执行的模块，比如说每个always块上是一个互相独立的并行块，那么always内部应该可以通过某种方式来达到顺序执行的效果——引出阻塞、非阻塞赋值。</p>
<ul>
<li><p>非阻塞赋值  &lt;&#x3D;</p>
<p>非阻塞赋值不会影响下一个语句的执行。**在某个时刻，一段非阻塞赋值代码是同时执行的，所有代码执行完后再进行赋值操作、刷新结果。**例如下方代码，假设a初值为1：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">a &lt;= a+<span class="number">1</span>;  <span class="comment">//line 1</span></span><br><span class="line">b &lt;= a;	<span class="comment">//line 2</span></span><br></pre></td></tr></table></figure>

<p>那么在运行时，line 1 与 line 2 同时执行，用于运算的a值为1，运行完后<code>a=2，b=1</code>。</p>
</li>
<li><p>阻塞赋值 &#x3D;</p>
<p><strong>阻塞赋值语句按照顺序执行，执行完立即进行赋值操作、刷新结果</strong>，上一句代码会影响下一句的执行。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">a = a + <span class="number">1</span>; <span class="comment">//line 1</span></span><br><span class="line">b = a; 	   <span class="comment">//line 2</span></span><br></pre></td></tr></table></figure>

<p> 上方的代码在运行时，执行完line 1得<code>a = 2</code>，立刻将该值用于下一句代码，得到<code>b=2</code>。</p>
</li>
</ul>
<p>这种思路与C中<code>a++</code>和 <code>++a</code>类似，阻塞就是<code>a++</code>用上一时刻的值进行计算，随后刷新，而非阻塞就是<code>++a</code>，我执行完代码，立刻用新的值进行后续运算。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li><p>算术运算：<code>+、-、*、/</code></p>
</li>
<li><p>关系运算：<code>&gt;、&lt;、&gt;=、&lt;=</code>，在没有括号的情况下优先进行算术运算。</p>
</li>
<li><p><strong>归约运算&#x2F;位运算</strong>：<code>&amp;、|、^、~&amp;、~|、~^</code></p>
<p>C语言中的位运算符属于双目运算符(C++、C#暂且不说)，而Verilog中可以用于一个变量得出一个bit值，如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">&amp;<span class="number">4</span>b&#x27;<span class="number">1010</span> = <span class="number">1</span>&amp;<span class="number">0</span>&amp;<span class="number">1</span>&amp;<span class="number">0</span> = <span class="number">1&#x27;b0</span></span><br></pre></td></tr></table></figure>

<p>如果把1个bit当作一个门的输出，那么一个数据的归约运算当然可以看作多个电路接入一个与或非门。</p>
<p>在Verilog中，双目运算和C基本一致，但是<strong>限定左右参数位宽一致</strong></p>
</li>
<li><p>逻辑运算：<code>&amp;&amp;、||、!=</code>等，不再赘述</p>
</li>
<li><p>移位运算符：<code>&lt;&lt;、&gt;&gt;</code>，逻辑与C基本一致。<strong>但是右操作数如果为x（不定值）或z（高阻），那么运算结果为不定值。</strong></p>
</li>
<li><p>条件运算符：<code>exp1 ? action1 : action2</code>，这个表达式与C一致，多层嵌套时也是就近结合。</p>
</li>
</ul>
<p>运算符的优先级：一元（归约）&gt;二元（算术、移位、关系、等和不等、按位运算）&gt;三元（条件运算）。</p>
<p>其优先级也类似C语言，一般使用<code>()</code>区分。</p>
<ul>
<li>位拼接标识符：<code>&#123;,&#125;</code>，常用来拼接不同位宽的数据，同时可以实现数据右移和左移。</li>
</ul>
<h3 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h3><p>与C语言相同，包括<code>if-else</code> 和<code>case</code> 语句，在此不再赘述。但是需要注意：</p>
<ul>
<li>如果if语句没有else块，可能会在组合逻辑中产生latch</li>
<li>if语句尽量写成多个else if的分支形式，而不建议写成if else  内嵌套if else的语句</li>
</ul>
<h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><p>把该节起名为参数类型的原因是希望参照C语言的函数，划分输入输出的思路。</p>
<p>Verilog的参数类型可以划分为<code>input、output、inout</code>三类，我们可以这么类比：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">input</span> <span class="keyword">wire</span> sel,</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">input</span> <span class="keyword">wire</span> data_out,</span><br><span class="line">        <span class="keyword">inout</span> <span class="keyword">wire</span> data_bus,</span><br><span class="line">        <span class="keyword">output</span> <span class="keyword">wire</span> data_in</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<ul>
<li>sel、data_out: 物理线型输入参数</li>
<li>data_bus: 物理线型可输入可输出参数，例如I2C数据线</li>
<li>data_in: 物理线型输出参数</li>
</ul>
<p>那么显式的对比到C语言中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">uint8_t</span> <span class="title function_">test</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">volatile</span> <span class="type">const</span> <span class="type">uint8_t</span> sel,      <span class="comment">//只能输入</span></span></span><br><span class="line"><span class="params">	<span class="keyword">volatile</span> <span class="type">const</span> <span class="type">uint8_t</span> data_out, <span class="comment">//只能输入</span></span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">    <span class="keyword">volatile</span> <span class="type">uint8_t</span> * data_bus <span class="comment">//可做输入，可修改值</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">return</span> data_in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>其中的volatile表示易变量。每次从硬件地址重新读取</li>
<li>其中的const显示表示这个量不可被软件层面修改</li>
<li>verilog中若有多个输出，C中可集成在一个结构体中</li>
</ul>
<h2 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h2><p>时间单位与精度</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns </span><span class="comment">// 单位1ns 精度1ns</span></span><br><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/10ps </span><span class="comment">// 单位1ns 精度10ps，则#10.11表示10.11ns = 10110 ps</span></span><br></pre></td></tr></table></figure>

<p>其中<strong>前者是时间单位，后者是仿真的最小刻度，精度必须小于时间单位。</strong></p>
<h3 id="调试函数"><a href="#调试函数" class="headerlink" title="调试函数"></a>调试函数</h3><p>FPGA里的函数依靠<code>$</code>符号为区分，功能类似C。</p>
<ol>
<li><p>$display 打印信息,打印后自动换行</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;%d+%d=%d&quot;</span>,a,b,c);</span><br><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>等价于printf，例如printf(“%d”,a);但是$display可以不加格式符，默认为十进制。</p>
<p>这个例子用C#函数来解释就是Console.WriteLine(…);函数</p>
</blockquote>
</li>
<li><p>$write打印信息</p>
<p>用法几乎完全同 <code>$display</code>，但是<code>write</code>可以使用换行符</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$write</span>(<span class="string">&quot;%d+%d=%d\n&quot;</span>,a,b,c);</span><br></pre></td></tr></table></figure>
</li>
<li><p>$strobe，格式同$display。<strong>但是该函数是在触发操作后执行的。</strong> 例如下方代码，在 <code>initial</code>块触发最后执行。</p>
<div>
    <center>    <!--将图片和文字居中-->
    <img src="image-20250601142141567.png" alt="image can't load." style="zoom:75%">
    <br>        <!--换行-->
    $strobe代码示意    <!--标题-->
    </center>
</div>

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">display:<span class="number">0101</span>+xxxx=x</span><br><span class="line">strobe:<span class="number">0101</span>+<span class="number">0110</span>=<span class="number">11</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>$ monitor，持续监测量，使用格式同上方几个函数。但可以理解为C语言中的数据断点，当监测量变发生化时输出调试信息。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    a = <span class="number">5</span>; <span class="comment">//输出</span></span><br><span class="line">    #<span class="number">100</span>;</span><br><span class="line">    b = <span class="number">6</span>; <span class="comment">//输出</span></span><br><span class="line">    #<span class="number">100</span>;</span><br><span class="line">    c = a + b; <span class="comment">//输出</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">initial</span> <span class="built_in">$monitor</span>(<span class="string">&quot;%d+%d=%d&quot;</span>,a,b,c);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="终止函数"><a href="#终止函数" class="headerlink" title="终止函数"></a>终止函数</h3><ol>
<li>$stop，暂停仿真。可使用modelsim指令或按键继续仿真。</li>
<li>$finish，结束仿真。只可重新开始。</li>
</ol>
<h3 id="配置函数"><a href="#配置函数" class="headerlink" title="配置函数"></a>配置函数</h3><ol>
<li><p>$time，返回64bit<strong>当前仿真时间</strong></p>
</li>
<li><p>$random，产生随机数</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> #<span class="number">10</span> a = <span class="built_in">$random</span>;</span><br><span class="line"><span class="keyword">initial</span> <span class="built_in">$monitor</span>(<span class="string">&quot;a = %d @time %d&quot;</span>,a,<span class="built_in">$time</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>$readmemb，读取二进制文件</p>
</li>
<li><p>$readmemh，读取十六进制文件</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] a [<span class="number">20</span>:<span class="number">0</span>]; <span class="comment">// 21位位深，8位位宽的数组</span></span><br><span class="line"><span class="comment">//等价于 uint8_t a[21];</span></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$readmemb</span>(<span class="string">&quot;text.txt&quot;</span>,a);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;=<span class="number">20</span>; i=i+<span class="number">1</span> ) <span class="keyword">begin</span></span><br><span class="line">           	#<span class="number">10</span>;</span><br><span class="line">            <span class="built_in">$write</span>(<span class="string">&quot;%s&quot;</span>,a[i]);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p align="center">---------------------------  End  ---------------------------</p>

<blockquote>
<p><em>与人同行的前提是，你要先在路上。</em></p>
</blockquote>
]]></content>
      <categories>
        <category>FPGA</category>
        <category>Syntax</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>Verilog</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-02-推送错误(Fatal:502)解决办法</title>
    <url>/2025/05/29/Hexo-02-Deploy_Error_And_Solution/</url>
    <content><![CDATA[<p>该博客主要介绍使用Hexo部署博客阶段出现Something Wrong中The requested URL returned error: 502错误码的原因与解决办法。</p>
<span id="more"></span>

<h2 id="现象描述"><a href="#现象描述" class="headerlink" title="现象描述"></a>现象描述</h2><p>博主在先前使用Hexo部署博文时，直接使用在git bash中使用推送命令<code>$ hexo d</code>即可把当前的文档推送到服务器，并且在线查看。</p>
<p>而本次typora完成文档编辑后生成网页，本地端口预览正常，但部署至github时报错，大致报错信息如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://github.com/MicroPrism/MicroPrism.github.io.git/&#x27;: The requested URL returned error: 502</span><br><span class="line">FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: Spawn failed</span><br><span class="line"><span class="code">    at ChildProcess.&lt;anonymous&gt; (F:\Blog\MicroPrism\node_modules\hexo-deployer-git\node_modules\hexo-util\lib\spawn.js:51:21)</span></span><br><span class="line"><span class="code">    at ChildProcess.emit (node:events:518:28)</span></span><br><span class="line"><span class="code">    at cp.emit (F:\Blog\MicroPrism\node_modules\cross-spawn\lib\enoent.js:34:29)</span></span><br><span class="line"><span class="code">    at ChildProcess._handle.onexit (node:internal/child_process:293:12)</span></span><br></pre></td></tr></table></figure>

<h2 id="场景变化"><a href="#场景变化" class="headerlink" title="场景变化"></a>场景变化</h2><ol>
<li><p>相对于上一次博客推送，本次使用ios手机热点，运营商为中国联通，而上次连接单位的wifi</p>
</li>
<li><p>此次推送博文以html语法插入了图片</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>			<span class="comment">&lt;!--块级封装--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">center</span>&gt;</span>	<span class="comment">&lt;!--将图片和文字居中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;dir-name/image-name.png&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">alt</span>=<span class="string">&quot;image can&#x27;t load.&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">style</span>=<span class="string">&quot;zoom:75%&quot;</span>/&gt;</span><span class="comment">&lt;!-- alt内为提示词--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span>		<span class="comment">&lt;!--换行--&gt;</span></span><br><span class="line">    title	<span class="comment">&lt;!--标题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>在此优先将解决办法写在此处，为其他人提供参考。</p>
<ol>
<li><p>根据报错信息，确认与服务器联通状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ping github.com</span><br></pre></td></tr></table></figure>

<p>能ping通说明不是github服务器问题。</p>
</li>
<li><p>尝试使用ssh访问github服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>如果能访问成功，说明本地密钥和github能匹配，连接异常不是密钥问题。连接正常时显示以下信息：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Hi repo-name! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>

<p>3.更改推送时的repo。打开hexo根目录<code>_config.yml</code>文件，更改为下方样式，其中repo-name为自己的仓库名。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:repo-name/repo-name.github.io.git</span> <span class="comment">##更换为ssh推送</span></span><br><span class="line">  <span class="comment">#repo: https://github.com/repo-name/repo-name.github.io.git ##https推送</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<p>至此，问题解决，有兴趣的可以观察下方的问题分析。</p>
</li>
</ol>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="语法冲突？"><a href="#语法冲突？" class="headerlink" title="语法冲突？"></a>语法冲突？</h3><p>博主首先对问题最直观的定位是<strong>插入图片的语法不统一</strong>导致的异常。相对于大多数网友选择的直接插入的方案，比如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">image name</span>](<span class="link">image-path/image.png</span>)</span><br></pre></td></tr></table></figure>

<p>我选择使用html语法插入，这种语法有几个好处：</p>
<ol>
<li>参数和提示信息更多。比如可以调节图片的位置，center、left、right。或者缩放比例，再或者是图片无法加载的提示信息。</li>
<li>可以加入对图片的解释，对于曲线类的图片，有题注说明会更清晰。</li>
<li>markdown和localhost都可以直接预览。</li>
</ol>
<p>随后到hexo官方查阅<a href="https://hexo.io/zh-cn/docs/troubleshooting">故障排除 | Hexo</a>的资料，搜索关键词“somthing wrong”定位到<strong>模型渲染错误</strong>一节，认为是语法错误，按其意见尝试修改，见下方第1点。同时在网络上搜索使用html语法插入图片的相关问题与解决方案，逐步查找原因：</p>
<ol>
<li>在html语法段加上<code>&#123;&#123;&#125;&#125;</code>，仍然异常。</li>
<li>删除所有html语法，仍然异常。</li>
<li>删除 .md文件名的空格，仍然异常。</li>
</ol>
<p>到此，即可排除是文件名空格、中文字符解析、html语法兼容的问题。<span style="color:red"><strong>后来发现something wrong是很笼统的错误提示，需要向前或向后找更详细的提示。</strong></span></p>
<h3 id="连接异常！"><a href="#连接异常！" class="headerlink" title="连接异常！"></a>连接异常！</h3><p>考虑到hexo推送机制底层还是调用git工具，那么如果出现问题，作为hexo的子集，git应该能获得更多错误信息。果然搜索到类似的帖子，在此进行概括：</p>
<blockquote>
<p>错误代码502意味着网络问题，可能是服务器端关闭或者是访问端的网络波动。首先需要检查你的防火墙、代理、以及网关是否拦截了访问。</p>
</blockquote>
<p>从这段解释里引出了对场景变化的第二个考虑，<strong>网络变化-从单位的网络变为手机热点，可能是运营商拦截？</strong></p>
<p>但是本地却能ping通github。所以<strong>进一步考虑到是否是密钥过期，或者是电脑上的密钥被清理</strong>。（早期github曾使用过短期密钥，因为密钥过期导致无法推送）</p>
<p>随后建立新的密钥：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;you-email@emil.com&quot;</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/lenovo/.ssh/id_rsa):</span><br></pre></td></tr></table></figure>

<p>回车保存在默认路径下，覆盖原有文件。使用下方指令copy密钥值粘贴到github端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>新建密钥之后将ssh连接的端口从默认22修改为不常被拦截的443端口，用记事本或者notepad等打开git安装目录下&#x2F;etc&#x2F;ssh&#x2F;ssh_config文件，在末尾加入：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    Hostname ssh.github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line">    Port 443</span><br></pre></td></tr></table></figure>

<p>重新使用ssh访问github，记得输入yes确认：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>截止到此，ssh访问应该不会出问题了。但是hexo部署仍然有问题，继续查找原因，发现ssh访问没问题的话，<strong>可能出在git端的配置上</strong>。</p>
<p>查找网络资料，发现git可以通过以下两条指令切换https、或者ssh协议：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote set-url origin https://github.com/repo-name/repo-name.github.io.git <span class="comment">##切换https协议</span></span><br><span class="line">$ git remote set-url origin git@github.com:repo-name/repo-name.github.io.git                </span><br></pre></td></tr></table></figure>

<p>类比思考，hexo是将协议集成在了配置文件 <code>_config.yml</code>内，如下方配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:repo-name/repo-name.github.io.git</span> <span class="comment">##更换为ssh推送</span></span><br><span class="line">  <span class="comment">#repo: https://github.com/repo-name/repo-name.github.io.git ##https推送</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<p>因此，将修改repo参数即可修改deploy时的协议，更换为ssh协议后即推送成功。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【1】<a href="https://hexo.io/zh-cn/docs/troubleshooting">故障排除 | Hexo</a></p>
<p>【2】<a href="https://blog.xihann.top/2024/01/21/hexo-d%E6%8A%A5%E9%94%99%E5%8F%8A%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90/">hexo d报错及原因分析 | 惜寒のBlog~</a></p>
<p>【3】<a href="https://www.cnblogs.com/zolich/p/12906838.html#1-%E5%85%88%E7%9C%8B%E7%9C%8B%E6%9C%AC%E5%9C%B0%E6%9C%89%E6%B2%A1%E6%9C%89ssh%E5%AF%86%E9%92%A5">GitHub使用SSH连接以及生成修改添加密钥详细过程 | zolich - 博客园</a></p>
<p>【4】<a href="https://stackoverflow.com/questions/44594353/the-requested-url-returned-error-502-corporate">The requested URL returned error 502, corporate? | Stack overflow</a></p>
<p>【5】<a href="https://blog.csdn.net/2303_79611263/article/details/140346864">解决将Hexo部署到GitHub时报错：Error: Spawn failed_hexo无法部署到github | CSDN博客</a></p>
<p>【6】<a href="https://blog.csdn.net/qq_33316784/article/details/104538400">git相互切换ssh和http协议(一看就懂版)_git 修改 ssh url | CSDN博客</a></p>
<p align="center">---------------------------  End  ---------------------------</p>

<blockquote>
<p><em>寂寞空庭春欲晚，梨花满地不开门。—— 春怨</em></p>
</blockquote>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>502</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA-01-关于ZYNQ</title>
    <url>/2025/04/20/FPGA-01-About_ZYNQ/</url>
    <content><![CDATA[<p>该博文介绍FPGA的相关基础知识，如制造厂商、主要功能等。</p>
<span id="more"></span>

<h2 id="PLD器件"><a href="#PLD器件" class="headerlink" title="PLD器件"></a>PLD器件</h2><p>FPGA: Field Programmable Gate Array，即现场可编程门阵列，属于可编程器件PLD（Programmable Logic Device），类似的有PLA、PAL、CPLD等器件。</p>
<h3 id="PLA与PROM"><a href="#PLA与PROM" class="headerlink" title="PLA与PROM"></a>PLA与PROM</h3><p>PLA与PROM为早期反熔丝型PLD电路。PLA（Programmable Logic array）中通过与门、非门构成“与平面”，“或平面”，以及一次性的编程矩阵。</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="image-20250420205204194.png" alt="image can't load." style="zoom:75%">
    <br>		<!--换行-->
    PLA内部结构	<!--标题-->
    </center>
</div>
可编程只读存储器PROM（Programmable Read-Only Memory）与PLA类似，均是通过“与连接矩阵与“或连接矩阵”组成，**但是PROM的结构上与连接矩阵固定，仅"或矩阵"可进行一次编程**，如下图。

<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="image-20250420210628775.png" alt="image can't load." style="zoom:75%">
    <br>		<!--换行-->
    PROM内部结构	<!--标题-->
    </center>
</div>

<h3 id="PAL与GAL"><a href="#PAL与GAL" class="headerlink" title="PAL与GAL"></a>PAL与GAL</h3><p>在PLA与PROM的基础上又延伸出其他两种类型，即PAL（Programmable Array Logic）和GAL（Generic Array Logic）。</p>
<p>其中PAL相对于PROM结构类似，只是<strong>PAL是仅”与连接矩阵”可编程</strong>，仍然为反熔丝工艺，仅可编程1次。</p>
<p>PAL根据输出电路工作模式可分为三类：</p>
<ul>
<li>三态输出</li>
<li>寄存器输出</li>
<li>互补输出</li>
</ul>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="image-20250420211339732.png" alt="image can't load." style="zoom:75%">
    <br>		<!--换行-->
    PAL内部结构	<!--标题-->
    </center>
</div>

<p>GAL相对于PAL改进：</p>
<ul>
<li>CMOS工艺，电可擦除，可多次编程</li>
<li>可编程的输出逻辑宏单元OLMC（Output Logic Macro Cell）</li>
</ul>
<p>其中OLMC可通过编程控制GAL输出，覆盖PAL的三种模式。</p>
<h3 id="CPLD与FPGA"><a href="#CPLD与FPGA" class="headerlink" title="CPLD与FPGA"></a>CPLD与FPGA</h3><p>复杂可编程逻辑器件CPLD（Complex Programmable Logic Device）可以看作若干PLA与可编程连接矩阵的集合。内部结构如图。</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="image-20250420215617600.png" alt="image can't load." style="zoom:75%">
    <br>		<!--换行-->
    CPLD内部结构	<!--标题-->
    </center>
</div>

<p>FPGA内大量使用LUT查找表和寄存器，可分为SRAM、反熔丝、Flash三种类型，包括可编程的：</p>
<ul>
<li>逻辑块</li>
<li>布线资源</li>
<li>IO口</li>
</ul>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="image-20250420204136714.png" alt="image can't load." style="zoom:75%">
    <br>		<!--换行-->
    FPGA与CPLD对比	<!--标题-->
    </center>
</div>

<p>FPGA的应用场景对比单片机和ARM，主要优势9是灵活高效、高吞吐量、低批量延时、快速并行运算、可重构、可重复编程、可实现定制性能和定制功耗。</p>
<h2 id="ZYNQ"><a href="#ZYNQ" class="headerlink" title="ZYNQ"></a>ZYNQ</h2><p>Xilinx内的ZYNQ系列芯片内包括一块Cortex-A9的硬件ARM处理器，称为为PS。其余的逻辑部分，称为PL，PL上可以使用逻辑块搭载MicroBlaze软核处理器。</p>
<h3 id="PS-端"><a href="#PS-端" class="headerlink" title="PS 端"></a>PS 端</h3><p>ZYNQ内除去ARM外，还包括应用处理单元APU（Application Processing Unit）、扩展外设、cache存储器、存储器接口、互联接口、时钟发生电路。</p>
<h4 id="APU"><a href="#APU" class="headerlink" title="APU"></a>APU</h4><div>
    <center>
        <img src="image-20250425103918783.png" alt="image can't load." style="zoom:75%">
        <br>
    <center>
      APU框架
</center></center></div>

<ul>
<li>双ARM核、NEONTM媒体处理引擎MPE（Media Processing Engine）、浮点计算单元FPU（Floating Point Unit）、内存管理单元MMU（Memory Management Unit）、一级cache存储器（指令+数据）</li>
<li>一致性控制单元SCU（Snoop Control Unit）：ARM与OCM和二级cache之间的连接桥。可用加速一致端口ACP（Accelerator Coherency Port）管理PS与PL的访问</li>
<li>二级cache、片上存储器OCM（On Chip Memory），包括256kB的RAM和128kB的BootRAM。</li>
</ul>
<h4 id="存储器接口"><a href="#存储器接口" class="headerlink" title="存储器接口"></a>存储器接口</h4><p>ZYNQ-7000系列存储器接口包括动态+静态口。</p>
<ul>
<li><p>动态存储器控制器</p>
<ol>
<li>核心存储控制器和调度器DDRC</li>
<li>AXI存储器端口接口DDRI</li>
<li>数字PHY及控制器DDBP，可用于DDR2&#x2F;3、DDR3L、LPDDR2</li>
</ol>
</li>
<li><p>静态存储控制器</p>
<p>SMC（Static Memory Controller），可用作NAND闪存控制器、或并口存储器控制器，支持NAND闪存、NOR闪存、异步SRAM。</p>
</li>
<li><p>QSPI</p>
<p>程序烧录，程序固化。</p>
</li>
</ul>
<h4 id="外部接口"><a href="#外部接口" class="headerlink" title="外部接口"></a>外部接口</h4><p>PS和外部通信主要通过复用的输入&#x2F;输出MIO（Multiplexed Input&#x2F;Output，MIO）实现，直接连接在PS端。但扩展的MIO即EMIO需要通过PL端转接，QSPI、USB、SMC不适用于PL的EMIO接口。</p>
<p>出去4组32位的GPIO外，对外接口还包括各2组：SPI、I2C、CAN、UART、SD、USB、GigE（Ethernet）。</p>
<h3 id="PL端"><a href="#PL端" class="headerlink" title="PL端"></a>PL端</h3><p>Xilinx FPGA芯片的组成部分：可编程输入输出单元IOB、可配置逻辑块CLB、嵌入式块RAM、布线资源、底层内嵌功能单元、底层内嵌专用硬核等。</p>
<h4 id="IOB"><a href="#IOB" class="headerlink" title="IOB"></a>IOB</h4><p>需要注意，FPGA每个Bank的VCC电压不同，一个Bank仅有一个电压。</p>
<p>I&#x2F;O组被分类为高性能HP（High Performance）和高范围HR（High Range）。</p>
<ul>
<li>HP：VCC为1.8V，常作连接存储器和其他芯片的高速接口</li>
<li>HR：VCC为3.3V，适合各种IO标准</li>
</ul>
<p>HP与HR均支持单端、差分输入，具体可以查阅引脚说明。</p>
<p><strong>每个IOB包括IOSERDER，可作串转并或并转串。</strong></p>
<h4 id="CLB"><a href="#CLB" class="headerlink" title="CLB"></a>CLB</h4><p>CLB指可编程逻辑块，逻辑单元最小规模。Slice片是CLB的子单元。</p>
<p><strong>ZYNQ的片是由4个查找表（LUT）+8触发前+其他逻辑组成的。</strong></p>
<h4 id="BRAM"><a href="#BRAM" class="headerlink" title="BRAM"></a>BRAM</h4><p>嵌入式块RAM，用于生成RAM、ROM、FIFO及移位寄存器等常用的存储模块。</p>
<p>ZYNQ的BRAM由60个存储块组成：</p>
<ul>
<li>每个块RAM由2个18kB的BRAM组成；</li>
<li>以块为单位使用；</li>
<li>3类分组，即BRAM（36kB）；BRAM（18kB）+BRAM（18kB），BRAM+FIFO。由于仅包括1个FIFO Logic，只能生成一组FIFO控制信号。</li>
</ul>
<p><strong>使用块RAM即在片内用小物理空间存储大量数据</strong>。</p>
<h4 id="硬核"><a href="#硬核" class="headerlink" title="硬核"></a>硬核</h4><p>ZYNQPL端内嵌XADC，即两个模数转换器。且有接口可以连接至PS端。</p>
<p align="center">---------------------------  End  ---------------------------</p>

<blockquote>
<p><em>大梦谁先觉，平生我自知。–《三国演义》</em></p>
</blockquote>
]]></content>
      <categories>
        <category>FPGA</category>
        <category>ZYNQ</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>ZYNQ</tag>
      </tags>
  </entry>
  <entry>
    <title>SpaceDesk-Win与iPad有线扩展</title>
    <url>/2025/04/19/SpaceDesk-Secondary_Screen/</url>
    <content><![CDATA[<p>Win与平板在同一无线网络下，很容易实现无线连接，但无线延迟较高、设备易发热。有线连接延迟低、帧率高，这篇博客可以让闲置的iPad来跳“最后一舞”，前提是有一个正在吃灰的iPad…</p>
<span id="more"></span>

<h2 id="设备说明"><a href="#设备说明" class="headerlink" title="设备说明"></a>设备说明</h2><ul>
<li>Windows 11,	Type-C</li>
<li>iPad Air4，	Type-C</li>
<li>iPad原装双端Type-C数据线</li>
</ul>
<h2 id="软件说明"><a href="#软件说明" class="headerlink" title="软件说明"></a>软件说明</h2><h3 id="Win端"><a href="#Win端" class="headerlink" title="Win端"></a>Win端</h3><ol>
<li><p>下载安装SpaceDesk</p>
<p>SpaceDesk官网：<a href="https://www.spacedesk.net/download/#server-driver">最新版本 点击下载</a></p>
<p>百度网盘：<a href="https://pan.baidu.com/s/18-q_8Ee8a7pfuRcNfBlofw?pwd=8eis">v2.1.15 点击下载</a></p>
</li>
<li><p>下载安装iTunes</p>
<p>打开Win自带的微软商店，搜索下载。</p>
<div>            <!--块级封装-->
 <center>    <!--将图片和文字居中-->
    <img src="image-20250419103753851.png" alt="image can't load." style="zoom:75%">
    <br>        <!--换行-->
    Microsoft Store    <!--标题-->
    </center>
</div>

<p>疑似v2.1.15 版本的SpaceDesk不具备iPad连接的驱动，需要使用iTunes连接1次，后续就不再使用。</p>
</li>
</ol>
<h3 id="iPad-端"><a href="#iPad-端" class="headerlink" title="iPad 端"></a>iPad 端</h3><p>App Store 搜索spacedesk下载。</p>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="image-20250419104020718.png" alt="image can't load." style="zoom:50%">
    <br>		<!--换行-->
    App Store	<!--标题-->
    </center>
</div>

<p>安装完成后打开软件，设置最高画质、自动旋转、自动改变IP等，iPad端无需其他操作。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="黑白显示"><a href="#黑白显示" class="headerlink" title="黑白显示"></a>黑白显示</h3><p>原因：SpaceDesk并非是最新版本。下载官网最新版本。</p>
<h3 id="连接Type-c无反应"><a href="#连接Type-c无反应" class="headerlink" title="连接Type-c无反应"></a>连接Type-c无反应</h3><p>原因：汉化包Bug。</p>
<p>打开安装包，Remove当前安装版本，重新安装，不要打汉化</p>
<h3 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h3><p>【1】<a href="https://blog.csdn.net/qq_42013947/article/details/136596644?ops_request_misc=&request_id=&biz_id=102&utm_term=LXHYouth&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-136596644.142%5Ev102%5Epc_search_result_base6&spm=1018.2226.3001.4187">LXHYouth|使用SpaceDesk实现iPad成为电脑拓展屏(保姆级教程)-CSDN博客</a></p>
<p>【2】<a href="https://www.bilibili.com/video/BV1NQ4y1A7PD/?share_source=copy_web&vd_source=793e603d878f9531350764468aa132ce">我想当饼藏|ipad作为副屏与Windows电脑有线连接-哔哩哔哩</a></p>
<p>【3】<a href="https://www.bilibili.com/opus/912838630992510994?spm_id_from=333.1387.0.0">咸鱼羊同学|Windows与iPad有线副屏SpaceDesk扩展与常见问题 - 哔哩哔哩</a></p>
<p align="center">---------------------------  End  ---------------------------</p>

<blockquote>
<p><em>他山之石，可以攻玉。–《诗·小雅·鹤鸣》</em></p>
</blockquote>
]]></content>
      <categories>
        <category>Tools</category>
        <category>SpaceDesk</category>
      </categories>
      <tags>
        <tag>Ex-Screen</tag>
        <tag>Wired</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-01-博客搭建问题与解决办法</title>
    <url>/2025/04/09/Hexo-01-Build_Blog/</url>
    <content><![CDATA[<p>该博客主要介绍使用Hexo工具在Github上搭建Next主题个人博客的简要过程，列举所参考的视频与帖子连接，同时汇总个人搭建过程中遇到的各种错误和解决办法。</p>
<span id="more"></span>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>博客搭建所使用的部件如下：</p>
<ul>
<li>Github：用于博客线上浏览</li>
<li>Git: 线上推送工具</li>
<li>Hexo：用于管理本地博客内容、主题与线上推送</li>
<li>Sublime Text：用于管理博客文件夹，无需来回跳转</li>
</ul>
<p>博客搭建所用的参考视频为：</p>
<p>【1】<a href="https://www.bilibili.com/video/BV1cW411A7Jx/?spm_id_from=333.337.top_right_bar_window_history.content.click&vd_source=5465b0f4790ebae45362caa6519f3b79">hojun_cn|手把手教你搭建属于自己的hexo+github博客-BiliBili</a></p>
<p>博客美化参考的教程如下：</p>
<p>【1】<a href="https://hexo-next.readthedocs.io/zh-cn/latest/">Hexo-NexT</a></p>
<p>【2】<a href="https://vic.kim/2019/05/25/Hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E4%B9%8BNext%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/">Hexo博客优化之Next主题美化 | Vicの博客</a></p>
<p>【3】<a href="https://xiamu-ssr.github.io/Hexo/2024/06/19/2024-H1/2024-06-19-12-31-52/">如何优雅的使用Github Action服务来将Hexo部署到Github Pages - Hexo</a></p>
<p>【4】<a href="https://github.com/theme-next/theme-next-canvas-nest/blob/master/README.md">Hexo v7.0+的canvas-nest插件配置-Github</a></p>
<p>【5.1】<a href="https://blog.csdn.net/Aoman_Hao/article/details/89416634">Hexo博客Next主题建立标签云-CSDN博客</a></p>
<p>【5.2】<a href="https://github.com/D0n9X1n/hexo-tag-cloud/blob/master/README.ZH.md">Hexo的hexo-tag-cloud插件使用手册-Github</a></p>
<p>【6】<a href="https://blog.csdn.net/kantaiyang/article/details/129159055">Hexo无法显示本地图片的问题-CSDN博客</a></p>
<p>【7】<a href="https://tanwucheng.github.io/2021/03/03/4.Hexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AERSS%E8%AE%A2%E9%98%85/">HEXO笔记④-Hexo博客NexT主题设置RSS订阅 | Ten’s Blog</a></p>
<p>【8.1】[hexo 的 Next 主题 中添加首页文章置顶功能及置顶图标 | ShallWe - 官方博客](<a href="https://blog.mrshallwe.com/2022/03/16/hexo">https://blog.mrshallwe.com/2022/03/16/hexo</a> 的 Next 主题 中添加首页文章置顶功能及置顶图标&#x2F;)</p>
<p>【8.2】<a href="https://blog.csdn.net/qq_41603102/article/details/117203360">Hexo+Next8的升级踩坑之旅_next 8 config-CSDN博客</a></p>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><p>Hexo创建本地博客仓库后，使用<strong>控制台</strong>或<strong>Git Bash Here</strong>输入指令进行博文管理，详见<a href="https://hexo.io/zh-cn/docs/commands">指令 | Hexo</a>，以下简要介绍常用指令</p>
<ol>
<li><p>网站生成–生成本地网站</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
</li>
<li><p>网站推送–推送至github</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建本地端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s -p 5555</span><br></pre></td></tr></table></figure>

<p>该指令将创建本地5555端口，可在浏览器中输入<code>localhost:5555</code>进行查看，但并未推送至线上。</p>
</li>
</ol>
<h2 id="问题与解决办法"><a href="#问题与解决办法" class="headerlink" title="问题与解决办法"></a>问题与解决办法</h2><p>虽然有视频参考，但作者在使用时仍然出现一些问题，在此记录，帮助后人乘凉。</p>
<h3 id="插件版本"><a href="#插件版本" class="headerlink" title="插件版本"></a>插件版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo: 7.3.0</span><br><span class="line">node: 22.14.0</span><br><span class="line">next: 8.23.0</span><br></pre></td></tr></table></figure>

<h3 id="本地仓库初始化失败"><a href="#本地仓库初始化失败" class="headerlink" title="本地仓库初始化失败"></a>本地仓库初始化失败</h3><p><strong>原因1：在Github创建仓库时的仓库名与本地仓库名不一致。</strong></p>
<p>举个栗子：作者在Github的仓库名为<code>AAA</code>，那么使用<code>hexo init AAA</code>指令时的本地仓库路径应该为<code>C:\Blog</code>，文件夹名称为<code>AAA</code>。</p>
<p><strong>原因2：无法在某个硬盘的根目录下创建仓库。例如在<code>C:</code>文件夹下初始化将失败。</strong></p>
<p>举个栗子：在本地文件夹下应该创建子文件夹，如<code>C:\Blog</code>或者你喜欢的其他名称。</p>
<p><strong>原因3：SSL证书报错，如下。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init AAA</span><br><span class="line">INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git</span><br><span class="line">fatal: unable to access <span class="string">&#x27;https://github.com/hexojs/hexo-starter.git/&#x27;</span>: SSL certificate problem: unable to get <span class="built_in">local</span> issuer certificate</span><br><span class="line">WARN  git <span class="built_in">clone</span> failed. Copying data instead</span><br><span class="line">INFO  Install dependencies</span><br><span class="line">INFO  Start blogging with Hexo!</span><br></pre></td></tr></table></figure>

<p>解决办法：首先下载最新版本Git，某些旧版本可能会失败。其次，Git在下载后默认为Linux终端加密，使用以下指令修改配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global http.sslbackend schannel</span><br></pre></td></tr></table></figure>

<p><span style="color:red"><strong>不建议使用以下指令：该指令关闭安全检查，可能会受到外部攻击。</strong></span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global http.sslVerify <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<h3 id="更改主题后生成时报错"><a href="#更改主题后生成时报错" class="headerlink" title="更改主题后生成时报错"></a>更改主题后生成时报错</h3><p>此时进行本地查看，网页端将显示空白界面。生成阶段的报错信息如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">WARN  No layout: 2025/04/09/hello-world/index.html</span><br><span class="line">WARN  No layout: archives/index.html</span><br><span class="line">WARN  No layout: archives/2025/index.html</span><br><span class="line">WARN  No layout: archives/2025/04/index.html</span><br><span class="line">WARN  No layout: index.html</span><br></pre></td></tr></table></figure>

<p>原因1：主题包名称与<code>_config.yml</code>中不一致，检查文件名。</p>
<p>举个例子：作者使用<code>next</code>主题，在github上下载的主题包名称为<code>xxxx_next_xxx</code>形式。将主题包与<code>_config.yml</code>中修改为<code>next</code>或其他相同的名称即可。</p>
<p>原因2：原有缓存内容未更新。使用以下指令重新生成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g</span><br></pre></td></tr></table></figure>

<h3 id="无法推送至Github仓库"><a href="#无法推送至Github仓库" class="headerlink" title="无法推送至Github仓库"></a>无法推送至Github仓库</h3><p>原因1：仓库分支名有误。Github默认仓库名曾由<code>master</code>修改为<code>mian</code>， 但Hexo默认分支为<code>master</code>。</p>
<p>解决办法：在<code>_config.yml</code>内找到<code>branch </code>分支，并修改为<code>main</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">	<span class="string">type:git</span></span><br><span class="line">	<span class="string">repo:xxx</span> <span class="comment">#你的Github仓库</span></span><br><span class="line">	<span class="string">branch：main</span></span><br></pre></td></tr></table></figure>

<h3 id="新增侧边栏项目后出错"><a href="#新增侧边栏项目后出错" class="headerlink" title="新增侧边栏项目后出错"></a>新增侧边栏项目后出错</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">YAMLException: can not <span class="built_in">read</span> a block mapping entry; a multiline key may not be an implicit key (4:1)</span><br></pre></td></tr></table></figure>

<p>原因1：文件的<code>front-matter</code>内存在中英文字符混用。</p>
<p>解决办法：使用英文字符，并且后跟空格。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: 关于</span><br><span class="line"><span class="built_in">date</span>: 2025-04-16 13:20:26</span><br><span class="line">tags: about</span><br></pre></td></tr></table></figure>

<h3 id="创建新标签后访问错误"><a href="#创建新标签后访问错误" class="headerlink" title="创建新标签后访问错误"></a>创建新标签后访问错误</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Cannot GET /about/</span><br></pre></td></tr></table></figure>

<p>原因1：可能并未创建对应的文件夹，或者文件名称有误。</p>
<p>解决办法：new page创建新文件夹，文件夹内的文件名<strong>必须为<code>index.md</code></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page about</span><br></pre></td></tr></table></figure>

<p>并且注意，此时需要更改内部的tags，比如</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: 关于</span><br><span class="line"><span class="built_in">date</span>: 2025-04-16 13:20:26</span><br><span class="line">tags: about</span><br></pre></td></tr></table></figure>

<h3 id="自定义图标不显示"><a href="#自定义图标不显示" class="headerlink" title="自定义图标不显示"></a>自定义图标不显示</h3><p>网络上大多数是旧版本Hexo 或者Next主题的配置方案，按照他们的步骤可能找不到相同的文件 …   如本节内4篇博客方案，均无法复刻。</p>
<p>【1】<a href="https://blog.csdn.net/weixin_44634406/article/details/122777058">hexo next 解决自定义侧边栏用户社交链接小图标 custom sidebar social icon_next自定义图标-CSDN博客</a></p>
<p>【2】<a href="https://ouyen.github.io/hexo-icon/">给hexo next扩展图标 | 纯白的小站</a></p>
<p>【3】<a href="https://lockrim.top/2023/03/29/Next%E4%B8%BB%E9%A2%98fa%E5%9B%BE%E6%A0%87%E9%97%AE%E9%A2%98/">Next主题fa图标问题 | LockRim·小站</a></p>
<p>【4】<a href="https://yelog.org/2020/12/28/3-hexo-add-icon/">3-hexo添加自定义图标 | 叶落阁</a></p>
<p>原因：参照<a href="https://lockrim.top/2023/03/29/Next%E4%B8%BB%E9%A2%98fa%E5%9B%BE%E6%A0%87%E9%97%AE%E9%A2%98/">博客3</a>发现可能涉及到不同版本Font Awesome(简称fa)图标库，V5和V6涵盖的图标数不同。其他图标可在<a href="https://www.iconfont.cn/?spm=a313x.search_index.i3.2.7d813a81xrirca">iconfont图标库</a>下载。</p>
<p>解决办法：next v8.23.0版本<code>_config.yml</code>文件注释表明其已集成fa库，在<a href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">链接6</a>中搜索图标名，如<code>bilibili</code>。如果有结果，则可在Next主题配置文件中使用<code>fab fa-bilibili</code>，在<code>.md</code>文档内中按如下格式使用：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fa-brands fa-bilibili&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fa-brands fa-bilibili&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;font-size:20px&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fa-brands fa-bilibili&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;font-size:36px;color:red&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&#x27;custom-button&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fa-brands fa-bilibili&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> <span class="language-xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><i class="fa-brands fa-bilibili"></i><br><i class="fa-brands fa-bilibili" style="font-size:20px"></i><br><i class="fa-brands fa-bilibili" style="font-size:36px;color:red"></i><br><button class="custom-button"><i class="fa-brands fa-bilibili"></i> </button></p>
<p>但该版本Next主题中，即使从<a href="https://www.iconfont.cn/?spm=a313x.search_index.i3.2.7d813a81xrirca">iconfont</a>下载图标代码也难以插入到本地<code>  .css</code>或者<code>.styl</code>文件。</p>
<p>【5】<a href="https://www.iconfont.cn/?spm=a313x.search_index.i3.2.7d813a81xrirca">iconfont-阿里巴巴矢量图标库</a></p>
<p>【6】<a href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;font-awesome&#x2F;6.4.0&#x2F;css&#x2F;all.min.css</a></p>
<p>【7】<a href="https://fontawesomeicons.com/tryit/fa/v6/bilibili">fa-brands fa-bilibili — Tryit Editor</a></p>
<h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><h3 id="博客分类"><a href="#博客分类" class="headerlink" title="博客分类"></a>博客分类</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure>

<p>此时这篇文章同时包括三个分类： <code>PlayStation</code> 和 <code>Games</code> 分别都是父分类 <code>Diary</code> 的子分类，同时 <code>Life</code> 是一个没有子分类的分类。</p>
<h3 id="修改分类间隔符"><a href="#修改分类间隔符" class="headerlink" title="修改分类间隔符"></a>修改分类间隔符</h3><p>如果希望保留多语言支持，可以修改翻译文件中的 <code>symbol.comma</code> 定义：</p>
<ol>
<li><p>找到主题的语言文件（如中文）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">themes/next/languages/zh-CN.yml</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 <code>symbol.comma</code> 的值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">symbol:</span><br><span class="line">  comma: <span class="string">&quot; / &quot;</span>  <span class="comment"># 将逗号改为斜杠</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p align="center">---------------------------  End  ---------------------------</p>

<blockquote>
<p><em>且视他人之疑目如盏盏鬼火，大胆地去走你的夜路。–史铁生 《病隙随笔》</em></p>
</blockquote>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Next</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
