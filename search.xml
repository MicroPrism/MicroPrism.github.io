<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>博客食用指南</title>
    <url>/2025/04/08/Blog_Using_Guide/</url>
    <content><![CDATA[<p>本博文按照类别列举所有已经上传的博客，可能会对某些博文简要介绍，方便其他网友查阅（<del>如果有的话</del>）。</p>
<span id="more"></span>
<p align="center">
————————— Part 1 —————————
</p>
<h1 id="电子类">电子类</h1>
<h2 id="altium">Altium</h2>
<ol type="1">
<li>empty.</li>
<li><a href="https://microprism.github.io/2025/07/18/Altium-02-Error_And_Solution/">Altium-02-异常与解决办法</a></li>
</ol>
<h2 id="si">SI</h2>
<ol type="1">
<li><a href="https://microprism.github.io/2025/07/09/SI-01-Impedance/">SI-01-PCB特性阻抗</a></li>
</ol>
<h2 id="zynq">ZYNQ</h2>
<ol type="1">
<li><a href="https://microprism.github.io/2025/07/19/ZYNQ-01-ZYNQ_TCP_Demo_Error/">ZYNQ-01-ZYNQ7020
TCP例程自动协商失败解决办法</a></li>
</ol>
<h2 id="fpga">FPGA</h2>
<ol type="1">
<li><a href="https://microprism.github.io/2025/04/20/FPGA-01-About_ZYNQ/">FPGA-01-关于ZYNQ</a></li>
<li><a href="https://microprism.github.io/2025/05/29/FPGA-02-Verilog_Syntax/">FPGA-02-Verilog语法</a></li>
<li><a href="https://microprism.github.io/2025/11/24/FPGA-03-Verilog_Syntax/">FPGA-03-Verilog语法</a></li>
<li><a href="https://microprism.github.io/2025/12/01/FPGA-04-Verilog_Syntax/">FPGA-04-Verilog语法</a></li>
</ol>
<p align="center">
————————— Part 2 —————————
</p>
<h1 id="协议类">协议类</h1>
<ol type="1">
<li><a href="https://microprism.github.io/2025/07/19/TCP-Protocol/">TCP/IP-协议详解</a></li>
</ol>
<p align="center">
————————— Part 3 —————————
</p>
<h1 id="计算机类">计算机类</h1>
<ol type="1">
<li><a href="https://www.bilibili.com/video/BV1tNpbekEht/?spm_id_from=333.337.search-card.all.click&amp;vd_source=5465b0f4790ebae45362caa6519f3b79">《数据结构（C
语言描述）》</a></li>
<li><a href="https://space.bilibili.com/517494241?spm_id_from=333.337.0.0">董晓算法的个人空间-董晓算法个人主页-哔哩哔哩视频</a></li>
</ol>
<h2 id="数据结构">数据结构</h2>
<ol type="1">
<li><a href="https://microprism.github.io/2025/08/09/DS-01-Introduction/">数据结构-01-引言</a></li>
<li><a href="https://microprism.github.io/2025/08/10/DS-02-Linear_List/">数据结构-02-线性表</a></li>
<li><a href="https://microprism.github.io/2025/09/15/DS-03-Stack_and_Queue/">数据结构-03-栈与队列</a></li>
</ol>
<p align="center">
————————— Part 4 —————————
</p>
<h1 id="leetcode">LeetCode</h1>
<h2 id="c算法">C算法</h2>
<ol type="1">
<li><a href="https://microprism.github.io/2025/07/19/LeetCode-01-String_Composition/">LeetCode-01-字符串交叉拼接</a></li>
<li><a href="https://microprism.github.io/2025/07/19/LeetCode-02-GCD_Of_String/">LeetCode-02-两字符串寻找最大公因子</a></li>
<li><a href="https://microprism.github.io/2025/07/24/LeetCode-03-Kids_With_Candies">LeetCode-03-寻找糖果数最多的孩子</a></li>
<li><a href="https://microprism.github.io/2025/07/24/LeetCode-04-Can_Place_Flowers/">LeetCode-04-种花问题</a></li>
<li><a href="https://microprism.github.io/2025/08/02/LeetCode-05-Reverse_Vowels/">LeetCode-05-字符串中元音字符翻转</a></li>
<li><a href="https://microprism.github.io/2025/08/03/LeetCode-06-Reverse_Words/">LeetCode-06-字符串中单词顺序反转</a></li>
<li><a href="https://microprism.github.io/2025/08/07/LeetCode-07-Product_ExceptSelf/">LeetCode-07-元素之积</a></li>
<li><a href="https://microprism.github.io/2025/08/09/LeetCode-08-Increasing_Triplet/#more">LeetCode-08-三元递增子序列</a></li>
</ol>
<p align="center">
————————— Part 5 —————————
</p>
<h1 id="工具类">工具类</h1>
<ol type="1">
<li><a href="https://microprism.github.io/2025/04/09/Hexo-Build_Blog/">Hexo-博客搭建</a></li>
<li><a href="https://microprism.github.io/2025/06/17/Git-Using_Guide/">Git-使用指南</a></li>
<li><a href="https://microprism.github.io/2025/04/19/SpaceDesk-Secondary_Screen/">SpaceDesk-Win与iPad有线副屏扩展与常见问题</a></li>
</ol>
<p align="center">
————————— Part 6 —————————
</p>
<h1 id="见闻类">见闻类</h1>
<ol type="1">
<li><a href="https://microprism.github.io/2025/06/02/NCU-873_Trends/">南昌大学-873控制工程考研形势</a></li>
<li><a href="https://microprism.github.io/2025/06/10/Sideline-SIM_Card/">流量卡-性价比推荐</a></li>
</ol>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p>前人栽树，后人乘凉。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>FPGA-04-Verilog语法</title>
    <url>/2025/12/01/FPGA-04-Verilog_Syntax/</url>
    <content><![CDATA[<p>本文记录Verilog计数器、按键消抖、流水灯以及状态机设计思路。博文尾部为参考自顶向下设计思路的简单状态机模块设计。</p>
<span id="more"></span>
<h1 id="计数器">计数器</h1>
<p>计数器是FPGA中常用的单位，例如希望a状态持续X时间，b状态持续Y时间。在时钟做时间源的情况下，通过累计时钟计数得出较大打秒级、分钟级单位，得出flag标志可用到各个模块的判断语句中。</p>
<p>假设有sys_clk =
F，则单个周期T=1/F，A秒钟的计数器所需的计数值为M=A/T=AF。</p>
<ul>
<li>为节省资源，考虑找到所有时间值的最小公倍数</li>
<li>单个always块仅操作单个变量</li>
<li>提前1拍，打出flag信号，可用于所有变量</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需求：led 0.5s亮，1.5s灭</span></span><br><span class="line"><span class="keyword">module</span> Counter(</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	sys_clk,</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	sys_rst_n,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">reg</span>		led_out</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span>	CNT_MAX	= <span class="number">25&#x27;d24_999_999</span>;	<span class="comment">//计数值为0.5s</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">24</span>:<span class="number">0</span>]	cnt;		<span class="comment">//计数器-0.5s</span></span><br><span class="line"><span class="comment">//reg			cnt_flag;	//到达0.5s标志</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>]	half_s_cnt;	<span class="comment">//0.5s个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计数块</span></span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line"><span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">	cnt &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cnt == CNT_MAX)</span><br><span class="line">	cnt &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算第几个0.5s，用于做不同时长闪烁</span></span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line"><span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">	half_s_cnt &lt;= <span class="number">2&#x27;d0</span>;		<span class="comment">//或者此处复位设置为3</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cnt == CNT_MAX - <span class="number">1</span>)</span><br><span class="line">	half_s_cnt &lt;= half_s_cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	half_s_cnt &lt;= half_s_cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//led控制块</span></span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line"><span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">	led_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(half_s_cnt == <span class="number">2&#x27;d0</span>)		</span><br><span class="line"><span class="comment">//放在首个亮时，由于half_s_cnt复位后为0，与cnt同一拍开始计数，所以上电后第一个亮会为480ms</span></span><br><span class="line"><span class="comment">//因此，可将亮起的位置放在后侧</span></span><br><span class="line">	led_out &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	led_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//parameter	CNT_MAX	=	25&#x27;d24_999_999;	//50MHz Clock,计数0.5s</span></span><br><span class="line">	<span class="comment">//localparam	CNT_MAX =	25&#x27;d24_999_999;		//局部参数，实例化时不可从外部使用</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div>
<center>
<img src="image-20251201233903055.png" alt="image can't load." style="zoom:75%"> <br> half_s_cnt == 2’d0 复位后首次丢失一拍
</center>
</div>
<div>
<center>
<img src="image-20251201234332654.png" alt="image can't load." style="zoom:75%"> <br> half_s_cnt == 2’d3，复位后时间正常
</center>
</div>
<p><strong>两张图的差异在于，led_out默认输出与第一次状态不同。对第一张图，在rst
= 1后，cnt和led同时翻转，因此出现一拍丢失。若希望使用half_s_cnt ==
2’d0，而不出现丢拍，则需要把复位后的led状态拉高。</strong></p>
<h1 id="分频器">分频器</h1>
<p>Vivado自带的IP核为锁相环，通过PLL由一个输入时钟得到多个不同频率的子时钟。分频器细分为奇分频与偶分频。分频器本质与计数器相同，即计数到某一值输出翻转或输出Flag标志。</p>
<h2 id="偶分频">偶分频</h2>
<p>偶分频可以sys_clk上升沿为为基准，计数刚好对应的分频系数的一半时，对信号翻转。</p>
<div>
<center>
<img src="image-20251208213722376.png" alt="image can't load." style="zoom:50%"> <br> 偶分频(双边沿输出flag标志)
</center>
</div>
<p>若为低频时钟，则可直接对信号翻转：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本模块通过输出不同参数来调用奇分频或偶分频函数</span></span><br><span class="line"><span class="comment">//暂时实现偶分频模块</span></span><br><span class="line"><span class="keyword">module</span> uPLL(</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	sys_clk,</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	sys_rst_n,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">reg</span>		clk_out,</span><br><span class="line">	<span class="keyword">output</span>  <span class="keyword">reg</span>		stat_flag </span><br><span class="line">    );</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">parameter</span>		DIVIDER	=	<span class="number">4&#x27;d6</span>;</span><br><span class="line">	<span class="comment">//-------------------局部配置参数-------------------</span></span><br><span class="line">	<span class="keyword">localparam</span>		DIV_IDX =	(DIVIDER &gt;	<span class="number">15</span> || DIVIDER &lt; <span class="number">2</span>)?</span><br><span class="line">								(DIVIDER &gt; 	<span class="number">15</span>)?<span class="number">14</span>:</span><br><span class="line">								(DIVIDER &lt;= <span class="number">1</span>)?<span class="number">2</span>:</span><br><span class="line">								DIVIDER:</span><br><span class="line">								DIVIDER;												  </span><br><span class="line">	<span class="keyword">localparam</span>		DIV_MAX	=	<span class="number">4&#x27;d15</span>;</span><br><span class="line">	<span class="keyword">localparam</span>		DIV_MIN	=	<span class="number">4&#x27;d2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//-------------------分频计数器-------------------	</span></span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]	clk_cnt;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//-------------------分频器状态-------------------</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		stat_flag	&lt;=	<span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(DIVIDER &gt; DIV_MAX || DIVIDER	&lt; 	DIV_MIN)</span><br><span class="line">		stat_flag	&lt;=  <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		stat_flag	&lt;=	<span class="number">1&#x27;b1</span>;	</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//-------------------计数器-------------------</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		clk_cnt &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(clk_cnt == DIV_IDX/<span class="number">2</span>-<span class="number">1</span>)</span><br><span class="line">		clk_cnt	&lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		clk_cnt &lt;= clk_cnt + <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//-------------------时钟输出-------------------	</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		clk_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(clk_cnt == DIV_IDX/<span class="number">2</span>-<span class="number">1</span>)</span><br><span class="line">		clk_out &lt;= ~clk_out;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		clk_out	&lt;= clk_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>以此生成的clk：</p>
<ul>
<li><p>可直接在后续alway块中做参考</p>
<p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] a;</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_out <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">    <span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">        a &lt;= <span class="number">2&#x27;d0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        a &lt;= a + <span class="number">1&#x27;b1</span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>不属于FPGA全局时钟，高速时钟下不精确</p></li>
</ul>
<p>为解决高速时钟下不精确问题，将clk_out作为输出标识配合同步时钟，思路同<a href="#计数器">计数器</a>。将上方代码块的clk_out代码更换为以下代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line"><span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">	clk_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(clk_cnt == DIV_IDX/<span class="number">2</span>-<span class="number">2</span>)</span><br><span class="line">	clk_out	&lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	clk_out &lt;= <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure>
<p>仿真结果如下：</p>
<div>
<center>
<img src="image-20251208215700771.png" alt="image can't load." style="zoom:50%"> <br> 偶分频仿真结果
</center>
</div>
<p>产生flag标识后可以配合sys_clk使用：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] a;</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">posedge</span> sys_rst_n)</span><br><span class="line"><span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">    	a	&lt;= <span class="number">2&#x27;b0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(flag)	<span class="comment">//--- a在新时钟的上升沿下降沿均加1</span></span><br><span class="line">    	a	&lt;= a + <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    	a 	&lt;= a;</span><br></pre></td></tr></table></figure>
<p>上方的flag == 1
时代表分频后时钟的边沿（上升沿+下降沿），<strong>调整计数清零时的值可调整为单边沿或双边沿</strong>：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//偶分频模块</span></span><br><span class="line"><span class="comment">//采用flag信号</span></span><br><span class="line"><span class="keyword">module</span> eveDivider(	</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>			sys_clk,</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>			sys_rst_n,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">reg</span>				clk_out,</span><br><span class="line">	<span class="keyword">output</span>  <span class="keyword">reg</span>				clk_flag </span><br><span class="line">    );</span><br><span class="line"><span class="comment">//-------------------全局配置参数-------------------</span></span><br><span class="line">	<span class="keyword">parameter</span>		DIVIDER			=	<span class="number">32&#x27;d6</span>;</span><br><span class="line">	<span class="keyword">parameter</span>		CLK_EDGE_SEL 	= 	<span class="number">1&#x27;b0</span>;	<span class="comment">//输出边沿选择	</span></span><br><span class="line"><span class="comment">//-------------------局部配置参数-------------------	</span></span><br><span class="line">    <span class="keyword">localparam</span>		DIV_IDX =	(CLK_EDGE_SEL == <span class="number">1&#x27;b0</span>)? DIVIDER -<span class="number">1</span> 	:		<span class="comment">//单边沿flag</span></span><br><span class="line">														DIVIDER/<span class="number">2</span> -<span class="number">1</span>	;	<span class="comment">//双边沿flag</span></span><br><span class="line"><span class="comment">//-------------------分频计数器-------------------	</span></span><br><span class="line">	<span class="keyword">reg</span>		[<span class="number">31</span>:<span class="number">0</span>]	clk_cnt;	</span><br><span class="line"><span class="comment">//-------------------边沿计数器-------------------	</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(sys_rst_n == <span class="number">1&#x27;b0</span>)</span><br><span class="line">		clk_cnt &lt;= <span class="number">32&#x27;d0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(clk_cnt == DIV_IDX)</span><br><span class="line">		clk_cnt	&lt;= <span class="number">32&#x27;d0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		clk_cnt	&lt;= clk_cnt + <span class="number">1&#x27;d1</span>;		</span><br><span class="line"><span class="comment">//-------------------输出时钟-------------------	</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(sys_rst_n == <span class="number">1&#x27;b0</span>)</span><br><span class="line">		clk_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(clk_cnt == DIVIDER/<span class="number">2</span>-<span class="number">1</span> || clk_cnt == DIVIDER-<span class="number">1</span>)</span><br><span class="line">		clk_out	&lt;= ~clk_out;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		clk_out	&lt;= clk_out;		</span><br><span class="line"><span class="comment">//-------------------标志位输出-------------------	</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(sys_rst_n == <span class="number">1&#x27;b0</span>)		</span><br><span class="line">		clk_flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(clk_cnt == DIV_IDX - <span class="number">1</span>)</span><br><span class="line">		clk_flag &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		clk_flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<div>
<center>
<img src="image-20251209225702076.png" alt="image can't load." style="zoom:50%"> <br> 偶分频(双边沿标志)仿真结果
</center>
</div>
<h2 id="奇分频">奇分频</h2>
<p>偶分频因为分频系数为偶数，最小为二分频，恰好对齐ys_clk上升沿(本节末尾放置使用下降沿的通用分频器)。若对时钟进行奇分频，欲求找到系数一半m/2-1的上升沿是不可能的，但是可引入下降沿为标准，波形如下：</p>
<div>
<center>
<img src="image-20251208221814413.png" alt="image can't load." style="zoom:50%"> <br> 奇分频波形
</center>
</div>
<p>因此，代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> uPLL(</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	sys_clk,</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	sys_rst_n,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">reg</span>		clk_out,</span><br><span class="line">	<span class="keyword">output</span>  <span class="keyword">reg</span>		stat_flag </span><br><span class="line">    );</span><br><span class="line">	<span class="keyword">parameter</span>		DIVIDER	=	<span class="number">4&#x27;d6</span>;</span><br><span class="line">	<span class="comment">//-------------------局部配置参数-------------------</span></span><br><span class="line">	<span class="keyword">localparam</span>		DIV_IDX =	(DIVIDER &gt;	<span class="number">15</span> || DIVIDER &lt; <span class="number">2</span>)?</span><br><span class="line">								(DIVIDER &gt; 	<span class="number">15</span>)?<span class="number">14</span>:</span><br><span class="line">								(DIVIDER &lt;= <span class="number">1</span>)?<span class="number">2</span>:</span><br><span class="line">								DIVIDER:</span><br><span class="line">								DIVIDER;												  </span><br><span class="line">	<span class="keyword">localparam</span>		DIV_MAX	=	<span class="number">4&#x27;d15</span>;</span><br><span class="line">	<span class="keyword">localparam</span>		DIV_MIN	=	<span class="number">4&#x27;d2</span>;</span><br><span class="line">	<span class="comment">//-------------------分频计数器-------------------	</span></span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]	clk_cnt;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//-------------------边沿计数器-------------------</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		clk_cnt &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(clk_cnt == DIV_IDX-<span class="number">1</span>)</span><br><span class="line">		clk_cnt &lt;= <span class="number">4&#x27;b0</span> ;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		clk_cnt &lt;= clk_cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="comment">//-------------------异常状态指示-------------------</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		stat_flag	&lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(DIVIDER &gt; DIV_MAX || DIVIDER &lt; DIV_MIN)</span><br><span class="line">		stat_flag	&lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		stat_flag	&lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="comment">//-------------------信号输出-------------------</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		clk_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(clk_cnt == DIV_IDX-<span class="number">2</span>)</span><br><span class="line">		clk_out	&lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		clk_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<div>
<center>
<img src="image-20251208225120013.png" alt="image can't load." style="zoom:50%"> <br> 奇数分频仿真结果
</center>
</div>
<p><strong>显然always块中增加对下降沿的判断可以快速精准的找到分频结果，但是：</strong></p>
<ul>
<li><strong>双边沿检测综合更复杂、时序约束复杂</strong></li>
<li><strong>不适合合并到仅使用上升沿判断的通用分频模块中</strong></li>
</ul>
<p>因此可将上升沿下降沿分别放在两个块内，计数到分频值的一半时翻转，将输出信号相或即可得到输出：</p>
<div>
<center>
<img src="image-20251209232035871.png" alt="image can't load." style="zoom:75%"> <br> 奇分频波形
</center>
</div>
<p>代码块如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> oddDivider(</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	sys_clk,</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	sys_rst_n,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span>  <span class="keyword">wire</span>		clk_out </span><br><span class="line">    );</span><br><span class="line">	<span class="comment">//-------------------全局配置参数-------------------</span></span><br><span class="line">	<span class="keyword">parameter</span>		DIVIDER	=	<span class="number">32&#x27;d5</span>;</span><br><span class="line">	<span class="comment">//-------------------局部配置参数-------------------</span></span><br><span class="line">	<span class="keyword">localparam</span>		DIV_HIDX =	DIVIDER/<span class="number">2</span>;		</span><br><span class="line">	<span class="keyword">localparam</span>		DIV_IDX =	DIVIDER - <span class="number">1</span>;												  </span><br><span class="line"></span><br><span class="line">	<span class="comment">//-------------------分频计数器-------------------	</span></span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>]	clk_cnt;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">reg</span> clk_pos;</span><br><span class="line">	<span class="keyword">reg</span> clk_neg;</span><br><span class="line">	<span class="comment">//-------------------计数器-------------------	</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)	</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		clk_cnt &lt;= <span class="number">32&#x27;d0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(clk_cnt == DIV_IDX)</span><br><span class="line">		clk_cnt &lt;= <span class="number">32&#x27;d0</span> ;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		clk_cnt &lt;= clk_cnt + <span class="number">1&#x27;d1</span>;</span><br><span class="line">	<span class="comment">//-------------------上升沿输出-------------------		</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		clk_pos 	&lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(clk_cnt == DIV_HIDX || clk_cnt == DIV_IDX)</span><br><span class="line">		clk_pos		&lt;= ~clk_pos;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		clk_pos 	&lt;= clk_pos;</span><br><span class="line">    <span class="comment">//-------------------下降沿输出-------------------	</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">negedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		clk_neg 	&lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(clk_cnt == DIV_HIDX || clk_cnt == DIV_IDX)</span><br><span class="line">		clk_neg		&lt;= ~clk_neg;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		clk_neg 	&lt;= clk_neg;</span><br><span class="line">	<span class="comment">//-------------------线与输出-------------------	</span></span><br><span class="line">	<span class="keyword">assign</span> clk_out = clk_pos | clk_neg;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<div>
<center>
<img src="image-20251223221501338.png" alt="image can't load." style="zoom:75%"> <br> 奇分频仿真波形
</center>
</div>
<h2 id="通用分频">通用分频</h2>
<p>既然上方两种分频方式可产生flag信号，那么可通过对sys_clk基准时钟单上升沿计数封装出通用分频模块，到达分频时输出flag，代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> uPLL(</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	sys_clk,</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	sys_rst_n,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">reg</span>		clk_flag</span><br><span class="line">    );</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//-------------------全局配置参数-------------------</span></span><br><span class="line">	<span class="keyword">parameter</span>		DIVIDER	=	<span class="number">32&#x27;d5</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//-------------------局部配置参数-------------------</span></span><br><span class="line">	<span class="keyword">localparam</span>		DIV_REV_CNT		=	DIVIDER - <span class="number">2</span>;		<span class="comment">//flag reverse count</span></span><br><span class="line">	<span class="keyword">localparam</span>		DIV_REF_CNT		=	DIVIDER - <span class="number">1</span>;		<span class="comment">//reference value to clear the count</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//-------------------分频计数器-------------------	</span></span><br><span class="line">	<span class="keyword">reg</span>		[<span class="number">31</span>:<span class="number">0</span>]	clk_cnt;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		clk_cnt &lt;= <span class="number">32&#x27;d0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(clk_cnt == DIV_REF_CNT)</span><br><span class="line">		clk_cnt &lt;= <span class="number">32&#x27;d0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		clk_cnt &lt;= clk_cnt + <span class="number">1&#x27;d1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		clk_flag &lt;= <span class="number">1&#x27;d0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(clk_cnt == DIV_REV_CNT)</span><br><span class="line">		clk_flag &lt;= <span class="number">1&#x27;d1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		clk_flag &lt;= <span class="number">1&#x27;d0</span>;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<div>
<center>
<img src="image-20251223224225849.png" alt="image can't load." style="zoom:75%"> <br> 通用分频仿真波形
</center>
</div>
<h1 id="按键消抖">按键消抖</h1>
<p>按键是电路板上常用的给出特殊高低电平的器件，单一使用按键时可能出现按下/弹起时的波形抖动，称为前抖动/后抖动。常用的解决办法是：</p>
<ul>
<li>硬件上采用RS触发器、外接滤波电容</li>
<li>软件上采用延时算法</li>
</ul>
<div>
<center>
<img src="image-20251224225348372.png" alt="image can't load." style="zoom:75%"> <br> 按键抖动模型
</center>
</div>
<p>按键按下的状态分为5个状态：</p>
<ul>
<li>A、E：按下/弹起后的稳定状态</li>
<li>B：按下时的不稳定状态，持续时间不定</li>
<li>C：按下后的稳定状态</li>
<li>D：弹起时的不稳定状态，持续时间不定</li>
</ul>
<h2 id="功能需求">功能需求</h2>
<p>针对指定引脚，检测到连续20ms低电平时，输出1拍低电平</p>
<h2 id="详细设计">详细设计</h2>
<p>针对输入信号，当检测到低电平时计数器开始计数。若遇到高电平，则立刻清0。当达到给定值时输出低电平脉冲，随后计数值保持，直到按键释放。</p>
<div>
<center>
<img src="image-20251224231604239.png" alt="image can't load." style="zoom:75%"> <br> 方案设计
</center>
</div>
<p>上图3种方案设计时，依次分析可能出现的问题，直到优化出最终设计。</p>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> key_filter(</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	sys_clk,</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	sys_rst_n,</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	key_in,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">reg</span>		key_out</span><br><span class="line">    );</span><br><span class="line">	<span class="comment">//-------------------局部配置参数-------------------</span></span><br><span class="line">	<span class="keyword">parameter</span>	FILTER_MAX	= <span class="number">20&#x27;d1_000_000</span>;</span><br><span class="line">	<span class="keyword">reg</span>		[<span class="number">19</span>:<span class="number">0</span>]	hold_cnt;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//-------------------低电平保持计数器-------------------	</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		hold_cnt &lt;= <span class="number">20&#x27;d0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(key_in == <span class="number">1&#x27;b1</span>)</span><br><span class="line">		hold_cnt &lt;= <span class="number">20&#x27;d0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(hold_cnt == FILTER_MAX - <span class="number">1</span>)</span><br><span class="line">		hold_cnt &lt;= hold_cnt;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		hold_cnt &lt;= hold_cnt + <span class="number">1&#x27;d1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//-------------------滤波输出-------------------	</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		key_out &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(hold_cnt == FILTER_MAX - <span class="number">2</span>)</span><br><span class="line">		key_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		key_out &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>tb仿真文件中，也可以使用always块加计数器在不同时间段产生不同的输入：</p>
<p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>	[<span class="number">7</span>:<span class="number">0</span>]	clk_cnt;</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)	<span class="comment">//阶段计数器</span></span><br><span class="line"><span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">    clk_cnt &lt;= <span class="number">8&#x27;d0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(clk_cnt == <span class="number">199</span>)</span><br><span class="line">    clk_cnt &lt;= <span class="number">8&#x27;d0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    clk_cnt &lt;= clk_cnt + <span class="number">1&#x27;d1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)	<span class="comment">//分段输入</span></span><br><span class="line"><span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">    key_in &lt;= <span class="number">1&#x27;d1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(clk_cnt &lt;<span class="number">19</span> || clk_cnt&gt;=<span class="number">150</span>)		<span class="comment">//A/E高电平阶段</span></span><br><span class="line">    key_in &lt;= <span class="number">1&#x27;d1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(clk_cnt &gt;=<span class="number">50</span> &amp;&amp; clk_cnt &lt;<span class="number">100</span>)	<span class="comment">//C低电平阶段</span></span><br><span class="line">    key_in &lt;= <span class="number">1&#x27;d0</span>;</span><br><span class="line"><span class="keyword">else</span> 								<span class="comment">//B/D不稳定阶段</span></span><br><span class="line">    key_in &lt;= <span class="built_in">$random</span>%<span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="仿真结果">仿真结果</h2>
<div>
<center>
<img src="image-20251224232716374.png" alt="image can't load." style="zoom:75%"> <br> 仿真结果
</center>
</div>
<h1 id="流水灯">流水灯</h1>
<h2 id="功能需求-1">功能需求</h2>
<p>根据参数，调整4路LED流水灯输出，每间隔固定时间切换下一个灯亮。</p>
<h2 id="详细设计-1">详细设计</h2>
<p>在参数给定的情况下，只需设定计数器，计数到给定值时刷新输出，即方案A。此种情况无法保证复位按下时的初始状态全灭/全亮。</p>
<p>进一步，如果希望初始状态为4’b0000/4’b1111，和运行时仅1bit为1或0的状态并不一致。因此需要提前打1拍增加flag标志(参考<a href="#分频器">分频器</a>一节，提前1拍打出flag)，在检测到flag拉高时根据当前led状态决定是移位或是刷新初值(led_out
== 4b1000)。</p>
<blockquote>
<p>如果采用位拼接，只需要在flag拉高时刷新初值。</p>
</blockquote>
<div>
<center>
<img src="image-20251225214938051.png" alt="image can't load." style="zoom:75%"> <br> 方案设计
</center>
</div>
<h2 id="代码实现-1">代码实现</h2>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> flow_led(</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>			sys_clk,</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>			sys_rst_n,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">reg</span>		[<span class="number">3</span>:<span class="number">0</span>]	led_out</span><br><span class="line">    );</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//-------------------全局配置参数-------------------</span></span><br><span class="line">	<span class="keyword">parameter</span>	G_LIGHT_HD_TIME	= <span class="number">25&#x27;d25_000_000</span>;	<span class="comment">//LED light hold time</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//-------------------局部配置参数-------------------</span></span><br><span class="line">	<span class="keyword">localparam</span>	L_LIGHT_HD_TIME = G_LIGHT_HD_TIME - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">localparam</span>	L_LED_INIT		= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">reg</span>	[<span class="number">24</span>:<span class="number">0</span>]	clk_cnt;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		clk_cnt &lt;= <span class="number">25&#x27;d0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(clk_cnt == L_LIGHT_HD_TIME)</span><br><span class="line">		clk_cnt &lt;= <span class="number">25&#x27;d0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		clk_cnt &lt;= clk_cnt + <span class="number">1&#x27;d1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//方案B-移位</span></span><br><span class="line">	<span class="keyword">reg</span>	time500ms_flag;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		time500ms_flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(clk_cnt == L_LIGHT_HD_TIME - <span class="number">1</span>)</span><br><span class="line">		time500ms_flag &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		time500ms_flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		led_out &lt;= L_LED_INIT;					<span class="comment">//设置复位时独特状态</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(led_out == L_LED_INIT)</span><br><span class="line">		led_out &lt;= L_LED_INIT + <span class="number">4&#x27;b0001</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(time500ms_flag)<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>( led_out == <span class="number">4&#x27;b1000</span>)</span><br><span class="line">			led_out &lt;= L_LED_INIT + <span class="number">4&#x27;b0001</span>;	<span class="comment">//移位</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			led_out &lt;= led_out&lt;&lt;<span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		led_out &lt;= led_out;</span><br><span class="line">	<span class="comment">//方案A--位拼接</span></span><br><span class="line">	<span class="comment">/*	</span></span><br><span class="line"><span class="comment">	always@(posedge sys_clk or negedge sys_rst_n)</span></span><br><span class="line"><span class="comment">	if(!sys_rst_n)</span></span><br><span class="line"><span class="comment">		led_out &lt;= L_LED_INIT;</span></span><br><span class="line"><span class="comment">	else if(clk_cnt == L_LIGHT_HD_TIME)</span></span><br><span class="line"><span class="comment">		led_out &lt;= &#123;led_out[2:0],led_out[3]&#125;;	//位拼接</span></span><br><span class="line"><span class="comment">	else</span></span><br><span class="line"><span class="comment">		led_out &lt;= led_out;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="仿真结果-1">仿真结果</h2>
<div>
<center>
<img src="image-20251225220056320.png" alt="image can't load." style="zoom:75%"> <br>
</center>
</div>
<p>方案A的不再赘述。对上述方案B，复位后的第一个状态会丢1拍，在<a href="#计数器">计数器</a>一节尾部已经做了分析。</p>
<h1 id="呼吸灯">呼吸灯</h1>
<p>流水灯是在指定时间间隔是切换状态，呼吸灯为达到呼吸效果则通过控制占空比（PWM）达到不同程度的亮度效果（引脚直接控制电压显然比较困难）。</p>
<ul>
<li>在不同时间段，不同占空比呈现不同亮度。</li>
</ul>
<h2 id="功能需求-2">功能需求</h2>
<p>给定参数T下，实现均匀的亮，灭效果，整个周期为2T。</p>
<h2 id="详细设计-2">详细设计</h2>
<p>假设有1个较短的时间片，根据PWM的原理，此时间片内，高电平持续时间越长，呈现的亮度越亮。通过对相同长度的时间片设置递增的高电平时长，可以“呼吸”式亮起/灭下。</p>
<p>参照其他已有设计，可以1us为基准时间单位，以N个单位设置上一级/上上一级时间片。</p>
<blockquote>
<p>若如此设置，单个亮/灭状态的周期 T = N<sup>2</sup> us。</p>
<p>将两级时间片的单位设置为相同，程序内方便以当前循环周期设定亮灭。</p>
</blockquote>
<div>
<center>
<img src="image-20260103155003452.png" alt="image can't load." style="zoom:55%"> <br><br>
呼吸灯波形时序
</center>
</div>
<p>上方是整体的逻辑，N =
1000，标准的1s亮/灭。单独以其中一个为例，将计数值简化t1 = t2 = t3 =
4。</p>
<p>四个led_out从上至下为连续4个cnt_t3下的输出，呈现如下态势：</p>
<div>
<center>
<img src="image-20260103162626328.png" alt="image can't load." style="zoom:55%"> <br><br>
单周期波形
</center>
</div>
<p>可发现：cnt_t2&lt;cnt_t3时灯亮，可实现亮度时间均匀的增长。（暗下同理）</p>
<h2 id="代码实现-2">代码实现</h2>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">module</span> breathe_led</span><br><span class="line">	#(	</span><br><span class="line">	<span class="keyword">parameter</span>	G_US_CNT_MAX = <span class="number">6&#x27;d50</span>,		<span class="comment">//cnt_t1</span></span><br><span class="line">	<span class="keyword">parameter</span>	G_MS_CNT_MAX = <span class="number">10&#x27;d1000</span>,	<span class="comment">//cnt_t2</span></span><br><span class="line">	<span class="keyword">parameter</span>	G_S_CNT_MAX =  <span class="number">10&#x27;d1000</span>		<span class="comment">//cnt_t3，参数值由外部输入，便于仿真观察</span></span><br><span class="line">	)</span><br><span class="line">	(</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	sys_clk,</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	sys_rst_n,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">reg</span>		pwm_out</span><br><span class="line">    );</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//-------------- 全局参数 -------------</span></span><br><span class="line">	<span class="comment">//parameter	G_US_CNT_MAX = 6&#x27;d50,		//全局参数也可写在内部</span></span><br><span class="line">	<span class="comment">//parameter	G_MS_CNT_MAX = 10&#x27;d1000,</span></span><br><span class="line">	<span class="comment">//parameter	G_S_CNT_MAX =  10&#x27;d1000,</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//-------------- 局部参数 -------------</span></span><br><span class="line">	<span class="keyword">localparam</span>	L_US_CNT_MAX = G_US_CNT_MAX - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">localparam</span>	L_MS_CNT_MAX = G_MS_CNT_MAX - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">localparam</span>	L_S_CNT_MAX =  G_S_CNT_MAX - <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//-------------- 计数器定义 -------------</span></span><br><span class="line">    <span class="keyword">reg</span>	[<span class="number">5</span>:<span class="number">0</span>]	us_cnt;		<span class="comment">//此处注意，位宽需要结合实际值，若希望计数129，则6bit是不够的</span></span><br><span class="line">	<span class="keyword">reg</span>	[<span class="number">10</span>:<span class="number">0</span>]	ms_cnt;		</span><br><span class="line">	<span class="keyword">reg</span>	[<span class="number">10</span>:<span class="number">0</span>]	s_cnt;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//--------------  us计数器  -------------</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)	<span class="comment">//用于产生基准us计数器</span></span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		us_cnt &lt;= <span class="number">6&#x27;d0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(us_cnt == L_US_CNT_MAX)</span><br><span class="line">		us_cnt &lt;= <span class="number">6&#x27;d0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		us_cnt &lt;= us_cnt + <span class="number">1&#x27;d1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//--------------  ms计数器  -------------</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		ms_cnt &lt;= <span class="number">10&#x27;d0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(us_cnt == L_US_CNT_MAX &amp;&amp; ms_cnt == L_MS_CNT_MAX)</span><br><span class="line">		ms_cnt &lt;= <span class="number">10&#x27;d0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(us_cnt == L_US_CNT_MAX)</span><br><span class="line">		ms_cnt &lt;= ms_cnt + <span class="number">1&#x27;d1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ms_cnt &lt;= ms_cnt;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//--------------  s计数器  -------------</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)	</span><br><span class="line">		s_cnt &lt;= <span class="number">10&#x27;d0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(us_cnt == L_US_CNT_MAX &amp;&amp; </span><br><span class="line">			ms_cnt == L_MS_CNT_MAX &amp;&amp;</span><br><span class="line">			s_cnt  == L_S_CNT_MAX)</span><br><span class="line">		s_cnt &lt;= <span class="number">10&#x27;d0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(us_cnt == L_US_CNT_MAX &amp;&amp; </span><br><span class="line">			ms_cnt == L_MS_CNT_MAX )</span><br><span class="line">		s_cnt &lt;= s_cnt + <span class="number">1&#x27;d1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		s_cnt &lt;= s_cnt;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//--------------  亮灭状态切换  -------------</span></span><br><span class="line">	<span class="keyword">reg</span> breathe_status;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)	</span><br><span class="line">		breathe_status &lt;= <span class="number">1&#x27;d0</span>;	<span class="comment">//亮状态</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(us_cnt == L_US_CNT_MAX &amp;&amp; </span><br><span class="line">			ms_cnt == L_MS_CNT_MAX &amp;&amp;</span><br><span class="line">			s_cnt  == L_S_CNT_MAX)</span><br><span class="line">		breathe_status &lt;= ~breathe_status; <span class="comment">//灭状态</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		breathe_status &lt;= breathe_status;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//--------------  PWM输出  -------------</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		pwm_out &lt;= <span class="number">1&#x27;d0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>((breathe_status == <span class="number">1&#x27;d0</span> &amp;&amp; ms_cnt &gt; s_cnt) ||</span><br><span class="line">			(breathe_status == <span class="number">1&#x27;d1</span> &amp;&amp; ms_cnt &lt; s_cnt))</span><br><span class="line">		pwm_out &lt;= <span class="number">1&#x27;d0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		pwm_out &lt;= <span class="number">1&#x27;d1</span>;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>上方代码为single channel的输出，再建立顶层模块即可实现4
chl的不同频率输出（参考ip核设计思路，不改动内部代码）：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> breathe_4chl_led(</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span> 		sys_clk,</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>		sys_rst_n,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">wire</span>	[<span class="number">3</span>:<span class="number">0</span>]	led_out</span><br><span class="line">    );</span><br><span class="line">	</span><br><span class="line">	breathe_led</span><br><span class="line">	#(	</span><br><span class="line">	<span class="variable">.G_US_CNT_MAX</span>(<span class="number">6&#x27;d50</span>),</span><br><span class="line">	<span class="variable">.G_MS_CNT_MAX</span>(<span class="number">10&#x27;d1000</span>),</span><br><span class="line">	<span class="variable">.G_S_CNT_MAX</span>(<span class="number">10&#x27;d1000</span>)</span><br><span class="line">	)</span><br><span class="line">	breathe_led_inst0(</span><br><span class="line">	<span class="variable">.sys_clk</span>(sys_clk),</span><br><span class="line">	<span class="variable">.sys_rst_n</span>(sys_rst_n),</span><br><span class="line">	</span><br><span class="line">	<span class="variable">.pwm_out</span>(led_out[<span class="number">0</span>])</span><br><span class="line">    );</span><br><span class="line">	</span><br><span class="line">	breathe_led</span><br><span class="line">	#(	</span><br><span class="line">	<span class="variable">.G_US_CNT_MAX</span>(<span class="number">6&#x27;d50</span>),</span><br><span class="line">	<span class="variable">.G_MS_CNT_MAX</span>(<span class="number">10&#x27;d700</span>),</span><br><span class="line">	<span class="variable">.G_S_CNT_MAX</span> (<span class="number">10&#x27;d700</span>)</span><br><span class="line">	)</span><br><span class="line">	breathe_led_inst1(</span><br><span class="line">	<span class="variable">.sys_clk</span>(sys_clk),</span><br><span class="line">	<span class="variable">.sys_rst_n</span>(sys_rst_n),</span><br><span class="line">	</span><br><span class="line">	<span class="variable">.pwm_out</span>(led_out[<span class="number">1</span>])</span><br><span class="line">    );</span><br><span class="line">	</span><br><span class="line">	breathe_led</span><br><span class="line">	#(	</span><br><span class="line">	<span class="variable">.G_US_CNT_MAX</span> (<span class="number">6&#x27;d50</span>),</span><br><span class="line">	<span class="variable">.G_MS_CNT_MAX</span> (<span class="number">10&#x27;d500</span>),</span><br><span class="line">	<span class="variable">.G_S_CNT_MAX</span>  (<span class="number">10&#x27;d500</span>)</span><br><span class="line">	)</span><br><span class="line">	breathe_led_inst2(</span><br><span class="line">	<span class="variable">.sys_clk</span>(sys_clk),</span><br><span class="line">	<span class="variable">.sys_rst_n</span>(sys_rst_n),</span><br><span class="line">	</span><br><span class="line">	<span class="variable">.pwm_out</span>(led_out[<span class="number">2</span>])</span><br><span class="line">    );</span><br><span class="line">	</span><br><span class="line">	breathe_led</span><br><span class="line">	#(	</span><br><span class="line">	<span class="variable">.G_US_CNT_MAX</span> (<span class="number">6&#x27;d50</span>),</span><br><span class="line">	<span class="variable">.G_MS_CNT_MAX</span> (<span class="number">11&#x27;d2000</span>),</span><br><span class="line">	<span class="variable">.G_S_CNT_MAX</span>  (<span class="number">11&#x27;d2000</span>)</span><br><span class="line">	)</span><br><span class="line">	breathe_led_inst3(</span><br><span class="line">	<span class="variable">.sys_clk</span>(sys_clk),</span><br><span class="line">	<span class="variable">.sys_rst_n</span>(sys_rst_n),</span><br><span class="line">	</span><br><span class="line">	<span class="variable">.pwm_out</span>(led_out[<span class="number">3</span>])</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="仿真结果-2">仿真结果</h2>
<p>pwm_out的输出高电平时间均匀递增</p>
<div>
<center>
<img src="image-20251230232647727.png" alt="image can't load." style="zoom:75%"> <br><br>
呼吸灯仿真输出
</center>
</div>
<h1 id="状态机">状态机</h1>
<p>状态机缩写FSM，又叫有限状态机，指状态的个数有限。根据是否受限于输入分为</p>
<ul>
<li>Moore型：最后输出状态至于当前状态有关，与输入无关</li>
<li>Mealy型：最后输出状态至于当前状态有关，同时与输入有关</li>
</ul>
<p><strong>状态机的状态意为“事件”，A事件到B或C事件称为状态转移。</strong>完整的状态机需要具备：</p>
<ul>
<li>输入：根据输入可以确定是否需要进行状态跳转以及输出，是影响状态机系统执行过程的重要驱动力；</li>
<li>输出：根据当前时刻的状态以及输入，是状态机系统最终要执行的动作；</li>
<li>状态：根据输入和上一状态决定当前时刻所处的状态，是状态机系统执行的一个稳定的过程。</li>
</ul>
<div>
<center>
<img src="image-20260104194145937.png" alt="image can't load." style="zoom:55%"> <br><br>
状态图模型
</center>
</div>
<h2 id="单输入单输出状态机">单输入单输出状态机</h2>
<h3 id="功能需求-3">功能需求</h3>
<p>可乐机每次只能投入1枚1元硬币，且每瓶可乐卖3元钱，即投入3个硬币就可以让可乐机出可乐，如果投币不够3元想放弃投币需要按复位键，否则之前投入的钱不能退回。</p>
<h3 id="详细设计-3">详细设计</h3>
<p>对该需求需要设计状态转移图，即IDLE、ONE、TWO三个投币状态，状态间的切换靠输入驱动，与当前状态和输入有关，如下Mealy状态机。</p>
<div>
<center>
<img src="image-20260104194145937.png" alt="image can't load." style="zoom:55%"> <br><br>
Mealy状态机模型
</center>
</div>
<p>若再增加一个状态THREE，输出则可完全依照当前状态，即检测到为THREE状态后直接输出可乐，输入不影响输出。如下Moore型状态机。</p>
<div>
<center>
<img src="image-20260104195038410.png" alt="image can't load." style="zoom:55%"> <br><br>
Moore状态机模型
</center>
</div>
<h3 id="波形分析">波形分析</h3>
<p>此节的需求中，输入只有一个，状态根据输入变化。</p>
<div>
<center>
<img src="image-20260104201917235.png" alt="image can't load." style="zoom:55%"> <br><br>
Mealy状态机波形
</center>
</div>
<h3 id="代码实现-3">代码实现</h3>
<p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> simple_FSM(</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	sys_clk,</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	sys_rst_n,</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	pi_money,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">reg</span>		po_cola</span><br><span class="line">	);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">parameter</span>	IDLE = <span class="number">3&#x27;b001</span>;</span><br><span class="line">	<span class="keyword">parameter</span>	ONE =  <span class="number">3&#x27;b010</span>;</span><br><span class="line">	<span class="keyword">parameter</span>	TWO =  <span class="number">3&#x27;b100</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		state &lt;= IDLE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">case</span> (state)</span><br><span class="line">		IDLE:	<span class="keyword">if</span>(pi_money == <span class="number">1&#x27;b1</span>)</span><br><span class="line">					state &lt;= ONE;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					state &lt;= IDLE;</span><br><span class="line">		ONE:	<span class="keyword">if</span>(pi_money == <span class="number">1&#x27;b1</span>)</span><br><span class="line">					state &lt;= TWO;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					state &lt;= ONE;</span><br><span class="line">		TWO:	<span class="keyword">if</span>(pi_money == <span class="number">1&#x27;b1</span>)</span><br><span class="line">					state &lt;= IDLE;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					state &lt;= TWO;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">				state &lt;= IDLE;</span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">		</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		po_cola &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(state == TWO &amp;&amp; pi_money == <span class="number">1&#x27;b1</span>)</span><br><span class="line">		po_cola &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		po_cola &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<h3 id="仿真分析">仿真分析</h3>
<div>
<center>
<img src="image-20260105182126774.png" alt="image can't load." style="zoom:55%"> <br><br>
三状态仿真波形
</center>
</div>
<h2 id="多输入多输出状态机">多输入多输出状态机</h2>
<h3 id="功能需求-4">功能需求</h3>
<p>可乐定价为2.5元一瓶，可投入0.5元、1元硬币，投币不够2.5元需要按复位键退回钱款，投币超过2.5元需找零。</p>
<h3 id="详细设计-4">详细设计</h3>
<p>先设计状态转移图，即IDLE、HALF、ONE、ONE_HALF、TWO、三个投币状态，状态间的切换靠输入驱动，与当前状态和输入有关，如下Mealy状态机。</p>
<p>确定输入：</p>
<ul>
<li>0.5元</li>
<li>1元</li>
</ul>
<p>确定输出：</p>
<ul>
<li>是否找零</li>
<li>是否出可乐</li>
</ul>
<div>
<center>
<img src="image-20260105192532293.png" alt="image can't load." style="zoom:55%"> <br><br>
Mealy状态转移图
</center>
</div>
<h3 id="波形分析-1">波形分析</h3>
<div>
<center>
<img src="image-20260105190633278.png" alt="image can't load." style="zoom:55%"> <br><br>
波形分析图
</center>
</div>
<h3 id="代码实现-4">代码实现</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> complex_FSM(</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	sys_clk,</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	sys_rst_n,</span><br><span class="line">	<span class="keyword">input</span> 	<span class="keyword">wire</span>	pi_money_one,</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	pi_money_half,</span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">reg</span>		po_money,</span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">reg</span>		po_cola</span><br><span class="line">    );</span><br><span class="line">	<span class="comment">//------------ 输入合并 ------------------</span></span><br><span class="line">	<span class="keyword">wire</span>   [<span class="number">1</span>:<span class="number">0</span>] pi_money;</span><br><span class="line">	<span class="keyword">assign</span> pi_money = &#123;pi_money_one,pi_money_half&#125;;</span><br><span class="line">	<span class="comment">//------------ 局部参数 ------------------</span></span><br><span class="line">	<span class="comment">//---- 状态定义</span></span><br><span class="line">	<span class="keyword">localparam</span>	IDLE 		= <span class="number">5&#x27;b00001</span>;</span><br><span class="line">	<span class="keyword">localparam</span>	HALF		= <span class="number">5&#x27;b00010</span>;</span><br><span class="line">	<span class="keyword">localparam</span>	ONE	 		= <span class="number">5&#x27;b00100</span>;</span><br><span class="line">	<span class="keyword">localparam</span>	ONE_HALF 	= <span class="number">5&#x27;b01000</span>;</span><br><span class="line">	<span class="keyword">localparam</span>	TWO 		= <span class="number">5&#x27;b10000</span>;</span><br><span class="line">	<span class="comment">//-----输入定义</span></span><br><span class="line">	<span class="keyword">localparam</span>	INPUT_HALF	= <span class="number">2&#x27;b01</span>;</span><br><span class="line">	<span class="keyword">localparam</span>	INPUT_ONE	= <span class="number">2&#x27;b10</span>;</span><br><span class="line">	<span class="comment">//------------ 状态切换 ------------------	</span></span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] state;</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		state &lt;= IDLE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">case</span>(state)</span><br><span class="line">		IDLE:	<span class="keyword">if</span>(pi_money == INPUT_HALF)</span><br><span class="line">					state &lt;= HALF;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(pi_money == INPUT_ONE)</span><br><span class="line">					state &lt;= ONE;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					state &lt;= IDLE;</span><br><span class="line">		HALF:	<span class="keyword">if</span>(pi_money == INPUT_HALF)</span><br><span class="line">					state &lt;= ONE;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(pi_money ==INPUT_ONE)</span><br><span class="line">					state &lt;= ONE_HALF;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					state &lt;= HALF;</span><br><span class="line">		ONE:	<span class="keyword">if</span>(pi_money == INPUT_HALF)</span><br><span class="line">					state &lt;= ONE_HALF;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(pi_money == INPUT_ONE)</span><br><span class="line">					state &lt;= TWO;</span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">					state &lt;= ONE;</span><br><span class="line">		ONE_HALF:<span class="keyword">if</span>(pi_money == INPUT_HALF)</span><br><span class="line">					state &lt;= TWO;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(pi_money ==INPUT_ONE)</span><br><span class="line">					state &lt;= IDLE;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					state &lt;= ONE_HALF;</span><br><span class="line">		TWO:	<span class="keyword">if</span>(pi_money[<span class="number">1</span>] != pi_money[<span class="number">0</span>])</span><br><span class="line">					state &lt;= IDLE;</span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">					state &lt;= TWO;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">				state &lt;= IDLE;</span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="comment">//---------------- 输出量</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		po_cola &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>((state == ONE_HALF &amp;&amp; pi_money == INPUT_ONE)</span><br><span class="line">			|| (state == TWO &amp;&amp; pi_money[<span class="number">1</span>] != pi_money[<span class="number">0</span>]))</span><br><span class="line">		po_cola &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		po_cola	&lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="comment">//---------------- 输出量</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		po_money &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(state == TWO &amp;&amp; pi_money == INPUT_ONE)</span><br><span class="line">		po_money &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		po_money &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb_complex_FSM(</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line">	<span class="keyword">reg</span>	sys_clk;</span><br><span class="line">	<span class="keyword">reg</span> sys_rst_n;</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] pi_money;</span><br><span class="line">	<span class="keyword">wire</span>	po_cola;</span><br><span class="line">	<span class="keyword">wire</span>	po_money;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		sys_clk = <span class="number">1&#x27;b1</span>;</span><br><span class="line">		sys_rst_n &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		#<span class="number">20</span></span><br><span class="line">		sys_rst_n &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//--------------- 引用仿真实例inst0内的量</span></span><br><span class="line">	<span class="keyword">wire</span> [<span class="number">4</span>:<span class="number">0</span>] state = complex_FSM_inst0<span class="variable">.state</span>;</span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		<span class="built_in">$timeformat</span>(-<span class="number">9</span>,<span class="number">0</span>,<span class="string">&quot;ns&quot;</span>,<span class="number">6</span>);</span><br><span class="line">		<span class="built_in">$monitor</span>(<span class="string">&quot;@time %t: pi_money_half = %b, pi_money_one = %b, state = %b,po_cola = %b, po_money = %b&quot;</span>,</span><br><span class="line">					<span class="built_in">$time</span> ,pi_money[<span class="number">0</span>],pi_money[<span class="number">1</span>],state,po_cola,po_money);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">//--------------- 50MHz时钟</span></span><br><span class="line">	<span class="keyword">always</span> #<span class="number">10</span> sys_clk = ~sys_clk;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//--------------- 随机输入</span></span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!sys_rst_n)</span><br><span class="line">		pi_money &lt;= <span class="number">2&#x27;b00</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		pi_money &lt;= &#123;<span class="built_in">$random</span>&#125;%<span class="number">3</span>;</span><br><span class="line">	</span><br><span class="line">	complex_FSM complex_FSM_inst0(</span><br><span class="line">	<span class="variable">.sys_clk</span>(sys_clk),</span><br><span class="line">	<span class="variable">.sys_rst_n</span>(sys_rst_n),</span><br><span class="line">	<span class="variable">.pi_money_one</span>(pi_money[<span class="number">1</span>]),</span><br><span class="line">	<span class="variable">.pi_money_half</span>(pi_money[<span class="number">0</span>]),</span><br><span class="line">	</span><br><span class="line">	<span class="variable">.po_money</span>(po_money),</span><br><span class="line">	<span class="variable">.po_cola</span>(po_cola)</span><br><span class="line">    );</span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="仿真分析-1">仿真分析</h3>
<div>
<center>
<img src="image-20260105204438970.png" alt="image can't load." style="zoom:55%"> <br><br>
仿真波形
</center>
</div>
<blockquote>
<p>最初在做仿真时，pi_money_half和pi_money_one在独立的always块内赋值，导致出现同时为1的意外情况。后续修正为pi_money
&lt;= {$random}%3; 包含00、01、10三种情况。</p>
</blockquote>
<h1 id="综合应用">综合应用</h1>
<p>结合本篇博文的消抖、流水灯、状态机，可以搭建简单的小功能。</p>
<h2 id="功能需求-5">功能需求</h2>
<p>实现可乐机，投币为0.5元、1元，达到2.5时出可乐，达到3时出可乐并找零。每次投币10s后无操作则回到初始态。每个投币状态由LED反馈，0-2元，分别亮起0-4个LED，2.5元为单向流水，3元时为双向流水，流水间隔0.5s。</p>
<h2 id="详细设计-5">详细设计</h2>
<p>如果继续按照模块化设计思路，根据需求可拆解以下模块：</p>
<ul>
<li>输入检测：确定是否有输入，输入是什么，并进行滤波</li>
<li>状态切换：确定什么时间复位，输出包含所有状态</li>
<li>LED控制：根据当前状态进行LED亮灭</li>
</ul>
<div>
<center>
<img src="image-20260110101735089.png" alt="image can't load." style="zoom:55%"> <br><br>
模块划分
</center>
</div>
<h2 id="波形分析-2">波形分析</h2>
<p>[1]输入检测：参考<a href="#按键消抖">按键消抖</a>一节，当监测到连续20ms输入时，输出1拍高电平</p>
<p>[2]状态机：相对<a href="#状态机">上一节</a>内容</p>
<ul>
<li>取消cola和money的输出</li>
<li>新增FSM的state状态量输出，供后续模块调用</li>
<li>新增切换状态后10s复位计数器</li>
</ul>
<p>[3]LED控制：</p>
<p>LED控制状态包括两种，固定排列常亮 +
指定间隔/方向闪烁，对两种分别进行波形逻辑绘制：</p>
<div>
<center>
<img src="image-20260110102524194.png" alt="image can't load." style="zoom:75%"> <br><br>
基本状态：N个LED常亮，红色虚线表示进入新状态
</center>
</div>
<p>每uint_cnt，检测并切换LED状态。若在state !=
prev_state时切换状态，则uint_cnt复位，重新对新状态计时。</p>
<div>
<center>
<img src="image-20260111173304436.png" alt="image can't load." style="zoom:75%"> <br><br>
流水状态：间隔0.5s流水，红色虚线表示进入新状态
</center>
</div>
<p>由于流水状态包含流水方向，需要1bit寄存器表示什么时候翻转。由于后续状态依靠flow_dir，因此需要提前打一拍翻转。</p>
<h2 id="代码设计">代码设计</h2>
<p>代码查阅:<a href="https://github.com/MicroPrism/MicroPrism.github.io/tree/main/code/2025-12-01-FPGA-04-Verilog_Syntax">点击此处</a></p>
<p>总结发现，真正耗时的时确定模块间的数据传递关系，比如：</p>
<ul>
<li>Key按键到FSM检测时输入的究竟是1拍高电平还是低电平：单模块仿真时未发现此问题，整体仿真异常才发现</li>
<li>状态参数究竟由谁控制：led的state仅前级传递，还是内部定义一个10s回到空闲态的计数器，应在划分模块时提前构思好</li>
</ul>
<h2 id="仿真分析-2">仿真分析</h2>
<p>此处只放top层文件仿真结果：</p>
<div>
<center>
<img src="image-20260111174908264.png" alt="image can't load." style="zoom:75%"> <br><br>
仿真结果：模块间传输延时1拍
</center>
</div>
<h1 id="注意事项">注意事项</h1>
<ol type="1">
<li><p>仿真时必须修改tb文件中传递parameter参数的时，底层模块的局部参数才会变化，否则仿真时继续使用上一次的值，导致结果异常。</p></li>
<li><p>状态量设置</p>
<p>状态量类似C语言中的宏定义，常见的0、1、2….区分不同状态，在Verilog中也类似，以下三种形式都可以表示四种状态：</p>
<ul>
<li>二进制值：2’b00,2’b01,2’b10,2’b11</li>
<li>独热码：4’b0001,4’b0010,4’b0100,4’b1000</li>
<li><a href="https://blog.csdn.net/jingfengvae/article/details/51691124">格雷码</a>：3’b000,3’b001,3’b011,3b’110，相邻两个编码只有一个bit不同</li>
</ul>
<p>由于Verilog代码最后综合出的是电路，一个bit可以视为一个比较器。由于布局布线的差异多输入比较器可以会存在传输延迟，可能导致A输入在clk上升沿前，而B输出延迟2ns出现在clk上升沿之后，进而出现状态不稳的情况。格雷码相邻编码只有1bit不同，解决多输入传输延迟问题，同时节省部分资源。</p>
<p><strong>FPGA寄存器资源较多，CPLD组合逻辑资源多，通常采用以下配置方式。</strong></p>
<div>
<center>
<img src="image-20260105205421207.png" alt="image can't load." style="zoom:55%"> <br><br>
编码方式表
</center>
</div></li>
</ol>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p><em>君子终日乾乾，夕惕若厉。–《周易·乾卦》</em></p>
</blockquote>
]]></content>
      <categories>
        <category>电子类</category>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA-03-Verilog语法</title>
    <url>/2025/11/24/FPGA-03-Verilog_Syntax/</url>
    <content><![CDATA[<p>本文参考实例熟悉Verilog
HDL基本语法，描述FPGA程序设计本质和思路。基于Vivado创建工程，野火ZYNQ-7020开发板实操。</p>
<span id="more"></span>
<h1 id="开发背景">开发背景</h1>
<p>软件：Vivado 2018.3</p>
<p>开发板：野火 Xilinx-ZYNQ-7000开发板-皓月开发平台</p>
<p>芯片：XC7Z020CLG400-2</p>
<p>工程目录：</p>
<ul>
<li><p>doc：存放visio图形文件，包括模块IO、波形图、原理图（查引脚）、RTL电路</p></li>
<li><p>Vivado_Prj：项目文件</p></li>
</ul>
<p>基本开发流程：</p>
<ol type="1">
<li>模块划分：明确需要什么功能，需要什么输入输出信号</li>
<li>波形绘制：FPGA本质为数字电路，设计之前明确IO真值表。</li>
<li>代码编写：设计模块</li>
<li>仿真分析：设计testbench文件，<strong>但是仿真结果也不等于实测</strong></li>
<li>RTL综合：实际的代码转化为RTL电路，不同的语句使用的底层电路不相同</li>
<li>添加约束：分配FPGA引脚、时序约束等</li>
<li>硬件联调：上板验证</li>
</ol>
<h1 id="语法应用">语法应用</h1>
<p>FPGA程序是并行执行的，所有always块可视作同步执行，设计不同的块就是设计always触发条件。</p>
<h2 id="模块程序">模块程序</h2>
<h3 id="模块io">模块IO　</h3>
<p>仍然拿C的函数举例，通常会包含ｎ个固定的输入量，0或1个输出量。FPGA则使用input、output、output做区分。
通常输入量为wire型。输出则需要对应代码，通常使用组合逻辑时为reg型，特殊使用assign赋值则为wire型。</p>
<h3 id="latch锁存">Latch锁存</h3>
<p>程序设计不当时，综合后的RTL电路会产生Latch锁存器，在同步电路中应当避免。其危害如下：</p>
<ul>
<li>毛刺敏感</li>
<li>无法异步复位，上电后为不定态</li>
<li>静态时序分析复杂化</li>
</ul>
<p>组合逻辑中产生Latch的条件：</p>
<ul>
<li><p>if-else语句缺少末尾的else</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(&#123;in1,in2,in3&#125;==<span class="number">3&#x27;b000</span>)	</span><br><span class="line">    out = <span class="number">8&#x27;b0000_0001</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(&#123;in1,in2,in3&#125;==<span class="number">3&#x27;b001</span>)</span><br><span class="line">    out = <span class="number">8&#x27;b0000_0010</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(&#123;in1,in2,in3&#125;==<span class="number">3&#x27;b010</span>)</span><br><span class="line">    out = <span class="number">8&#x27;b0000_0100</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(&#123;in1,in2,in3&#125;==<span class="number">3&#x27;b011</span>)</span><br><span class="line">    out = <span class="number">8&#x27;b0000_1000</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(&#123;in1,in2,in3&#125;==<span class="number">3&#x27;b100</span>)</span><br><span class="line">    out = <span class="number">8&#x27;b0001_0000</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(&#123;in1,in2,in3&#125;==<span class="number">3&#x27;b101</span>)</span><br><span class="line">    out = <span class="number">8&#x27;b0010_0000</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(&#123;in1,in2,in3&#125;==<span class="number">3&#x27;b110</span>)</span><br><span class="line">    out = <span class="number">8&#x27;b0100_0000</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(&#123;in1,in2,in3&#125;==<span class="number">3&#x27;b111</span>)</span><br><span class="line">    out = <span class="number">8&#x27;b1000_0000</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    out = <span class="number">8&#x27;b0000_0000</span>;</span><br></pre></td></tr></table></figure>
<div>
<center>
<img src="image-20251124205938660.png" alt="image can't load." style="zoom:100%"> <br> if-else语句遍历所有条件
</center>
</div>
<p>若缺少最终的else语句，则会在尾部产生锁存：</p>
<div>
<center>
<img src="image-20251124210134581.png" alt="image can't load." style="zoom:100%"> <br> if-else语句缺少else
</center>
</div></li>
<li><p>case语句在条件未遍历时缺少default</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span>(&#123;in1,in2,in3&#125;)</span><br><span class="line">		<span class="number">3&#x27;b000</span>:	out = <span class="number">8&#x27;b0000_0001</span>;</span><br><span class="line">		<span class="number">3&#x27;b001</span>:	out = <span class="number">8&#x27;b0000_0010</span>;</span><br><span class="line">		<span class="number">3&#x27;b010</span>:	out = <span class="number">8&#x27;b0000_0100</span>;</span><br><span class="line">		<span class="number">3&#x27;b011</span>:	out = <span class="number">8&#x27;b0000_1000</span>;</span><br><span class="line">		<span class="number">3&#x27;b100</span>:	out = <span class="number">8&#x27;b0001_0000</span>;</span><br><span class="line">		<span class="number">3&#x27;b101</span>:	out = <span class="number">8&#x27;b0010_0000</span>;</span><br><span class="line">		<span class="number">3&#x27;b110</span>:	out = <span class="number">8&#x27;b0100_0000</span>;</span><br><span class="line">		<span class="number">3&#x27;b111</span>:	out = <span class="number">8&#x27;b1000_0000</span>;</span><br><span class="line">		<span class="keyword">default</span>:out = <span class="number">8&#x27;b0000_0000</span>;</span><br><span class="line">	<span class="keyword">endcase</span>	</span><br></pre></td></tr></table></figure>
<div>
<center>
<img src="image-20251124205259801.png" alt="image can't load." style="zoom:75%"> <br> case语句遍历所有条件
</center>
</div>
<p>而将</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">3&#x27;b111</span>:	out = <span class="number">8&#x27;b1000_0000</span>;</span><br><span class="line"><span class="keyword">default</span>:out = <span class="number">8&#x27;b0000_0000</span>;</span><br></pre></td></tr></table></figure>
<p>两句注释之后生成的RTL电路则带有Latch</p>
<div>
<center>
<img src="image-20251124205716339.png" alt="image can't load." style="zoom:75%"> <br> case语句缺少条件
</center>
</div></li>
<li><p>输出变量给自身赋值</p>
<p>变量给自身赋值，其逻辑类似于保持自身，直到某个条件触发后开始变化。恰好与锁存器的功能一致。</p>
<div>
<center>
<img src="image-20251124210523205.png" alt="image can't load." style="zoom:100%"> <br> if-else语句out=out赋值
</center>
</div>
<div>
<center>
<img src="image-20251124210659965.png" alt="image can't load." style="zoom:50%"> <br> case语句out = out赋值
</center>
</div></li>
</ul>
<p>参考本节的图片，也能发现不同语句综合出的电路不相同，if-else内涵顺序结构，其RTL是多个二选一选择器串连，case语句并行选择，只有一个ROM块。</p>
<h3 id="模块调用">模块调用</h3>
<p>类似于函数复用，不过C中通常是编译器来把所有相同的函数名定位到一个地址。而FPGA作为“电路语言”需要为每个模块分配不同的电路，即所谓的实例化。</p>
<p>假设有以下半加器模块：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> half_adder(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> in1,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> in2,</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> sum,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> count</span><br><span class="line">);</span><br><span class="line">    <span class="comment">//code block</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>如果想在其基础上设计全加器，只需要实例化两次（两个电路）：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> full_adder(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> in1,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> in2,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> cin,</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> sum,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> count</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">wire</span> h0_sum;</span><br><span class="line">    <span class="keyword">wire</span> h0_count;</span><br><span class="line">    <span class="keyword">wire</span> h1_sum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> count = (h0_count|h1_count);</span><br><span class="line">        </span><br><span class="line">    half_adder half_adder_inst0(</span><br><span class="line">        <span class="variable">.in1</span>(in1),</span><br><span class="line">        <span class="variable">.in2</span>(in2),</span><br><span class="line">        <span class="variable">.sum</span>(h0_sum),</span><br><span class="line">        <span class="variable">.count</span>(h0_count)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    half_adder half_adder_inst0(</span><br><span class="line">        <span class="variable">.in1</span>(cin),</span><br><span class="line">        <span class="variable">.in2</span>(h0_sum),</span><br><span class="line">        <span class="variable">.sum</span>(sum),</span><br><span class="line">        <span class="variable">.count</span>(h1_count)</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>只需要添加几个中间变量，如<code>wire h0_sum;</code>，就可以将某个实例的输出给到另一个输入。</p>
<h2 id="仿真程序">仿真程序</h2>
<p>仿真程序称之为testbench，名称为tb_XX.v以做区分。</p>
<p>设计某个.v功能模块的仿真程序，类似于顶层模块对底层的调用，不预留参数而仅仅做实例化。通过reg、wire型变量引入inst中。</p>
<h3 id="初始化">初始化</h3>
<p>使用initial语句块设计输入量的初始状态，使用begin-end块涵盖多个语句。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    sys_clk = <span class="number">1</span>;</span><br><span class="line">    sys_rst_n &lt;= <span class="number">0</span>;</span><br><span class="line">    #<span class="number">20</span></span><br><span class="line">    sys_rst_n &lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>可使用如下语句输出调试信息：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$timeformat</span>(-<span class="number">9</span>,<span class="number">0</span>,<span class="string">&quot;ns&quot;</span>,<span class="number">6</span>);	<span class="comment">//时间格式：单位10^-9，小数点后0位，对应“ns”，至少输出6次</span></span><br><span class="line">    <span class="built_in">$monitor</span>(<span class="string">&quot;@time %t: out = %b.&quot;</span>,<span class="built_in">$time</span>,out);	<span class="comment">//输出某个时间值下，out量输出值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="赋值方式">赋值方式</h2>
<p>Verilog内分为阻塞赋值(“=”)与非阻塞赋值(“&lt;=”)。</p>
<ul>
<li>对于组合逻辑，常常使用阻塞赋值，使用时序逻辑时，采用非阻塞赋值。</li>
<li>同一always块中尽量用同一赋值方式。</li>
<li>同一always块尽量只修改一个变量。</li>
</ul>
<p>假设有以下代码，定义中间量in_reg，对比阻塞与非阻塞的差异：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> blocking(</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>			sys_clk,</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>			sys_rst_n,</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>	[<span class="number">1</span>:<span class="number">0</span>]	in,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">reg</span>		[<span class="number">1</span>:<span class="number">0</span>]	out</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">reg</span>	[<span class="number">1</span>:<span class="number">0</span>]	in_reg;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">always</span>@(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)</span><br><span class="line">	<span class="keyword">if</span>(sys_rst_n == <span class="number">1&#x27;b0</span>)<span class="keyword">begin</span></span><br><span class="line">		<span class="comment">//赋值处1</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">		<span class="comment">//赋值处2</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>仿真文件中，我们设置clk和in信号为阻塞赋值(同一时刻发生变化)，in信号和时钟沿完全同步变化：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb_blocking();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">reg</span>		sys_clk;</span><br><span class="line">	<span class="keyword">reg</span>		sys_rst_n;</span><br><span class="line">	<span class="keyword">reg</span>		[<span class="number">1</span>:<span class="number">0</span>]	in;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">wire</span>	[<span class="number">1</span>:<span class="number">0</span>]	out;	<span class="comment">//仿真引出wire量</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		sys_clk 	= <span class="number">1&#x27;b1</span>;</span><br><span class="line">		sys_rst_n	&lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		in			&lt;= <span class="number">2&#x27;b00</span>;</span><br><span class="line">		</span><br><span class="line">		#<span class="number">20</span></span><br><span class="line">		sys_rst_n	&lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">always</span> 	#<span class="number">10</span>	sys_clk = ~sys_clk;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">always</span>	#<span class="number">20</span>	in = &#123;<span class="built_in">$random</span>&#125;%<span class="number">4</span>;	<span class="comment">//此处若为非阻塞赋值，in会延迟clk一拍</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	blocking	blocking_inst0(</span><br><span class="line">	</span><br><span class="line">	<span class="variable">.sys_clk</span>(sys_clk),</span><br><span class="line">	<span class="variable">.sys_rst_n</span>(sys_rst_n),</span><br><span class="line">	<span class="variable">.in</span>(in),</span><br><span class="line">	</span><br><span class="line">	<span class="variable">.out</span>(out)</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="阻塞赋值">阻塞赋值</h3>
<p>对应的电路结构与触发沿没关系，只与输入电平变化有关系。<strong>对于同一个begin-end代码块内的语句，同一时刻只执行一条语句，其按先后顺序执行。</strong></p>
<p><strong>注：阻塞赋值不能操作wire型数据。</strong></p>
<p>对于如下代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">   a = b+<span class="number">1</span>;</span><br><span class="line">   b = a+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><strong>对应的电路在计算完a值之后计算下一个b值，右侧数值变化时左侧立刻变化。</strong></p>
<p>本节头部的模块中，若赋值处分别为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">in_reg 	= 	<span class="number">2</span>‘b00;</span><br><span class="line">out		=	<span class="number">2</span>‘b00;</span><br><span class="line"></span><br><span class="line">in_reg 	= 	in;</span><br><span class="line">out		=	in_reg;</span><br></pre></td></tr></table></figure>
<p>其RTL电路为D触发器。</p>
<div>
<center>
<img src="image-20251125233723518.png" alt="image can't load." style="zoom:55%"> <br> always块内阻塞赋值RTL
</center>
</div>
<p>仿真波形如下：</p>
<div>
<center>
<img src="image-20251126010426003.png" alt="image can't load." style="zoom:75%"> <br> 阻塞赋值RTL
</center>
</div>
<p>显然，in_reg和out之间并无延迟，数据同步变化。</p>
<h3 id="非阻塞赋值">非阻塞赋值</h3>
<p>非阻塞赋值对应电路通常与<strong>时钟沿</strong>有关，只有在触发沿的时刻才进行非阻塞赋值。同一个begin-end块中的语句并行执行，上一句的值改变仅会影响下一拍的输入。</p>
<p><strong>注：非阻塞赋值只能对reg量赋值，用于always和initial语句中，不可用于assign语句。</strong></p>
<p>对于同样的代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">   a &lt;= b+<span class="number">1</span>;</span><br><span class="line">   b &lt;= a+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>赋值开始时：计算语句右侧值</li>
<li>赋值结束时：更新左侧值，即T时刻上升沿时a的变化情况不影响计算b的值，会体现到到下一拍</li>
</ul>
<p>本节头部的模块中，若赋值处分别为非阻塞赋值：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">in_reg 	&lt;= 	<span class="number">2</span>‘b00;</span><br><span class="line">out		&lt;=	<span class="number">2</span>‘b00;</span><br><span class="line"></span><br><span class="line">in_reg 	&lt;= 	in;</span><br><span class="line">out		&lt;=	in_reg;</span><br></pre></td></tr></table></figure>
<p>其RTL电路为两个D触发器串联，从电路更容易理解滞后一拍：</p>
<div>
<center>
<img src="image-20251126000431448.png" alt="image can't load." style="zoom:50%"> <br> 非阻塞赋值RTL
</center>
</div>
<div>
<center>
<img src="image-20251126005538068.png" alt="image can't load." style="zoom:75%"> <br> 非阻塞赋值仿真波形
</center>
</div>
<p>RTL电路中in_reg和out之间多出一个上升沿D触发器，因此输出滞后一拍。查看<a href="#D触发器">D触发器</a>。</p>
<h1 id="附录">附录</h1>
<p>阻塞非阻塞赋值语句综合后的差异为一个D触发器，触发方式为边沿触发。</p>
<p>从背景上说，触发器的目的是增加电路“状态”，因为组合逻辑电路能传输信号–输出跟随输入变化，永远只反映现在的状态，即电路输出与上一时刻“状态”无关，</p>
<p>以单一的与、或、非门电路为例，其当前的输入直接影响当前的输出。而“状态”的前提是记忆，或者说保持，其中最简单的记忆电路是两个反相器串联：</p>
<div>
<center>
<img src="image-20251130235512504.png" alt="image can't load." style="zoom:50%"> <br> 保持电路
</center>
</div>
<p>以上电路：</p>
<ul>
<li>V<sub>in</sub>与V<sub>out</sub>同相</li>
<li>V<sub>in</sub>的值取决于上一拍状态</li>
</ul>
<p>假设，首个反相器输出Q，则第二个输出Q
<sup>’</sup>。其端口电压传输特性如下，三个工作点0(a)、1(c)和亚稳态(b)，稳定在a、c两点。</p>
<div>
<center>
<img src="image-20251201000949737.png" alt="image can't load." style="zoom:50%"> <br> 反相器输出特性
</center>
</div>
<h2 id="sr触发器">SR触发器</h2>
<p>在具备保持功能的反相器电路基础上，但其缺少外部输入。将非门替换为与非门或者或非门可增加一个输入量，如图a，当v<sub>11</sub>=v<sub>12</sub>=0时，与上图一致。</p>
<blockquote>
<p>如果不用与非门替换反相器，则在改变数值时，需要断开上下两部分连接，并改变数据后重新连接</p>
</blockquote>
<div>
<center>
<img src="image-20251201001428537.png" alt="image can't load." style="zoom:50%"> <br> SR触发器或非门电路
</center>
</div>
<p>按照图b进行符号定义，对于或非门，1信号为决定信号(与门0信号为决定信号)。因此有以下真值表：</p>
<table>
<thead>
<tr>
<th style="text-align: center;">R<sub>D</sub></th>
<th style="text-align: center;">S<sub>D</sub></th>
<th style="text-align: center;">Q<sup>n+1</sup></th>
<th style="text-align: center;">Q’<sup>n+1</sup></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">Q<sup>N</sup></td>
<td style="text-align: center;">Q’<sup>N</sup></td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0 <sup>*</sup></td>
<td style="text-align: center;">0<sup>*</sup></td>
</tr>
</tbody>
</table>
<p>*：当R<sub>D</sub>、S<sub>D</sub>同时为1时，能输出最终的结果。错误出现在当11同时消失为00时，理论上Q和Q’将同时输出1，但由于竞争-冒险的情况，两个门电路传输时间并不总是相同，因此最终状态可能是Q=1,将下方门Q’拉低为0，也许反之。此同时切换为00的状态为不定态，因此不建议出现。</p>
<p>根据真值表，称其为Set-Reset触发器。另一种形式是与非门电路，其R<sub>D</sub>’和S<sub>D</sub>’低电平有效(0为决定信号)，两者不能同为0。</p>
<p>再进一步，此时R、S信号在部分时刻影响输出，在输入端R、D增加与非门的Load信号，则有：</p>
<div>
<center>
<img src="image-20251201112507974.png" alt="image can't load." style="zoom:50%"> <br> SR同步电平触发器
</center>
</div>
<p>(a)图后端为R<sub>D</sub>’、S<sub>D</sub>’有效的SR触发器，增设前端的与非门后输入反相：</p>
<ul>
<li>CLK = 1时，电路为实时跟随的SR触发器</li>
<li>CLK = 0时，输入端变化被屏蔽</li>
</ul>
<p>再进一步，后端SR触发器若接异步输入（低电平有效），可同时具备同步异步功能。</p>
<div>
<center>
<img src="image-20251201113020891.png" alt="image can't load." style="zoom:50%"> <br> SR同步异步电平触发器
</center>
</div>
<p>电平触发器问题是，不易使得CLK=1时恰好SR输入变化。因此，在其基础上使用两个相同的SR触发器串联，但使用反相的装载信号CLK。</p>
<div>
<center>
<img src="image-20251201115138968.png" alt="image can't load." style="zoom:50%"> <br> SR主从触发器
</center>
</div>
<ul>
<li>CLK=1时，主触发器任意变化，从触发器屏蔽输入</li>
<li>CLK=0时，主触发器根据最后时刻SR输出并保持Q<sub>m</sub>，Q<sub>m</sub>作为从触发器的输入，输出稳定的Q值。</li>
</ul>
<p>因此，整个电路从时刻跟随SR变为仅在CLK下降沿时刻变化。其真值表如下：</p>
<table>
<thead>
<tr>
<th style="text-align: center;">CLK</th>
<th style="text-align: center;">S</th>
<th style="text-align: center;">R</th>
<th style="text-align: center;">Q<sup>N+1</sup></th>
<th style="text-align: center;">Q’<sup>N+1</sup></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">X</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">Q<sup>N</sup></td>
<td style="text-align: center;">Q’<sup>N</sup></td>
</tr>
<tr>
<td style="text-align: center;">↓</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">Q<sup>N</sup></td>
<td style="text-align: center;">Q’<sup>N</sup></td>
</tr>
<tr>
<td style="text-align: center;">↓</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">↓</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">↓</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1*</td>
<td style="text-align: center;">1*</td>
</tr>
</tbody>
</table>
<p>触发方式变为下降沿触发，但仍然受限于SR=0的约束条件。由此引出JK触发器。</p>
<h2 id="d触发器">D触发器</h2>
<p>上方的SR触发器有两个主要特点：</p>
<ul>
<li>具备保持功能（输入为00时）</li>
<li>CLK可决定分段加载SR的值</li>
</ul>
<p>但也存在以下问题：</p>
<ol type="1">
<li>受限于约束条件SR=0，否则可能出现不定态</li>
<li>CLK=1时，Q仍根据SR值时刻变化</li>
</ol>
<p><strong>为解决以上问题1，提出由同一信号决定SR，原始信号+反相信号。此方式SR恒等于0，但弊端是SR不可同时为0，即不具备保持功能。</strong></p>
<div>
<center>
<img src="image-20251201113930888.png" alt="image can't load." style="zoom:50%"> <br> 电平触发D触发器
</center>
</div>
<p>其真值表简化为：</p>
<table>
<thead>
<tr>
<th style="text-align: center;">CLK</th>
<th style="text-align: center;">D</th>
<th style="text-align: center;">Q<sup>N+1</sup></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">Q<sup>N</sup></td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>参考主从SR触发器，可设计边沿触发的D触发器，如下为CLK上升沿触发D触发器：</p>
<ul>
<li>CLK=0，前开后闭</li>
<li>CLK=1，前闭后开</li>
</ul>
<div>
<center>
<img src="image-20251201124709370.png" alt="image can't load." style="zoom:50%"> <br> 边沿触发D触发器
</center>
</div>
<p>其电路符号为：</p>
<div>
<center>
<img src="image-20251201125318946.png" alt="image can't load." style="zoom:75%"> <br> 上升触发D触发器电路符号
</center>
</div>
<p><strong>边沿D触发器、主从SR触发器、主从JK触发器的性质都是在下一拍反映上一拍的数据，“记忆”功能体现滞后一拍的特性。</strong></p>
<h2 id="jk触发器">JK触发器</h2>
<p>基于主从SR触发器，为解决SR恒为0的约束条件，提出将从触发器输出分别接入主触发器输入端，称为JK触发器。</p>
<div>
<center>
<img src="image-20251201120750531.png" alt="image can't load." style="zoom:50%"> <br> JK主从触发器
</center>
</div>
<p>其有以下特点：</p>
<ul>
<li>下降沿有效</li>
<li>Q<sup>N</sup>影响从触发器Q<sup>N+1</sup></li>
<li>Q<sup>N</sup>影响主触发器输入，进而影响Q<sub>m</sub><sup>N+1</sup></li>
</ul>
<p>假设电路处于稳定状态Q<sup>N</sup>=1，若此时JK=1，则输入端JK与Q<sup>N</sup>和Q’<sup>N</sup>分别相与等效（主触发器等效为SR电平触发器）后的输入为01，Q<sup>N+1</sup>被复位。若Q<sup>N</sup>=0，则输出被置1。即：</p>
<ol type="1">
<li><p>Q<sup>N</sup>=1，屏蔽置位端J，否则屏蔽复位端Ｋ</p></li>
<li><p>JK主从等效于去除约束后的SR主从</p></li>
</ol>
<p><strong>根据第1点，显然同一时钟周期内，Qm最多翻转一次。</strong></p>
<p>仍以Q<sup>N</sup>=1为例，主触发器屏蔽J后的等效JK仅有两种情况00、01，即Q<sub>m</sub><sup>N+1</sup>保持或输出0，因此Q<sup>N+1</sup>可能保持或翻转。</p>
<blockquote>
<p>因此，如果在CLK=1时，JK输入保持，则只观察下降沿时JK的值。若JK未被屏蔽的信号出现翻转，则输出Q<sup>N+1</sup>必定翻转：</p>
<ul>
<li>Q<sup>N</sup>=1时，K翻转</li>
<li>Q<sup>N</sup>=0时，J翻转</li>
</ul>
</blockquote>
<div>
<center>
<img src="image-20251201020744383.png" alt="image can't load." style="zoom:75%"> <br> JK触发器输出
</center>
</div>
<h1 id="参考资料">参考资料</h1>
<p>[1] <a href="https://www.bilibili.com/video/BV139tweXEzT/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&amp;vd_source=5465b0f4790ebae45362caa6519f3b79">野火
FPGA ZYNQ-7000系列FPGA Verilog开发实战指南 | 哔哩哔哩</a></p>
<p>[2] <a href="https://www.bilibili.com/video/BV15V4y1c7wa?spm_id_from=333.788.videopod.episodes&amp;vd_source=5465b0f4790ebae45362caa6519f3b79&amp;p=26">王红《数字电子技术基础》
触发器逻辑功能的分类 | 哔哩哔哩</a></p>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p><em>经历是过程，经验是目的。</em></p>
</blockquote>
]]></content>
      <categories>
        <category>电子类</category>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-03-栈与队列</title>
    <url>/2025/09/15/DS-03-Stack_and_Queue/</url>
    <content><![CDATA[<p>本博文基于C语言数据结构，解释队列存储结构与增删改查思路。</p>
<span id="more"></span>
<p>代码:<a href="https://github.com/MicroPrism/MicroPrism.github.io/tree/main/code/2025-08-10-DS-02-Linear_List/">点击查阅</a></p>
<h1 id="栈lifo">栈（LIFO）</h1>
<p>栈（stack）是限定<strong>仅在表尾进行插入或删除操作的线性表</strong>。因此对栈来说，表尾端称为栈顶（top），表头端称为栈底（bottom）。不含元素的空表称为空栈。</p>
<blockquote>
<p>类似于链表，无节点（头节点除外）时称为空链表。</p>
</blockquote>
<p>每当新元素插入时，存入栈顶，也称压栈。退栈的第一个元素也应为栈顶元素，其逻辑为先进后出（Last
In First
Out）原则，简称LIFO。<strong>因此，栈本质上是一种操作固定的特殊顺序表。</strong></p>
<div>
<center>
<img src="1_stack_memory.jpg" alt="image can't load." style="zoom:25%"> <br> 静态栈存储结构
</center>
</div>
<h2 id="顺序栈与链式栈">顺序栈与链式栈</h2>
<p>栈类似于线性表，因此其存储结构也类似，比如静态/动态分配固定大小的顺序栈（元素在物理地址上连续）以及动态分配节点地址的链式栈（节点在物理地址上不连续）。</p>
<p>参阅顺序表一文：<a href="https://microprism.github.io/2025/08/10/DS-02-Linear_List/#链表">数据结构-02-线性表
| Young’s Blog</a></p>
<div>
<center>
<img src="2_stack_type.jpg" alt="image can't load." style="zoom:25%"> <br> 静态栈存储结构
</center>
</div>
<p>代码定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建Stack类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> STACK == 0		<span class="comment">/* 动态分配data大小 */</span></span></span><br><span class="line">	ElemType* data;</span><br><span class="line">	<span class="type">int</span> top;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> STACK == 1	<span class="comment">/* 仅分配单个元素大小 */</span></span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stack</span>* <span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @brief 初始化栈 */</span></span><br><span class="line">Stack* <span class="title function_">initStack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	Stack* s = (Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));	<span class="comment">/* 动态分配栈变量内存 */</span></span><br><span class="line">	<span class="keyword">if</span> (s == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> STACK == 0 <span class="comment">/* 动态分配栈地址，内部数据地址 */</span></span></span><br><span class="line">	s-&gt;data = (ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) * MAXSIZE);</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;top = <span class="number">-1</span>;	<span class="comment">/* 栈顶元素设置为-1 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> STACK == 1 </span></span><br><span class="line">	s-&gt;data = <span class="number">0</span>;	<span class="comment">/* 链式栈头 */</span></span><br><span class="line">	s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="空栈判断与栈顶取值">空栈判断与栈顶取值</h2>
<p>栈的增删操作为压栈、出栈，改查与顺序表/链表基本一致。</p>
<p>如果栈非链式栈，则压栈操作需要判断栈是否满（满时报告异常提示）。而对于几种类型，出栈均需要判断栈是否为空（空时报告异常）。</p>
<ul>
<li><p>空栈</p>
<p>通过判断Top索引值是否为预设负值，或者next是否为NULL。</p></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* @brief 检验是否为空栈 </span></span><br><span class="line"><span class="comment">   @param 判断stack中top值是否为初始值 </span></span><br><span class="line"><span class="comment">   @retval 1，空栈；0，非空*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Stack* s)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(s);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> STACK == 0</span></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;top == <span class="number">-1</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> STACK == 1</span></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Empty Stack.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>栈顶取值</p>
<p>对于非空静态栈，直接取出data数据区内top索引处的数据；</p>
<p>对于链式栈，则直接取头指针的next数据（LIFO特性导致栈顶元素一定在前）。</p></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* @brief 获取栈顶元素</span></span><br><span class="line"><span class="comment">   @param s，指针，指向待操作栈地址；</span></span><br><span class="line"><span class="comment">		  e，指针，指向待出栈元素；</span></span><br><span class="line"><span class="comment">   @retval 1，获取栈顶元素；0，空栈*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getTop</span><span class="params">(Stack* s, ElemType* e)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(s);</span><br><span class="line">	<span class="type">int</span> result = isEmpty(s);</span><br><span class="line">	<span class="keyword">if</span> (result == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> STACK == 0</span></span><br><span class="line">	*e = s-&gt;next[s-&gt;top];</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> STACK == 1</span></span><br><span class="line">	*e = s-&gt;next-&gt;data;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="压栈出栈">压栈出栈</h2>
<ul>
<li><p>压栈</p>
<p>当存储新数据时：</p>
<ol type="1">
<li>对于顺序表结构的栈示意图，向Top索引处填充，并增加Top索引值；</li>
<li>对于链式表结构的栈，创建节点并使用头插法插在头节点之后（当然尾插法也可以，但需要保证操作一致性。头插法的优势是栈顶在前，时间复杂度O(1)，而尾插法为O(n)。</li>
</ol></li>
</ul>
<div>
<center>
<img src="1_stack_memory.jpg" alt="image can't load." style="zoom:25%"> <br> 静态栈存储结构
</center>
</div>
<ul>
<li><p>出栈</p>
<p>当弹出新数据时：</p>
<ol type="1">
<li>对于顺序表结构的栈示意图，提取Top索引处值，再减小Top索引值；</li>
<li>对于链式表结构的栈，提取hdr-&gt;next处元素值，修改链表结构，再释放该节点；</li>
</ol></li>
</ul>
<h1 id="队列fifo">队列（FIFO）</h1>
<p>队列（Queue）是先进先出（First In First
Out）线性表，只允许再表的一端进行插入，在另一端删除。队列中允许插入的队尾端为rear，允许删除的队头为front。</p>
<p align="center">
————————— 暂时断更 —————————
</p>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p><em>近水楼台先得月，向阳花木易为春。–《断句》</em></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机类</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-02-线性表</title>
    <url>/2025/08/10/DS-02-Linear_List/</url>
    <content><![CDATA[<p>本博文基于C语言数据结构定义时间、空间复杂度，补充等差数列、累加和数列、等比数列等数学基础。解释顺序表、链表的增删改查与效率提升思路。</p>
<span id="more"></span>
<p>代码:<a href="https://github.com/MicroPrism/MicroPrism.github.io/tree/main/code/2025-08-10-DS-02-Linear_List/">点击查阅</a></p>
<h1 id="定义">定义</h1>
<blockquote>
<p>由n(n&gt;=0)个数据特性相同的元素构成的有限序列。</p>
</blockquote>
<p>长度定义：线性表中元素个数定义为长度，n=0时称空表</p>
<p>非空线性表特性：</p>
<ul>
<li>存在唯一一个“第一个”数据元素</li>
<li>存在唯一一个“最后一个”数据元素</li>
<li>除第一个元素外，每个元素只有一个前驱</li>
<li>除最后一个元素外，每个元素只有一个后继</li>
</ul>
<h1 id="顺序表">顺序表</h1>
<p>用一组连续的内存单元依次存储线性表各个元素，逻辑上相邻的元素在物理存储空间上也是连续的。</p>
<blockquote>
<p>算法的目的也仅仅是针对某种数据结构高效的增删改查</p>
</blockquote>
<h2 id="存储结构">存储结构</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE = 100;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType; <span class="comment">//便于后续移植更改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initList</span><span class="params">(SeqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    L-&gt;length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加元素">添加元素</h2>
<p>可以将length作为数组索引。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">appendElem</span><span class="params">(SeqList *L, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length &gt;= MAXSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;顺序表已满\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;data[L-&gt;length] = e;</span><br><span class="line">    L-&gt;length ++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历元素">遍历元素</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">listElem</span><span class="params">(SeqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; L-&gt;length ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,L-&gt;data[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入元素">插入元素</h2>
<p>顺序表插入数据需要移动目标位置处后的所有元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertElem</span><span class="params">(SeqList *L,<span class="type">int</span> pos, ElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( L-&gt;length &gt;= MAXSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//表满</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; MAXSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//插入位置出错    </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= L-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= L-&gt;length - <span class="number">1</span>; i&gt;= pos - <span class="number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;data[i+<span class="number">1</span>] = L-&gt;data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        L-&gt;data[pos - <span class="number">1</span>] = *e;</span><br><span class="line">        L-&gt;length ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除元素">删除元素</h2>
<p>顺序表删除数据需要移动目标位置处后的所以元素，但是最后的元素不需清0。因为length-1之后，已经不会再访问该值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deleteElem</span><span class="params">(SeqList *L,<span class="type">int</span> pos, ElemType *e)</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == L-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//空表</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( pos &lt; <span class="number">0</span> || pos &gt; MAXSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//位置错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *e = L-&gt;data[pos<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(pos &lt; L-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=pos; i&lt; L-&gt;length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;data[i<span class="number">-1</span>] = L-&gt;data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     L-&gt;length--;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找元素">查找元素</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findElem</span><span class="params">(SeqList *L,ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="number">0</span> == L-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;L-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;data[i] == e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>; <span class="comment">//位置从1开始，索引从0开始</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态内存">动态内存</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *data; <span class="comment">//使用指针动态管理空间</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SeqList *<span class="title function_">initList</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SeqList *L = (SeqList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqList));<span class="comment">//结构体指针</span></span><br><span class="line">    L-&gt;data = (Elemype *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType)*MAXSIZE);<span class="comment">//分配数组</span></span><br><span class="line">    L-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="链表">链表</h1>
<h2 id="存储结构-1">存储结构</h2>
<p>一组任意的存储单元存储线性表的数据元素，可以是连续的，也可以是不连续的。</p>
<blockquote>
<p>相对于顺序表，链表村粗的存储单位未必连续。</p>
</blockquote>
<p>每个数据元素除去本身的信息外，还需要存储一个指示后继信息。数据元素称为数据域，后继位置称为指针域，两部分信息共同称为节点。</p>
<p>n个节点组成的线性序列，称为链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span> <span class="comment">//下一个节点地址</span></span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure>
<h2 id="单链表">单链表</h2>
<h3 id="初始化">初始化</h3>
<p>单链表初始化，即初始化一个头节点。后续的节点则不断插入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Node *<span class="title function_">initList</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *head = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    head-&gt;data = <span class="number">0</span>;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入元素-1">插入元素</h3>
<ul>
<li><p>头插法：每次把数据插入在头节点之后</p>
<div>
<center>
<img src="1_HeaderInsert.jpg" alt="image can't load." style="zoom:100%"> <br> 头插链表
</center>
</div>
<p>该方法需要先将新节点链向下一个节点，再将头节点链向新节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertHead</span><span class="params">(Node *L, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = L-&gt;next; </span><br><span class="line">    L-&gt;next = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>尾插法</p>
<p>尾插法即插入在尾部，隐藏首先需要获取尾部节点。</p>
<div>
<center>
<img src="2_TailInsert.jpg" alt="image can't load." style="zoom:100%"> <br> 尾插链表
</center>
</div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Node *<span class="title function_">getTail</span><span class="params">(Node *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p = L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在参数节点后插入新节点，并返回新的尾节点</span></span><br><span class="line">Node *<span class="title function_">insertTail</span><span class="params">(Node *tail, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    tail-&gt;next = p;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>任意位置插入</p>
<div>
<center>
<img src="3_Insert.jpg" alt="image can't load." style="zoom:100%"> <br> 任意位置插入
</center>
</div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertNode</span><span class="params">(Node *L, <span class="type">int</span> pos,ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p = L;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; pos<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p= p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="comment">//链表长度不足</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//此处可以做一些其他操作，比如直接插在尾部</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node *new = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    new-&gt;data = e;</span><br><span class="line">    new-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = new;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>遍历</p>
<p>链表遍历不需要知道节点个数，而是以节点是否为NULL为条件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">listNode</span><span class="params">(Node *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="删除元素-1">删除元素</h3>
<p>对于链表，需要找到待删除的节点位置，随后释放内存空间，防止造成内存泄漏。</p>
<p>但在节点删除时，需要注意最后一个节点不能被删除，<code>p-&gt;next</code>为空代表链表结束。</p>
<div>
<center>
<img src="4_deleteNode.jpg" alt="image can't load." style="zoom:100%"> <br> 删除节点
</center>
</div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deleteNode</span><span class="params">(Node* L,<span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p = L; <span class="comment">//头节点，从头节点之后的节点才称为第一个，第二个</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//p指向待删除节点的前驱</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;pos - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//p-&gt;next待删除节点为NULL</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;位置错误\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//q指向待删除节点</span></span><br><span class="line">    Node *q = p-&gt;next;</span><br><span class="line">    <span class="comment">//删除节点的前驱指向删除节点的后继</span></span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要删除全部链表，可从前向后删除。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deleteNodeList</span><span class="params">(Node *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p = L;</span><br><span class="line">    Node *q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实际应用">实际应用</h3>
<h4 id="例题1查找节点">例题1:查找节点</h4>
<p>已知一个带有表头节点的单链表，节点结构为<code>data + link</code>。假设该链表只给出了头指针
list
。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第 k
个位置上的结点（k 为正整数）。若查找成功，算法输出该节点的 data
域的值，并返回 1 ；否则，只返回 0 。要求：</p>
<ul>
<li>描述算法的基本思想；</li>
<li>描述算法的详细实现步骤；</li>
<li>根据设计思想和实现步骤，采用程序设计语言描述算法（使用 C 、C++、或
Java语言实现），关键之处请给出简要注释</li>
</ul>
<p><strong>解题思路：</strong>使用双指针（快慢指针）。即快指针走k步之后，开始同步移动fast和slow指针，当fast指向NULL节点时，slow即为目标指针。</p>
<div>
<center>
<img src="5_doublePointer_gap_k.jpg" alt="image can't load." style="zoom:15%"> <br> 快慢指针查值
</center>
</div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findNodeFS</span><span class="params">(Node *L, <span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *fast = L -&gt; next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">NULL</span>) <span class="comment">//链表长度小于k</span></span><br><span class="line">        &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;error 01: list length less than k&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node *slow = L-&gt;next; <span class="comment">//记录慢指针</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast -&gt; next;</span><br><span class="line">        slow = slow -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;success: expect data is %d\n&quot;</span>,slow-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题2合并链表">例题2:合并链表</h4>
<p>假定采用带头节点的单链表保存单词，当两个单词有相同的后缀时，则可共享相同的后缀存储空间，例如，“ending”和“being”的存储映像如下图所示。</p>
<div>
<center>
<img src="6_doublePointer_verge_List.jpg" alt="image can't load." style="zoom:15%"> <br> 合并尾部结点
</center>
</div>
<p>设 str1 和 str2
分别指向两个单词所在单链表的头节点，链表结点结构为<code>data+next</code>请设计一个时间上尽可能高效的算法，找出由
str1 和 str2 所指向两个链表共同后缀的起始位置（如图字符 i 所在结点的位置
p）。要求：</p>
<ul>
<li>描述算法的基本设计思想；</li>
<li>根据设计思想，采用 C 或 C++ 或 Java 语言描述，关键之处给出注释</li>
<li>说明你所设计算法的时间复杂度</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>已知尾部n个字符相等，则需要两个链表先对齐，即长链表后移gap个字节。随后，快慢指针同时移动，直到找到相同的data值。最后将短链表链向长链表的尾缀，并释放短链表后续的结点。</p>
<div>
<center>
<img src="6_doublePointer_verge_List_re.jpg" alt="image can't load." style="zoom:15%"> <br> 思路
</center>
</div>
<ul>
<li>寻找相同data时，需要记录上一个节点，以便链向新节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题2: 合并单词链表，例如being 和ending </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vergeListWithChar</span><span class="params">(Node* list1, Node* list2)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//输入链表为空</span></span><br><span class="line">	<span class="keyword">if</span> (list1 == <span class="literal">NULL</span> || list2 == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> list1_len = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> list2_len = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//计算链表1的长度</span></span><br><span class="line">	Node* fast = list1;</span><br><span class="line">	<span class="keyword">while</span> (fast != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fast = fast-&gt;next;</span><br><span class="line">		list1_len++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算链表2的长度</span></span><br><span class="line">	fast = list2;</span><br><span class="line">	<span class="keyword">while</span> (fast != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fast = fast-&gt;next;</span><br><span class="line">		list2_len++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算链表长度，并设定快慢指针值</span></span><br><span class="line">	Node* slow = fast;</span><br><span class="line">	<span class="type">int</span> gap = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (list1_len &gt; list2_len)</span><br><span class="line">	&#123;</span><br><span class="line">		fast = list1;</span><br><span class="line">		slow = list2;</span><br><span class="line">		gap = list1_len - list2_len;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		fast = list2;</span><br><span class="line">		slow = list1;</span><br><span class="line">		gap = list2_len - list1_len;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//移动快指针</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gap; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fast = fast-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历找到链表中的相同数据</span></span><br><span class="line">	Node* p = slow;</span><br><span class="line">	<span class="keyword">while</span> (fast-&gt;data != slow-&gt;data)</span><br><span class="line">	&#123;</span><br><span class="line">		p = slow;<span class="comment">//保存相同数值的上一节点</span></span><br><span class="line">		fast = fast-&gt;next;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//连接向相同值</span></span><br><span class="line">	p-&gt;next = fast; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//释放剩余节点</span></span><br><span class="line">	<span class="keyword">while</span> (slow != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p = slow;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题3过滤同值">例题3:过滤同值</h4>
<p>用单链表保存 n 个整数，结点的结构为 [data][link]，且|data| n(n
为正整数)。现要求设计一个时间复杂度尽可能高效的算法，对于链表中 data
的绝对值相等的节点，仅保留第一次出现的节点而删除其余绝对值相等的结点。例如，若给定单链表
head 如下：</p>
<div>
<center>
<img src="7_delete_same_node.jpg" alt="image can't load." style="zoom:15%"> <br> 操作事例
</center>
</div>
<p>要求：</p>
<ul>
<li>给出算法的基本设计思想。</li>
<li>使用 C 或 C++ 语言，给出单链表节点的数据类型定义。</li>
<li>根据设计思想，采用 C 或 C++ 语言描述算法，关键之处给出注释。</li>
<li>说明你所设计算法的时间复杂度和空间复杂度。</li>
</ul>
<p>解题思路：空间换时间</p>
<ul>
<li>已知链表节点内的data最大值小于链表长度n，可创建长度为n（或n+1）的空间作为判断数组，当某个值出现时索引值设为1。</li>
<li>当出现重复值时，将last_node-&gt;next指向current_node-&gt;next，以跳过重复节点。</li>
<li>刷新current_node节点</li>
<li>释放重复节点</li>
</ul>
<div>
<center>
<img src="7_delete_same_node_re.jpg" alt="image can't load." style="zoom:15%"> <br> 操作事例
</center>
</div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题3：删除链表中数值绝对值相同的节点,已知链表长度n</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteRepeatNode</span><span class="params">(Node* header, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	Node* p = header; <span class="comment">//使用current_node更合适</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//建立一个与数组长度相符的空间作为判断数组</span></span><br><span class="line">	<span class="type">int</span>* judgeArray = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (len + <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len + <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		judgeArray[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找值</span></span><br><span class="line">	p = header-&gt;next;</span><br><span class="line">	Node* last_node = <span class="literal">NULL</span>; <span class="comment">// 保存上一节点</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//绝对值首次出现，则标记</span></span><br><span class="line">		<span class="keyword">if</span> (judgeArray[<span class="built_in">abs</span>(p-&gt;data)] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			judgeArray[<span class="built_in">abs</span>(p-&gt;data)] = <span class="number">1</span>;</span><br><span class="line">			last_node = p; <span class="comment">//保存上一个节点</span></span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">//出现重复节点，则释放该节点</span></span><br><span class="line">		&#123;</span><br><span class="line">			last_node-&gt;next = p-&gt;next;  <span class="comment">//将重复值的前移节点链向重复节点的后一个节点</span></span><br><span class="line">			Node* tmp = p;		<span class="comment">// 待释放的重复节点</span></span><br><span class="line">			p = p-&gt;next;		<span class="comment">//更新p节点，不更新上一个节点q</span></span><br><span class="line">			<span class="built_in">free</span>(tmp); <span class="comment">//释放当前节点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(judgeArray);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题4反转链表">例题4:反转链表</h4>
<p>假设有以链表结构为：头节点+其他n个节点，每个节点为<code>data+next</code>格式，设计算法将链表内节点顺序反转。</p>
<div>
<center>
<img src="8_reverse_list.jpg" alt="image can't load." style="zoom:15%"> <br> 链表反转
</center>
</div>
<p>解题思路：</p>
<ul>
<li>使用三个指针指向顺序的三个数，当third指向NULL时，表明到达链表尾部</li>
<li>依次修改second节点的next指向，从指向下一个变为指向上一个</li>
<li>将源链表的头节点指向最后一个second节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题4：反转链表顺序</span></span><br><span class="line"><span class="comment">// @param: src - 输入初始链表</span></span><br><span class="line"><span class="comment">// @return: 成功返回0，异常返回其他值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">reverseList</span><span class="params">(Node* src)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//若链表节点数小于2(不含头节点)，则退出</span></span><br><span class="line">	<span class="keyword">if</span> (src == <span class="literal">NULL</span> || src-&gt;next == <span class="literal">NULL</span> || src-&gt;next-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Node* first = <span class="literal">NULL</span>;</span><br><span class="line">	Node* second = src-&gt;next;</span><br><span class="line">	Node* third = src-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//third为NULL时，second指向最后一个节点</span></span><br><span class="line">	<span class="keyword">while</span> (third != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		second-&gt;next = first;</span><br><span class="line">		first = second;</span><br><span class="line">		second = third;</span><br><span class="line">		third = third-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//连接最后一个节点</span></span><br><span class="line">	second-&gt;next = first;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//更新头节点</span></span><br><span class="line">	src-&gt;next = second;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题5删除中点">例题5:删除中点</h4>
<p>假设有以链表结构为：头节点+其他n个节点，每个节点为<code>data+next</code>格式，设计算法将链表内中间节点删除。</p>
<p>解题思路：</p>
<ul>
<li>使用快慢指针，slow每移动一个节点，fast移动两次</li>
<li>直到fast指向NULL或者fast-&gt;next指向NULL，则slow为待删除节点的前置节点</li>
</ul>
<div>
<center>
<img src="9_delete_middle_node.jpg" alt="image can't load." style="zoom:15%"> <br> 删除链表中间节点
</center>
</div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题5：删除链表中间节点</span></span><br><span class="line"><span class="comment">// @param: src - 输入初始链表</span></span><br><span class="line"><span class="comment">// @return: 成功返回0，异常返回其他值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteMiddleNode</span><span class="params">(Node* src)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (src == <span class="literal">NULL</span> || src-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置快慢指针初始值</span></span><br><span class="line">	Node* slow = src;</span><br><span class="line">	Node* fast = src-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//快指针移动两个节点，直到其或者其下一个节点为NULL</span></span><br><span class="line">	<span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Node* del = slow-&gt;next;</span><br><span class="line">	slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(del);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题6链表重排">例题6:链表重排</h4>
<p>设线性表L=(a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, … ,
a<sub>n-2</sub>, a<sub>n-1</sub>,
a<sub>n</sub>)采用带头节点的单链表保存，链表中的节点定义为data+next。</p>
<p>请设计一个空间复杂度为 O(1) 且时间上尽可能高效的算法，重新排列 L
中的各节点，得到线性表L’= (a<sub>1</sub>, a<sub>n</sub>, a<sub>2</sub>,
a<sub>n-1</sub>, a<sub>3</sub>, a<sub>n-2</sub>, …)。</p>
<p>解题思路：</p>
<ul>
<li>找到中间节点，并断开为两个链表</li>
<li>将后半链表倒序重排</li>
<li>两个链表交叉相连</li>
</ul>
<div>
<center>
<img src="10_reorder_list.jpg" alt="image can't load." style="zoom:15%"> <br> 链表交叉重排
</center>
</div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题6:重排链表节点交叉相连</span></span><br><span class="line"><span class="comment">// @param: src - 输入初始链表</span></span><br><span class="line"><span class="comment">// @return: 成功返回0，异常返回其他值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">reOrderList</span><span class="params">(Node* src)</span></span><br><span class="line">&#123;</span><br><span class="line">	Node* p = src;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span> || p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化快慢指针，寻找中间节点</span></span><br><span class="line">	Node* slow = p;</span><br><span class="line">	Node* fast = p-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//断开尾部链表</span></span><br><span class="line">	Node* tail_list = slow-&gt;next;</span><br><span class="line">	slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重排尾部链表</span></span><br><span class="line">	Node* first = <span class="literal">NULL</span>;</span><br><span class="line">	Node* second = tail_list;</span><br><span class="line">	Node* third = tail_list-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (third != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		second-&gt;next = first;</span><br><span class="line">		first = second;</span><br><span class="line">		second = third;</span><br><span class="line">		third = third-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//后半段链表首个节点tail_list</span></span><br><span class="line">	second-&gt;next = first;</span><br><span class="line">	tail_list = second;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//两个链表交叉重排，直到某段的下一个节点到尾部</span></span><br><span class="line">	p = src-&gt;next;</span><br><span class="line">	Node* q = tail_list;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Node* tmp = p-&gt;next;</span><br><span class="line">		p-&gt;next = q;</span><br><span class="line">		q = q-&gt;next;</span><br><span class="line">		p-&gt;next-&gt;next = tmp;</span><br><span class="line">		p = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将剩余的q连接至p的尾部(q剩余部分一定包含NULL</span></span><br><span class="line">    p-&gt;next = q;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而无论链表长度为奇数还是偶数，前半段的链表一定最先到达尾部NULL节点，因此只需要将new_p的next节点连接至剩余的p即可。</p>
<div>
<center>
<img src="10_reorder_list_link.jpg" alt="image can't load." style="zoom:15%"> <br> 偶数长度(情况1)与偶数长度(情况2)
</center>
</div>
<h2 id="单向循环链表">单向循环链表</h2>
<p>在单链表的基础上，尾节点的next不再指向NULL，而是指向链表中任意一个节点时，就构成了闭环。</p>
<blockquote>
<p>适用于单链表的printfList函数就不再适用，因为判断条件不再是cuurent_node-&gt;next
== NULL。同样的，删除链表的操作也需要预先将环断开。</p>
</blockquote>
<div>
<center>
<img src="11_cycle_list.jpg" alt="image can't load." style="zoom:15%"> <br> 循环链表
</center>
</div>
<p>如图列出10个节点的链表，也许在第10个节点next指向NULL，构成单向链表。也许会按照虚线所示指向某个前方节点，构成循环链表。</p>
<p>因此，在确定单向链表疑似存在环之后：</p>
<ol type="1">
<li>确定是否存在环</li>
<li>确定环的长度</li>
<li>找到环的入口(起始节点)</li>
</ol>
<p>针对以上三个目标引申出三个问题：</p>
<ol type="1">
<li><p>如何确定存在环路？–快慢指针</p>
<p>类比成小学数学的赛跑相遇问题，如果AB速度不同，则快着率先到达终点，否则一定会在途中某处相遇。因此问题就具现为快慢指针能否相遇</p>
<div>
<center>
<img src="11_cycle_list_is_cycle.jpg" alt="image can't load." style="zoom:15%"> <br> 有环终会相遇
</center>
</div></li>
<li><p>如何确定环的长度？</p>
<p>当确定存在环之后，从相遇节点起始，直至再次遇到相同节点移动的节点数</p></li>
<li><p>环的入口？–x+y = y+x</p>
<p>当确定环的长度后，再次适用快慢指针思路，起始点先走环长度x，再同步走y个长度，一定会在入口相遇。</p></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题7:判断是否是循环单链表，并且找到循环入口</span></span><br><span class="line"><span class="comment">// @param: src - 输入初始链表</span></span><br><span class="line"><span class="comment">// @return: 存在环，返回环的长度； 链表异常返回-1；链表无环返回-2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isCycleList</span><span class="params">(Node* src)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (src == <span class="literal">NULL</span> || src-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//源链表异常</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Node* fast = src;</span><br><span class="line">	Node* slow = src;</span><br><span class="line">	<span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)<span class="comment">/* fast与slow步进长度不同，当fast与slow有交叉时，证明存在环 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (slow == fast)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> siCycleLenth = <span class="number">1</span>; <span class="comment">/* 计算链表内环的长度 */</span></span><br><span class="line">			fast = fast-&gt;next;</span><br><span class="line">			<span class="keyword">for</span> (siCycleLenth = <span class="number">1</span>; fast != slow; siCycleLenth++)</span><br><span class="line">			&#123;</span><br><span class="line">				fast = fast-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> siCycleLenth;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-2</span>; <span class="comment">//未找到环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @param: src - 输入初始链表</span></span><br><span class="line"><span class="comment">// @return: 正常，返回起始节点地址； 异常，返回NULL</span></span><br><span class="line">Node* <span class="title function_">findStartNodeInCycle</span><span class="params">(Node* src,<span class="type">int</span> cycleLenth)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (src == <span class="literal">NULL</span> || src-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//源链表异常</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Node* fast = src;</span><br><span class="line">	Node* slow = src;</span><br><span class="line">	<span class="comment">/* fast指针向前便宜环个长度 */</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cycleLenth &amp;&amp; fast != <span class="literal">NULL</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fast = fast-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* slow与fast同步移动，直到相遇 */</span></span><br><span class="line">	<span class="keyword">while</span> (slow != fast &amp;&amp; fast != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		fast = fast-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要释放链表，需要增加以下函数断开环：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//释放循环链表</span></span><br><span class="line">Node* <span class="title function_">cutCycleList</span><span class="params">(Node* cycleStartNode)</span></span><br><span class="line">&#123;</span><br><span class="line">	Node* p = cycleStartNode;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != cycleStartNode)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完此函数后，返回指针为最后一个节点，p-&gt;next为NULL。</p>
<h2 id="双向链表">双向链表</h2>
<p>链式存储结构节点中只有一个指向后继的指针，查找节点的直接前驱，必须从表头出发，时间复杂度为O(n)。</p>
<p>因此为克服单向性的特点，提出双向链表，即prev和next。</p>
<div>
<center>
<img src="12_double_list.jpg" alt="image can't load." style="zoom:15%"> <br> 双向链表
</center>
</div>
<h3 id="添加元素-1">添加元素</h3>
<ul>
<li><p>头插法</p>
<p>相对于单链表，在处理时额外考虑链接前一个节点。</p>
<ol type="1">
<li>优先将下一节点的前置节点prev连接至新节点（也不是必须这么干，但逻辑关系要正确）</li>
<li>将新节点的next连接向头节点的下个节点</li>
<li>将头节点next连接至新节点</li>
<li>新节点prev链接至为头节点</li>
</ol>
<div>
<center>
<img src="12_double_list_insert_header.jpg" alt="image can't load." style="zoom:15%"> <br> 双向链表头插法
</center>
</div></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以头插法插入节点,带值</span></span><br><span class="line">Node* <span class="title function_">insertHeaderWithElem</span><span class="params">(Node* header, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">	Node* p = header;</span><br><span class="line">	Node* m = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	<span class="keyword">if</span> (m == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	m-&gt;data = e;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> EXAMPLE &gt;= 8 		<span class="comment">//EXAMPLE = 8 表示双向链表</span></span></span><br><span class="line">	<span class="comment">/* 链接prev节点 */</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;next-&gt;prev = m;</span><br><span class="line">	&#125;</span><br><span class="line">	m-&gt;prev = header;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	m-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = m;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>尾插法</p>
<p>尾插法只需要将新节点的prev连接至原有的尾节点，其他与单链表一致。</p>
<div>
<center>
<img src="12_double_list_insert_tailer.jpg" alt="image can't load." style="zoom:15%"> <br> 双向链表尾插法
</center>
</div></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以尾插法插入节点,带值</span></span><br><span class="line">Node* <span class="title function_">insertTailWithElem</span><span class="params">(Node* header, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">	Node* p = header;</span><br><span class="line">	<span class="comment">/* 找到尾节点 */</span></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Node* m = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	<span class="keyword">if</span> (m == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> EXAMPLE &gt;= 8</span></span><br><span class="line">	m-&gt;prev = p;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	m-&gt;data = e;</span><br><span class="line">	m-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;next = m;</span><br><span class="line">	<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>任意节点</p>
<p>任意节点插入元素类似于头插法，只需要提前找到目标位置。</p></li>
</ul>
<h3 id="删除节点">删除节点</h3>
<p>预想删除节点，即：</p>
<ul>
<li><p>找到目标位置的前一个节点</p></li>
<li><p>将待删除的节点的后继节点（非空）prev连接至前一节点</p></li>
<li><p>释放节点</p>
<div>
<center>
<img src="12_double_list_delete_node.jpg" alt="image can't load." style="zoom:15%"> <br> 双向链表删除节点
</center>
</div></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除指定位置的节点</span></span><br><span class="line">Node* <span class="title function_">deleteNode</span><span class="params">(Node* L, <span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">	Node* p = L;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pos - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Node* q = p-&gt;next;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> EXAMPLE &gt;= 8 </span></span><br><span class="line">	q-&gt;next-&gt;prev = p; <span class="comment">/* 将下一节点的prev链接至前一节点 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	p-&gt;next = q-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实际应用-1">实际应用</h3>
<p>例题1:已知头指针 h
指向一个带头节点的非空单循环链表，节点结构为data+next，其中p是尾指针，q是临时指针，要删除链表的第一个元素，正确的代码为：</p>
<ul>
<li>单向链表</li>
</ul>
<p>常规情况下，如下代码即可完成功能：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">q = h-&gt;next;</span><br><span class="line">h-&gt;next = q-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure>
<div>
<center>
<img src="13_delete_node_in_cycle_1.jpg" alt="image can't load." style="zoom:15%"> <br> 单向链表/非单节点自循环链表
</center>
</div>
<p>但显然，题干为循环链表，可能出现待删除节点自循环的情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">q = h-&gt;next;</span><br><span class="line">h-&gt;next = q-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(q == p)  <span class="comment">/* 考虑待删除节点是否是尾指针 */</span> </span><br><span class="line">&#123;</span><br><span class="line">    h-&gt;next = h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure>
<div>
<center>
<img src="13_delete_node_in_cycle_2.jpg" alt="image can't load." style="zoom:15%"><!-- alt内为提示词--> <br> 单节点自循环链表
</center>
</div>
<h1 id="总结">总结</h1>
<table style="width:100%;">
<colgroup>
<col style="width: 7%">
<col style="width: 57%">
<col style="width: 34%">
</colgroup>
<thead>
<tr>
<th></th>
<th style="text-align: center;">顺序表</th>
<th style="text-align: center;">链表</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储空间</td>
<td style="text-align: center;">预先分配，可能闲置或溢出</td>
<td style="text-align: center;">动态分配</td>
</tr>
<tr>
<td>存储密度</td>
<td style="text-align: center;">1，无需额外存储表示节点逻辑关系</td>
<td style="text-align: center;">小于1</td>
</tr>
<tr>
<td>存取元素</td>
<td style="text-align: center;">随机存取，按位置时间复杂度为O(1)</td>
<td style="text-align: center;">顺序存取，按位置时间复杂度为O(n)</td>
</tr>
<tr>
<td>插入删除</td>
<td style="text-align: center;">平均移动表内一半元素，时间复杂度O(n)</td>
<td style="text-align: center;">确定位置时，时间复杂度O(1)</td>
</tr>
<tr>
<td>适用情况</td>
<td style="text-align: center;">表长变化不大，且能预估变化范围；<br>大多数进行随机访问，而非插入删除；</td>
<td style="text-align: center;">长度变化大；<br>经常进行插入删除；</td>
</tr>
</tbody>
</table>
<p>例如常见的RTOS任务调度、TCP状态切换常用链表管理各个TCB控制块、消息缓存区，而具体的UART、CAN等消息接收区使用顺序表。</p>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p><em>读书不觉已春深，一寸光阴一寸金。–《白鹿洞二首·其一》</em></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机类</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-01-引言</title>
    <url>/2025/08/09/DS-01-Introduction/</url>
    <content><![CDATA[<p>本博文基于C语言的内容引入数据结构的时间、空间复杂度概念，并补充等差数列、累加和数列、等比数列等数学理论。</p>
<span id="more"></span>
<p>数据结构可以拆分为两个内容，即数据+结构。</p>
<h1 id="是什么">是什么？</h1>
<ul>
<li><p><strong>首先，数据从哪儿来？到哪儿去？</strong></p>
<p>数据从生活各处中来，而目的是用数据驱动业务。</p></li>
<li><p><strong>结构又是什么？</strong></p>
<p>即数据的组织形式，比如数组、比如链表。</p>
<p><strong>在特定的情境下，以往所用的数据类型无法基于需求合理地组织数据，此时需要自己设计一套新的数据组织形式来解决问题。</strong></p>
<p><strong>数据结构是一种存储、组织数据的方式，旨在方便访问和修改。任何一致数据结构都有各自的优劣。</strong></p></li>
</ul>
<h1 id="c基础">C基础</h1>
<h2 id="函数">函数</h2>
<ul>
<li>实现某个具体功能的代码块</li>
<li>增加代码复用性</li>
<li>降低编程难度</li>
<li>函数不被调用就不会执行</li>
<li>对内隐藏细节，对外暴露接口</li>
</ul>
<p>基于需求对函数设定参数、设定返回值。</p>
<h2 id="字符串">字符串</h2>
<p>C语言中的字符串是按照字符数据进行存储的，并没有这种数据类型。</p>
<blockquote>
<p>C#中有string类型</p>
</blockquote>
<ul>
<li><p>存储时字符串尾部带有 <code>\0</code>结束符</p></li>
<li><p>可在定义时直接初始化赋值，也可在定义后使用<code>strcpy()</code>赋值</p></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> arr1[<span class="number">11</span>] = <span class="string">"HelloWorld"</span>;</span><br><span class="line"><span class="type">char</span> arr2[<span class="number">11</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(arr2,<span class="string">"HelloWorld"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="地址">地址</h2>
<p>依据冯诺伊曼结构，计算机操作系统通常包括输入/输出设备，主存储器、辅存储器、控制器、运算器。</p>
<p><strong>内存条、显卡、适配卡都各自有其存储地址空间。操作系统将设备的存储地址空间抽象为一个巨大的一维数组空间，如常说的32位/64位机。</strong></p>
<h2 id="数组">数组</h2>
<ul>
<li>相同数据类型的集合</li>
<li>数组长度在定义时已经确定</li>
<li>n元素的数组下标为0~n-1</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">11</span>];</span><br><span class="line"><span class="type">char</span> b[<span class="number">10</span>][<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>例如以上变量a：</p>
<ul>
<li>a：数组变量</li>
<li>*a：数组首元素</li>
</ul>
<p>再比如变量b：</p>
<ul>
<li>b:数组地址</li>
<li>*b:数组首个行向量地址</li>
<li>**b：数组首个行向量中首个元素地址</li>
</ul>
<h2 id="指针">指针</h2>
<p>指针与数据在某种程度上可以实现相同的功能，比如 :</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">4</span>] = {<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>};</span><br><span class="line"><span class="type">int</span> *p = arr;</span><br></pre></td></tr></table></figure>
<p>则arr[i]和*(p+i)是一致的。指针在进行算术运算时，移动的是i与指针指向数据类型字节长度的乘积。</p>
<p>p+i的实际地址为p向后移动sizeof(int)*i。</p>
<table>
<thead>
<tr>
<th style="text-align: center;">有符号</th>
<th style="text-align: center;">无符号</th>
<th style="text-align: center;">32位</th>
<th style="text-align: center;">64位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">char</td>
<td style="text-align: center;">unsigned char</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">short</td>
<td style="text-align: center;">unsigned short</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: center;">int</td>
<td style="text-align: center;">unsigned int</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">4</td>
</tr>
<tr>
<td style="text-align: center;">long</td>
<td style="text-align: center;">unsigned long</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">8</td>
</tr>
<tr>
<td style="text-align: center;">float</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">8</td>
</tr>
<tr>
<td style="text-align: center;">double</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">8</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h2 id="结构体">结构体</h2>
<p>结构体是一个或多个变量的集合，变量可以是不同的类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>{</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>通常来说，结构体之间的传递也使用指针以提高效率。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> *<span class="title">p</span>;</span></span><br><span class="line">p-&gt;x = <span class="number">1</span>;</span><br><span class="line">(*pp).y = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>有些情况下，为了更清晰的表明结构体的功能，通常会使用别名：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果后续需要用作链表，需要结构体名和别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">} <span class="type">point_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不需要用作链表，可以直接省区结构体名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">}<span class="type">point_t</span>;</span><br></pre></td></tr></table></figure>
<h2 id="内存分配">内存分配</h2>
<ul>
<li><p>静态/全局内存</p>
<p>静态声明的变量和全局变量使用这部分内存，程序开始运行时分配，程序结束才消失</p></li>
<li><p>自动内存（栈）</p>
<p>函数内局部变量，函数被调用时才创建</p></li>
<li><p>动态内存（堆）</p>
<p>根据需求写代码动态分配内存，需要程序主动释放。</p></li>
</ul>
<h1 id="数学基础">数学基础</h1>
<h2 id="等差数列">等差数列</h2>
<p>假设有n项元素，其中a<sub>1</sub>至a<sub>n</sub>中每两项之间的差值为d，则其前n项和
<span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.552ex;" xmlns="http://www.w3.org/2000/svg" width="16.959ex" height="4.855ex" role="img" focusable="false" viewbox="0 -1460 7496.1 2146"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mi" transform="translate(646,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(1398,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mfrac" transform="translate(2453.8,0)"><g data-mml-node="mrow" transform="translate(220,710)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(989,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(2176.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(3177,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(4213.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g><g data-mml-node="mn" transform="translate(2271.1,-686)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><rect width="4802.3" height="60" x="120" y="220"/></g></g></g></svg></mjx-container></span> 由于 <span class="math display"><em>a</em><sub><em>n</em></sub> = <em>a</em><sub>1</sub> + (<em>n</em> − 1)<em>d</em></span>
所以前n项和也可表示为： <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.552ex;" xmlns="http://www.w3.org/2000/svg" width="22.403ex" height="4.855ex" role="img" focusable="false" viewbox="0 -1460 9902.3 2146"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mi" transform="translate(646,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(1398,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(2453.8,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="msub" transform="translate(3053.8,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(4241.6,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mfrac" transform="translate(5241.8,0)"><g data-mml-node="mrow" transform="translate(220,710)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(989,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1811.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2811.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(3311.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mi" transform="translate(3700.4,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g></g><g data-mml-node="mn" transform="translate(2080.2,-686)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><rect width="4420.4" height="60" x="120" y="220"/></g></g></g></svg></mjx-container></span> 当a<sub>1</sub>与d均为1时: <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.552ex;" xmlns="http://www.w3.org/2000/svg" width="14.919ex" height="4.855ex" role="img" focusable="false" viewbox="0 -1460 6594.3 2146"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mi" transform="translate(646,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(1398,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mfrac" transform="translate(2453.8,0)"><g data-mml-node="mrow" transform="translate(220,710)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(989,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1811.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2811.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(3311.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g><g data-mml-node="mn" transform="translate(1820.2,-686)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><rect width="3900.4" height="60" x="120" y="220"/></g></g></g></svg></mjx-container></span></p>
<h2 id="累加和数列">累加和数列</h2>
<p>累加和数列是在等差数列的基础上再度累加。即</p>
<ul>
<li>b<sub>1</sub> = S<sub>1</sub> = a<sub>1</sub></li>
<li>b<sub>2</sub> = S<sub>2</sub> = a<sub>1</sub>+a<sub>2</sub></li>
<li>b<sub>3</sub> = S<sub>3</sub> =
a<sub>1</sub>+a<sub>2</sub>+a<sub>3</sub></li>
<li>…</li>
<li>b<sub>n</sub> = S<sub>n</sub> = a<sub>1</sub>+a<sub>2</sub>+… +
a<sub>n</sub> = n(a<sub>1</sub>+a<sub>n</sub>)/2</li>
</ul>
<p>我们假设，数列b的前n项和为T<sub>n</sub>，则有 <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.864ex;" xmlns="http://www.w3.org/2000/svg" width="37.611ex" height="6.399ex" role="img" focusable="false" viewbox="0 -1562.5 16623.9 2828.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(1369,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="munderover" transform="translate(2424.8,0)"><g data-mml-node="mo"><path data-c="2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"/></g><g data-mml-node="TeXAtom" transform="translate(86,-1107.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(521,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(1299,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mi" transform="translate(509.9,1150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="msub" transform="translate(4035.5,0)"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mi" transform="translate(646,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g><g data-mml-node="mo" transform="translate(5377.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="munderover" transform="translate(6433.4,0)"><g data-mml-node="mo"><path data-c="2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"/></g><g data-mml-node="TeXAtom" transform="translate(86,-1107.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(521,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(1299,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mi" transform="translate(509.9,1150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(7877.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mfrac" transform="translate(8266.4,0)"><g data-mml-node="mi" transform="translate(220,676)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mn" transform="translate(230.5,-686)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><rect width="721" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(9227.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(9616.4,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="msub" transform="translate(10116.4,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(11304.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mo" transform="translate(12304.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(12693.4,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(13436.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(14436.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(14936.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mi" transform="translate(15325.9,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(15845.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(16234.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></span> 展开后可得： <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.864ex;" xmlns="http://www.w3.org/2000/svg" width="29.323ex" height="6.399ex" role="img" focusable="false" viewbox="0 -1562.5 12960.8 2828.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(1369,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(2424.8,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="munderover" transform="translate(3557,0)"><g data-mml-node="mo"><path data-c="2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"/></g><g data-mml-node="TeXAtom" transform="translate(86,-1107.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(521,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(1299,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mi" transform="translate(509.9,1150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mi" transform="translate(5167.7,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(5910.9,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mfrac" transform="translate(6911.2,0)"><g data-mml-node="mi" transform="translate(220,676)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mn" transform="translate(230,-686)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><rect width="720" height="60" x="120" y="220"/></g><g data-mml-node="munderover" transform="translate(8037.8,0)"><g data-mml-node="mo"><path data-c="2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"/></g><g data-mml-node="TeXAtom" transform="translate(86,-1107.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(521,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(1299,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mi" transform="translate(509.9,1150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(9481.8,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msup" transform="translate(9870.8,0)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mn" transform="translate(554,413) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(11050.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(12050.8,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(12571.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></span></p>
<p>利用求和公式计算得： <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.602ex;" xmlns="http://www.w3.org/2000/svg" width="53.382ex" height="4.905ex" role="img" focusable="false" viewbox="0 -1460 23595 2168"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(1369,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(2424.8,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mfrac" transform="translate(3390.4,0)"><g data-mml-node="mrow" transform="translate(220,710)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(989,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1811.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2811.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(3311.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g><g data-mml-node="mn" transform="translate(1820.2,-686)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><rect width="3900.4" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(7753,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mfrac" transform="translate(8753.3,0)"><g data-mml-node="mi" transform="translate(220,676)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mn" transform="translate(230,-686)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><rect width="720" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(9713.3,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mfrac" transform="translate(10102.3,0)"><g data-mml-node="mrow" transform="translate(220,710)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(989,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1811.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2811.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(3311.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(3700.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(4089.4,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(4589.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(5411.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(6411.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(6911.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g><g data-mml-node="mn" transform="translate(3620.4,-686)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"/></g><rect width="7500.9" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(18065.4,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mfrac" transform="translate(19065.6,0)"><g data-mml-node="mrow" transform="translate(220,710)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(989,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1811.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2811.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(3311.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g><g data-mml-node="mn" transform="translate(1820.2,-686)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><rect width="3900.4" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(23206,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></span></p>
<p>整理可得： <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.602ex;" xmlns="http://www.w3.org/2000/svg" width="37.362ex" height="4.905ex" role="img" focusable="false" viewbox="0 -1460 16514.2 2168"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(1369,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(2424.8,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mfrac" transform="translate(3390.4,0)"><g data-mml-node="mrow" transform="translate(220,710)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(989,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1811.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2811.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(3311.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g><g data-mml-node="mn" transform="translate(1820.2,-686)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><rect width="3900.4" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(7753,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(8753.3,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mfrac" transform="translate(9273.3,0)"><g data-mml-node="mrow" transform="translate(220,710)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(989,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1811.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2811.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(3311.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(3700.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(4089.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(4911.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(5911.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(6411.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g><g data-mml-node="mn" transform="translate(3370.4,-686)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"/></g><rect width="7000.9" height="60" x="120" y="220"/></g></g></g></svg></mjx-container></span></p>
<p>合并同类项得： <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.602ex;" xmlns="http://www.w3.org/2000/svg" width="30.75ex" height="4.905ex" role="img" focusable="false" viewbox="0 -1460 13591.7 2168"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(1369,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mfrac" transform="translate(2424.8,0)"><g data-mml-node="mrow" transform="translate(220,710)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(989,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1811.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2811.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(3311.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g><g data-mml-node="mn" transform="translate(1820.2,-686)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><rect width="3900.4" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(6565.3,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(6954.3,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(8142,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mfrac" transform="translate(9142.3,0)"><g data-mml-node="mrow" transform="translate(220,710)"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(520,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(909,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1731.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2731.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(3231.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g><g data-mml-node="mn" transform="translate(1780.2,-686)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><rect width="3820.4" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(13202.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></span> 我们假设，a<sub>1</sub> 和d均为1，则数列的前n项和为： <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.602ex;" xmlns="http://www.w3.org/2000/svg" width="21.868ex" height="4.905ex" role="img" focusable="false" viewbox="0 -1460 9665.7 2168"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(1369,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mfrac" transform="translate(2424.8,0)"><g data-mml-node="mrow" transform="translate(220,710)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(989,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1811.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2811.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(3311.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(3700.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(4089.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(4911.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(5911.9,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(6411.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g><g data-mml-node="mn" transform="translate(3370.4,-686)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"/></g><rect width="7000.9" height="60" x="120" y="220"/></g></g></g></svg></mjx-container></span></p>
<h2 id="等比数列">等比数列</h2>
<p>数列{a<sub>n</sub>}满足相邻项的比值为常数q，其通项式为 <span class="math display"><em>a</em><sub><em>n</em></sub> = <em>a</em><sub>1</sub><em>q</em><sup><em>n</em> − 1</sup></span>
因此S<sub>n</sub>的表达式为： <span class="math display"><em>S</em><sub><em>n</em></sub> = <em>a</em><sub>1</sub> + <em>a</em><sub>1</sub><em>q</em> + <em>a</em><sub>1</sub><em>q</em><sup>2</sup> + ..<em>a</em><sub>1</sub><em>q</em><sup><em>n</em> − 1</sup></span>
两端同时成q以后减去上式： <span class="math display">(<em>q</em> − 1)<em>S</em><sub><em>n</em></sub> = <em>a</em><sub>1</sub>(<em>q</em><sup><em>n</em></sup> − 1)</span>
可得： <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.991ex;" xmlns="http://www.w3.org/2000/svg" width="14.932ex" height="5.049ex" role="img" focusable="false" viewbox="0 -1351.5 6599.8 2231.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mi" transform="translate(646,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(1398,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(2453.8,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mfrac" transform="translate(3419.4,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(722.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="msup" transform="translate(1722.4,0)"><g data-mml-node="mi"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mi" transform="translate(543.7,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g><g data-mml-node="mrow" transform="translate(499,-686)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(722.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(1722.4,0)"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g></g><rect width="2940.4" height="60" x="120" y="220"/></g></g></g></svg></mjx-container></span></p>
<h1 id="算法分析">算法分析</h1>
<ul>
<li>时间复杂度</li>
<li>空间复杂度</li>
<li>抽象数据类型ADT</li>
</ul>
<p>数据结构与算法存在本质联系。在研究某一类型的数据结构时，总要涉及其上施加的运算，只有通过对定义运算的研究，才能真正理解数据结构的定义与作用。</p>
<h2 id="时间复杂度">时间复杂度</h2>
<p>时间复杂度，也称渐进复杂度，T(n) =
O(f(n))。随问题规模n增大，算法执行时间增长率和f(n)增长率成正比。</p>
<p><strong>程序运行时间主要和执行每条语句的耗时、每条语句的执行频率有关。</strong></p>
<p>语句执行要由源程序翻译为目标代码，目标代码再装配执行。每个语句执行一次需要的具体时间和机器的软/硬件环节有关。<span style="color:red"><strong>因此，算法分析并非是实际执行时间，而是针对算法中语句执行次数做出估计，得到算法执行时间的信息。</strong></span></p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; i++) <span class="comment">//循环n次，额外1次判断频度为n+1</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;=n; j++)<span class="comment">//同上</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k =<span class="number">1</span>; k&lt;=n; k++)<span class="comment">//同上</span></span><br><span class="line">        {</span><br><span class="line">            c[i][j] += a[i][k]* b[k][j]; </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>上方代码的<code>f(n) = n^3</code>，当n=1时，<code>f(n) = O(1)</code>。</p>
<p>有以下区分：</p>
<ul>
<li>最好时间复杂度：算法再最好情况下的时间复杂度</li>
<li><strong>最坏时间复杂度：算法在最坏情况下的时间复杂度</strong></li>
<li>平均时间复杂度：算法在所有可能的情况下，按输入实例等概率出现时的加权平均值</li>
</ul>
<p>通常只讨论最坏时间复杂度。</p>
<h3 id="常量阶">常量阶</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x++; <span class="comment">//频度为1</span></span><br><span class="line">s = <span class="number">0</span>; <span class="comment">//频度为1</span></span><br></pre></td></tr></table></figure>
<p><code>f(n) = 1+1;</code>复杂度为O(1)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++)</span><br><span class="line">{</span><br><span class="line">    x++;</span><br><span class="line">    s = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>算法执行时间不随问题的规模增长而增长，尽管执行了上万次，其仍然是常量。</p>
<h3 id="线性阶">线性阶</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">{</span><br><span class="line">	x++; <span class="comment">//频度为n</span></span><br><span class="line">    s=<span class="number">0</span>; <span class="comment">//频度为n</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><code>f(n)=(n+1)+n+n = 3n+1</code>，即复杂度T(n) = O(n)。</p>
<h3 id="平方阶">平方阶</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x++; <span class="comment">//频度为n</span></span><br><span class="line">s=<span class="number">0</span>; <span class="comment">//频度为n	</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=n; j++)<span class="comment">//频度为n	</span></span><br><span class="line">    {</span><br><span class="line">        y++;<span class="comment">//频度为n	</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><code>f(n)=(n+1)*n = n^2+n</code>，即复杂度T(n) = O(n^2)。</p>
<h3 id="立方阶">立方阶</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++)<span class="comment">//频度为n</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=i; j++) <span class="comment">//频度为1+2+..+i	</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k =<span class="number">0</span>; k&lt;=j;k++ )<span class="comment">//频度为1+(1+2)+(1+2+3)..+n*(n+1)/2</span></span><br><span class="line">        {</span><br><span class="line">        	y++;<span class="comment">//频度为n*(n+1)*(n+2)/6	</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><code>f(n)=n*(n*(n+1)/2) = n^2+n</code>，即复杂度T(n) = O(n^2)。</p>
<h3 id="对数阶">对数阶</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i=i*<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">	x++; </span><br><span class="line">    s=<span class="number">0</span>; </span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">次数</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">t</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">i</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">i</td>
<td style="text-align: center;">2^0</td>
<td style="text-align: center;">2^1</td>
<td style="text-align: center;">2^2</td>
<td style="text-align: center;">2^3</td>
<td style="text-align: center;">2^(t-1)</td>
</tr>
</tbody>
</table>
<p>2^t-1 &gt; n时循环退出，可得t&gt;log<sub>2</sub>n + 1</p>
<p>即T(n) =
O(log<sub>2</sub>n)，故也可以推导出倍数为其他值时的时间复杂度。</p>
<h3 id="题目">题目</h3>
<p>1.例如：设n是描述问题规模的非负整数，下面程序片段的时间复杂度是();</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(x&lt;n/<span class="number">2</span>)</span><br><span class="line">    x = <span class="number">2</span>*x;</span><br></pre></td></tr></table></figure>
<p>实现复杂度的核心目的是找到语句的执行频次，也即什么时候退出循环，把每次x的值列出</p>
<table>
<thead>
<tr>
<th style="text-align: center;">次数</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">t</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">i</td>
<td style="text-align: center;">2^2</td>
<td style="text-align: center;">2^3</td>
<td style="text-align: center;">2^4</td>
<td style="text-align: center;">2^5</td>
<td style="text-align: center;">2^t+1</td>
</tr>
</tbody>
</table>
<p>即2<sup>t+1</sup> &gt; n/2，可得t&gt;log<sub>2</sub>n -
2，时间复杂度为O(log<sub>2</sub>n)。</p>
<p>2.再如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>, sum =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sum &lt; n) sum += ++i;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>同样的思路，列i与sum的变化表格：</p>
<table>
<thead>
<tr>
<th style="text-align: center;">次数</th>
<th>1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">t</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">i</td>
<td>1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">t</td>
</tr>
<tr>
<td style="text-align: center;">sum</td>
<td>1</td>
<td style="text-align: center;">1+2</td>
<td style="text-align: center;">1+2+3</td>
<td style="text-align: center;">1+..+4</td>
<td style="text-align: center;">t(t+1)/2</td>
</tr>
</tbody>
</table>
<p>即t(t+1)/2 &gt;= n，推知t &gt; n<sup>1/2</sup>，时间复杂度为O
(n<sup>1/2</sup>)。</p>
<p><span style="color:red"><strong>此处曾出现一处误解，即在t次将sum的值计算为n(n+1)/2
&gt;
n，从而得出复杂度为O(n)。根本原因在于将循环次数与问题规模混用一个n值。</strong></span></p>
<p>3.再如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i*=<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">    {</span><br><span class="line">        sum++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">次数</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">t</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">i</td>
<td style="text-align: center;">2^0</td>
<td style="text-align: center;">2^1</td>
<td style="text-align: center;">2^2</td>
<td style="text-align: center;">2^3</td>
<td style="text-align: center;">2^(t-1)</td>
</tr>
<tr>
<td style="text-align: center;">内层次数</td>
<td style="text-align: center;">2^0</td>
<td style="text-align: center;">2^1</td>
<td style="text-align: center;">2^2</td>
<td style="text-align: center;">2^3</td>
<td style="text-align: center;">2^(t-1)</td>
</tr>
</tbody>
</table>
<p>其中外层函数的执行次数为2^(t-1) &gt;=n ，可得t&gt;log<sub>2</sub>n +
1。</p>
<p>而内层每次执行执行的次数与外圈i相等，故最内层语句总执行频度为： <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.738ex;" xmlns="http://www.w3.org/2000/svg" width="45.648ex" height="5.09ex" role="img" focusable="false" viewbox="0 -1481.6 20176.6 2249.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(550,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(939,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1539,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2205.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msup" transform="translate(3261.6,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mn" transform="translate(533,413) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(4420.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msup" transform="translate(5420.6,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mn" transform="translate(533,413) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(6357.1,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mo" transform="translate(7135.1,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(7579.8,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(8024.4,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msup" transform="translate(8802.4,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mo" transform="translate(361,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1139,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g><g data-mml-node="mo" transform="translate(10822.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(11877.9,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mfrac" transform="translate(12377.9,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(722.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="msup" transform="translate(1722.4,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g></g></g><g data-mml-node="mrow" transform="translate(389.1,-686)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(722.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1722.4,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><rect width="2760.7" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(15656.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msup" transform="translate(16712.2,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mo" transform="translate(361,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(1139,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g><g data-mml-node="mo" transform="translate(18676.4,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(19676.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></svg></mjx-container></span> 带入t=log<sub>2</sub>n得f(n) = 2n，故T(n) = O(n)；</p>
<h2 id="空间复杂度">空间复杂度</h2>
<p>空间复杂度主要描述某个算法对应的程序想在计算机上执行，<strong>除去用来存储代码和输入数据的内存空间外，还需要额外的空间</strong>。</p>
<p>S(n) = O(f(n))。</p>
<h2 id="抽象数据类型adt">抽象数据类型ADT</h2>
<p>ADT是一种编程概念，用于定义数据类型及其操作，不涉及实现细节。优势是对外隐藏细节，对内隐藏接口。</p>
<p>在C中，ADT通常通过结构体和函数实现。</p>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p>算法 + 数据结构 = 程序</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机类</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-08-三元递增子序列</title>
    <url>/2025/08/09/LeetCode-08-Increasing_Triplet/</url>
    <content><![CDATA[<p>LeetCode算法题：元素之积。</p>
<span id="more"></span>
<h2 id="题目">题目</h2>
<p>给你一个整数数组 <code>nums</code> ，判断这个数组中是否存在长度为
<code>3</code> 的递增子序列。</p>
<p>如果存在这样的三元组下标 <code>(i, j, k)</code> 且满足
<code>i &lt; j &lt; k</code> ，使得
<code>nums[i] &lt; nums[j] &lt; nums[k]</code> ，返回 <code>true</code>
；否则，返回 <code>false</code> 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5 * 105</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
</ul>
<h2 id="思路">思路</h2>
<p>首先区分题干要求，递增三元子序列。由原序列中任意n个元素可组成一个n元子序列，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<p>其中<code>[1,2,4]</code>、<code>[1,4,7]</code>均为a的子序列，如果有顺序要求，则判断条件更广。</p>
<p>因此，最基础的思路是使用三重循环遍历，直至找到，或者遍历完成。</p>
<h2 id="代码">代码</h2>
<p>###　方案Ａ-遍历</p>
<p>以首元素为i的起点，次元素为j起点，第三个元素为k的起点。但是改方案嵌套三重循环，不适用数据量较大的情况。</p>
<div>
<pre><code>       &lt;!--块级封装--&gt;
&lt;center&gt;    &lt;!--将图片和文字居中--&gt;
&lt;img src=&quot;2025-08-09-LeetCode-08-Increasing_Triplet/A.jpg&quot;
     alt=&quot;image can&#39;t load.&quot;
     style=&quot;zoom:100%&quot;/&gt;&lt;!-- alt内为提示词--&gt;
&lt;br&gt;        &lt;!--换行--&gt;
三循环，时间O(n^3)&lt;!--标题--&gt;
&lt;/center&gt;</code></pre>
</div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">increasingTriplet</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(numsSize &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numsSize<span class="number">-2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;numsSize - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=j+<span class="number">1</span>; k&lt;numsSize; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&lt;nums[j] &amp;&amp; nums[j]&lt;nums[k])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方案b-贪心">方案B-贪心</h3>
<p>方案A的时间复杂度较大，换种思路，即三个元素相互对比，其大小关系只有以下几种：</p>
<ul>
<li>i &lt; j &lt; k，单调递增</li>
<li>i &lt; j，i &lt; k &lt; j，新数组在前方两个数据之间</li>
<li>k &lt; i &lt; j，新数据最小</li>
</ul>
<p><strong>因此定义min存储整个序列的最小值，second存储的数据不定，但一定保证前方存在一个数据&lt;second。</strong></p>
<div>
<pre><code>       &lt;!--块级封装--&gt;
&lt;center&gt;    &lt;!--将图片和文字居中--&gt;
&lt;img src=&quot;2025-08-09-LeetCode-08-Increasing_Triplet/B.jpg&quot;
     alt=&quot;image can&#39;t load.&quot;
     style=&quot;zoom:100%&quot;/&gt;&lt;!-- alt内为提示词--&gt;
&lt;br&gt;        &lt;!--换行--&gt;
贪心，时间O(n)空间O(1)&lt;!--标题--&gt;
&lt;/center&gt;</code></pre>
</div>
<p>如上图，尽管最后的结果使用的是mid2、min3和末尾值，但在mid2之前一定有一个更小的min1（否则mid为初值<code>INT_MAX</code>，不可能有比其更大的值）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">increasingTriplet</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(numsSize &lt; <span class="number">3</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> mid = INT_MIX; <span class="comment">// 初始化为最大值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">     	<span class="comment">// 三元素递增</span></span><br><span class="line">        <span class="keyword">if</span>(mid &lt; nums[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 刷新次最小的元素值，前方一定有比他更小的</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(min &lt; nums[i])</span><br><span class="line">        &#123;</span><br><span class="line">            mid = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            min = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p><em>白日放歌须纵酒，青春作伴好还乡。–《闻官军收河南河北》</em></p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-07-元素之积</title>
    <url>/2025/08/07/LeetCode-07-Product_ExceptSelf/</url>
    <content><![CDATA[<p>LeetCode算法题：元素之积。</p>
<span id="more"></span>
<h2 id="题目">题目</h2>
<p>LeetCode：<a href="https://leetcode.cn/studyplan/leetcode-75/">LeetCode 75 -
学习计划</a>-07-数组元素除去自身外的乘积</p>
<p>给你一个整数数组 <code>nums</code>，返回 数组 <code>answer</code>
，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除
<code>nums[i]</code> 之外其余各元素的乘积 。</p>
<p>题目数据 <strong>保证</strong> 数组
<code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32
位</strong> 整数范围内。</p>
<p>请不要使用除法，且在 <code>O(n)</code> 时间复杂度内完成此题。</p>
<p><strong>进阶：</strong> <code>O(1)</code> 的额外空间复杂度？</p>
<h2 id="思路">思路</h2>
<p>最简易的想法是循环计算所有元素的乘积，随后除去元素自身。</p>
<p>在限制除法后将整个乘积过程拆分为两个：</p>
<ul>
<li>元素左侧的数值之积</li>
<li>元素右侧的数值之积</li>
</ul>
<p>问题即演变为如何最大程度的减小空间复杂度。</p>
<ol type="1">
<li>采用长缓存数组L、R分别存储元素左侧右侧之积，空间复杂度O(2n)</li>
<li>双循环。anwser [i] =
anwser[i-1]*nums[i]，将计算结果直接存入anwser数组内，额外使用int变量存储右侧之积，空间复杂度O(1)。</li>
<li>单循环。初始化输出数组为全1，额外使用两个int变量L、R存储左右之积，从两侧开始相乘。</li>
</ol>
<h2 id="代码">代码</h2>
<h3 id="方案a-lr数组">方案A-LR数组</h3>
<p>LR数组分别计算并存入新数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">productExceptSelf</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    *returnSize = numSize;</span><br><span class="line">     <span class="type">int</span> *answer = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*numSize);</span><br><span class="line">     <span class="type">int</span> *L = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*numSize);</span><br><span class="line">     <span class="type">int</span> *R = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*numSize);</span><br><span class="line">     L[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">     R[numSize - <span class="number">1</span>] =<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;numSize; i++)</span><br><span class="line">     &#123;</span><br><span class="line">        L[i] = L[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>];</span><br><span class="line">        R[numSize-i<span class="number">-1</span>] = R[numSize - i] * nums[numSize - i];</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;numSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        answer[i] = L[i] * R[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(L);</span><br><span class="line">    <span class="built_in">free</span>(R);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方案b-双循环">方案B-双循环</h3>
<ul>
<li>首次循环计算元素左侧之积并填入answer</li>
<li>二次循环计算元素右侧之积suffix，并计算新answer</li>
</ul>
<div>
<center>
<img src="B.jpg" alt="image can't load." style="zoom:100%"> <br> 单循环O(1)
</center>
</div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">productExceptSelf</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    *returnSize = numSize;</span><br><span class="line">     <span class="type">int</span> *answer = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*numSize);</span><br><span class="line">    answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> suffix = <span class="number">1</span>; <span class="comment">//右侧之积</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//正向，元素左侧之积存入answer中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;numSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        answer[i] = answer[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//反向，乘右侧之积suffix，并刷新新值    </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=numSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		answer[numSize-i] *= suffix;</span><br><span class="line">        suffix *= nums[numSize-i];</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方案c-单循环">方案C-单循环</h3>
<p>既然方案B中本身两次循环进行双向计算，故可进一步优化为单循环内从左至右计算两次：</p>
<ul>
<li>使用L、R存储某元素两侧的数值之积，L从左侧计算，R从右侧计算。</li>
<li>answer[i]与answer[n-i-1]正向反向两次计算，则单次循环内实现对数据的两次乘积</li>
</ul>
<div>
<center>
<img src="C.jpg" alt="image can't load." style="zoom:100%"> <br> 单循环O(1)
</center>
</div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">productExceptSelf</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    *returnSize = numSize;</span><br><span class="line">     <span class="type">int</span> *answer = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*numSize);</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; numSize; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         answer[i] = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> L = <span class="number">1</span>, R= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;numSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L *= nums[i - <span class="number">1</span>];</span><br><span class="line">        R *= nums[n - i];</span><br><span class="line">        </span><br><span class="line">        answer[i] *= L;</span><br><span class="line">        answer[n-i<span class="number">-1</span>] *= R;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p><em>云中谁寄锦书来，雁字回时，月满西楼。–《一剪梅·红藕香残玉簟秋》</em></p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-06-单词顺序反转</title>
    <url>/2025/08/03/LeetCode-06-Reverse_Words/</url>
    <content><![CDATA[<p>LeetCode算法题：字符串中单词顺序反转。</p>
<span id="more"></span>
<h2 id="题目">题目</h2>
<p>LeetCode：<a href="https://leetcode.cn/studyplan/leetcode-75/">LeetCode 75 -
学习计划</a>-06-反转字符串中的单词</p>
<p>给你一个字符串 <code>s</code> ，请你反转字符串中
<strong>单词</strong> 的顺序。</p>
<p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code>
中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p>
<p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong>
之间用单个空格连接的结果字符串。</p>
<p><strong>注意：</strong>输入字符串
<code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<h2 id="思路">思路</h2>
<p>从模块的功能看，输入内容可以有以下几种情况：</p>
<ol start="3" type="1">
<li>单字符单词、数字</li>
<li>混合数字的多字符单词</li>
</ol>
<p>输出的情况较为固定，单词+空格…</p>
<h2 id="代码">代码</h2>
<h3 id="方案a-双指针">方案A-双指针</h3>
<p>采用左右指针从输入字符串中从后向前找单词。</p>
<ol type="1">
<li>right = left = len -1，从最右侧开始，寻找完整单词</li>
<li>以空格为界寻找左边界left</li>
<li>更新right = left ，寻找下一个单词</li>
<li>直到right = 0地址索引终止。</li>
</ol>
<div>
<center>
<img src="reverseString_A.jpg" alt="image can't load." style="zoom:100%"> <br> 自后向前找单词O(n)
</center>
</div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">reverseWords</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    assert(s);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">char</span>* out_string = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (len + <span class="number">1</span>));</span><br><span class="line">    <span class="type">char</span>* out_idx = out_string;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* right = s + len - <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span>* left = right;</span><br><span class="line">    <span class="comment">//处理单字符</span></span><br><span class="line">    <span class="keyword">if</span> (right == s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="type">void</span>*)out_idx, (<span class="type">void</span>*)left, <span class="keyword">sizeof</span>(<span class="type">char</span>) * (right - left + <span class="number">1</span>));</span><br><span class="line">        out_idx += right - left + <span class="number">1</span>;</span><br><span class="line">        *out_idx = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> out_string;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理多字符</span></span><br><span class="line">    <span class="keyword">while</span> (right &gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (*right == <span class="string">&#x27; &#x27;</span> &amp;&amp; right &gt; s) right--;</span><br><span class="line">        <span class="keyword">if</span> (*right == <span class="string">&#x27; &#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">        left = right;</span><br><span class="line">        <span class="keyword">while</span> (*left != <span class="string">&#x27; &#x27;</span> &amp;&amp; left &gt; s) left--;</span><br><span class="line">        (left != s || (left == s &amp;&amp; *left == <span class="string">&#x27; &#x27;</span>)) ? left += <span class="number">1</span> : <span class="number">0</span>; <span class="comment">//判断是否为首字符，防止越界</span></span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="type">void</span>*)out_idx, (<span class="type">void</span>*)left, <span class="keyword">sizeof</span>(<span class="type">char</span>) * (right - left + <span class="number">1</span>));</span><br><span class="line">        out_idx += right - left + <span class="number">1</span>;</span><br><span class="line">        *(out_idx++) = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        right = left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *(out_idx - <span class="number">1</span>) = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//字符串结束符</span></span><br><span class="line">    <span class="keyword">return</span> out_string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方案指针是从后向前移动，需要注意数组越界/指针越界。其中leetcode会报错，本地VS可运行成功。
&gt; runtime error: store to address 0x502000000040 with insufficient
space for an object of type ‘char’</p>
<p>另外此函数使用strlen函数空间复杂度为O(n)，需额外占用部分空间。</p>
<h3 id="方案b-双反转">方案B-双反转</h3>
<p>由于需要反转字符串内的单词顺序，因此可以分为以下几个步骤：</p>
<ol type="1">
<li>去除首尾空格、去除中间空格</li>
<li>反转整个字符串</li>
<li>反转单个单词</li>
</ol>
<p>此种方案可以在原有字符串上进行改动，空间复杂度为O (1)
，<strong>修减空格、反转函数</strong>进行模块化。</p>
<div>
<center>
<img src="reverseString_B.jpg" alt="image can't load." style="zoom:100%"> <br> 反转字符串再反转单词O(1)
</center>
</div>
<ol type="1">
<li>从前之后滤除空格。遇到单词后的空格/尾部结束符时仅输出1次空格，将后方字符前移。将尾部替换为结束符<code>\0</code>。</li>
<li>反转整个字符串。实现单词位置的反转。</li>
<li>反转单词。以<strong>空格/结束符</strong>为提示符查找单个单词进行反转。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trimString</span><span class="params">(<span class="type">char</span>* s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修剪前侧空格</span></span><br><span class="line">    <span class="keyword">while</span> (j&lt;len &amp;&amp; s[j] == <span class="string">&#x27; &#x27;</span>) j++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修建中间空格</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[j] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i++] = s[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            s[i++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; len &amp;&amp; s[j] == <span class="string">&#x27; &#x27;</span>) j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修剪尾部空格</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) i--;</span><br><span class="line">    s[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>* s,<span class="type">int</span> start,<span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = s[start];</span><br><span class="line">        s[start] = s[end];</span><br><span class="line">        s[end] = tmp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">reverseWords</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span> || *s == <span class="string">&#x27;\0&#x27;</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    trimString(s);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转整个字符串</span></span><br><span class="line">    reverseString(s,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span> || s[i] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            reverseString(s, start, i - <span class="number">1</span>);</span><br><span class="line">            start = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p><em>远上寒山石径斜，白云深处有人家。–《山行》</em></p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-05-元音字符翻转</title>
    <url>/2025/08/02/LeetCode-05-Reverse_Vowels/</url>
    <content><![CDATA[<p>LeetCode算法题：字符串中元音字符翻转。</p>
<span id="more"></span>
<h2 id="题目">题目</h2>
<p>LeetCode：<a href="https://leetcode.cn/studyplan/leetcode-75/">LeetCode 75 -
学习计划</a>-05-反转字符串中的元音字母</p>
<p>给你一个字符串 <code>s</code>
，仅反转字符串中的所有元音字母，并返回结果字符串。</p>
<p>元音字母包括
<code>'a'</code>、<code>'e'</code>、<code>'i'</code>、<code>'o'</code>、<code>'u'</code>，且可能以大小写两种形式出现不止一次。</p>
<h2 id="思路">思路</h2>
<p>待查找字符已知，从左右两端搜索对应值即可。</p>
<h2 id="代码">代码</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isVowels</span><span class="params">(<span class="type">char</span> ch)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">reverseVowels</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    assert(s);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* left = s;</span><br><span class="line">    <span class="type">char</span>* right =  s + <span class="built_in">strlen</span>(s) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right - left &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isVowels(*left))</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isVowels(*right))</span><br><span class="line">        &#123;</span><br><span class="line">            right--;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = *left;</span><br><span class="line">            *left = *right;</span><br><span class="line">            *right = tmp;</span><br><span class="line">            left++;</span><br><span class="line">            right--; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> arrVowels[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;U&#x27;</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">isVowels</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(arrVowels)/<span class="keyword">sizeof</span>(<span class="type">char</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arrVowels[i] == ch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方案使用const数组对字符进行封装，适合多次调用时功能的扩展移植。功能采用单个while循环完成，但内部if-else会影响流水线，因此进行优化为双重循环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">reverseVowels</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    assert(s);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* left = s;</span><br><span class="line">    <span class="type">char</span>* right =  s + <span class="built_in">strlen</span>(s) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right - left &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(isVowels(*left))</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(isVowels(*right))</span><br><span class="line">        &#123;</span><br><span class="line">            right--;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = *left;</span><br><span class="line">            *left = *right;</span><br><span class="line">            *right = tmp;</span><br><span class="line">            left++;</span><br><span class="line">            right--; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果向修改isVowels函数，可以调整为如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> arrVowels[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;U&#x27;</span>&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isVowels</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(arrVowels)/<span class="keyword">sizeof</span>(<span class="type">char</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arrVowels[i] == ch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而若调用次数不多，可使用以下代码，逻辑或||相对于逻辑与&amp;&amp;减少判断次数，加快运行时间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isVowels</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if(ch!=&#x27;a&#x27;&amp;&amp; ch!=&#x27;A&#x27;&amp;&amp; ch!=&#x27;o&#x27;&amp;&amp; ch!=&#x27;O&#x27;&amp;&amp; ch!=&#x27;e&#x27;&amp;&amp; ch!=&#x27;E&#x27;&amp;&amp; ch!=&#x27;i&#x27;&amp;&amp; ch!=&#x27;I&#x27;&amp;&amp;ch!=&#x27;u&#x27;&amp;&amp; ch!=&#x27;U&#x27;)</span></span><br><span class="line"><span class="comment">        return 1;</span></span><br><span class="line"><span class="comment">    else </span></span><br><span class="line"><span class="comment">        return 0;   </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      <span class="keyword">return</span> (ch==<span class="string">&#x27;a&#x27;</span>|| ch==<span class="string">&#x27;A&#x27;</span>|| ch==<span class="string">&#x27;o&#x27;</span>|| ch==<span class="string">&#x27;O&#x27;</span>|| ch==<span class="string">&#x27;e&#x27;</span>|| ch==<span class="string">&#x27;E&#x27;</span>|| ch==<span class="string">&#x27;i&#x27;</span>|| ch==<span class="string">&#x27;I&#x27;</span>||ch==<span class="string">&#x27;u&#x27;</span>|| ch==<span class="string">&#x27;U&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p><em>缺月挂疏桐，漏断人初静。–《卜算子·黄州定慧院寓居作》</em></p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-04-种花问题</title>
    <url>/2025/07/24/LeetCode-04-Can_Place_Flowers/</url>
    <content><![CDATA[<p>LeetCode算法题：种花问题。</p>
<span id="more"></span>
<h2 id="题目">题目</h2>
<p>LeetCode：<a href="https://leetcode.cn/studyplan/leetcode-75/">LeetCode 75 -
学习计划</a>-04-种花问题</p>
<p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给你一个整数数组 <code>flowerbed</code> 表示花坛，由若干
<code>0</code> 和 <code>1</code> 组成，其中 <code>0</code>
表示没种植花，<code>1</code> 表示种植了花。另有一个数 <code>n</code>
，能否在不打破种植规则的情况下种入 <code>n</code> 朵花？能则返回
<code>true</code> ，不能则返回 <code>false</code> 。</p>
<h2 id="思路">思路</h2>
<p>花不能相邻，则可用连续三块地无花进行分析。即<code>i-1,i,i+1</code>均为空。</p>
<p>但需考虑几个特殊情况：</p>
<ul>
<li>待插花数n=0</li>
<li>花坛长度为1、2或其他长度（可直接判断插花或不插）</li>
</ul>
<h2 id="代码">代码</h2>
<h3 id="方案a">方案A</h3>
<p>分别考虑特殊情况和长度大于2时的通用情况，遍历所有情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">canPlaceFlowers</span><span class="params">(<span class="type">int</span>* flowerbed, <span class="type">int</span> flowerbedSize, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    assert(flowerbed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 待插入0 */</span></span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 花圃仅一块 */</span></span><br><span class="line">    <span class="keyword">if</span>(flowerbedSize == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        flowerbed[<span class="number">0</span>]==<span class="number">0</span>? (n--):<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> n&gt;<span class="number">0</span>?<span class="literal">false</span>:<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向两端插花 */</span></span><br><span class="line">    <span class="keyword">if</span>(flowerbed[<span class="number">0</span>]+flowerbed[<span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        flowerbed[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flowerbed[flowerbedSize<span class="number">-1</span>]+flowerbed[flowerbedSize<span class="number">-2</span>] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        flowerbed[flowerbedSize<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 循环在中间插花 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; flowerbedSize &gt; <span class="number">2</span> &amp;&amp; i&lt; flowerbedSize<span class="number">-1</span> &amp;&amp; n &gt; <span class="number">0</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((flowerbed[i<span class="number">-1</span>] | flowerbed[i] | flowerbed[i+<span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flowerbed[i++] = <span class="number">1</span>; <span class="comment">/* 插花后向后跳 */</span></span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方案b">方案B</h3>
<div>
<pre><code>       &lt;!--块级封装--&gt;
&lt;center&gt;    &lt;!--将图片和文字居中--&gt;
&lt;img src=&quot;2025-07-24-LeetCode-04-Can_Place_Flowers/slip_window.jpg&quot;
     alt=&quot;image can&#39;t load.&quot;
     style=&quot;zoom:100%&quot;/&gt;&lt;!-- alt内为提示词--&gt;
&lt;br&gt;        &lt;!--换行--&gt;
滑动窗逻辑&lt;!--标题--&gt;
&lt;/center&gt;</code></pre>
</div>
<p>使用滑动窗口逻辑，设定</p>
<ul>
<li>起始左窗口<code>left = -1,right = 0</code>。</li>
<li>检索到right内的值为1时，刷新左右边界值</li>
<li>左右边界间距大于3时，可插入一个</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">canPlaceFlowers</span><span class="params">(<span class="type">int</span>* flowerbed, <span class="type">int</span> flowerbedSize, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    assert(flowerbed);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left=<span class="number">-1</span>,right=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(flowerbedSize==<span class="number">1</span>)	<span class="comment">//考虑待插入数组只有一个空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        flowerbed[<span class="number">0</span>] == <span class="number">0</span> ? (n--):<span class="number">0</span>;	</span><br><span class="line">        <span class="keyword">return</span>  n&lt;=<span class="number">0</span>;		<span class="comment">//需考虑n=0的情况</span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right &lt; flowerbedSize &amp;&amp; n&gt;<span class="number">0</span>) <span class="comment">/* 未到达右边界，且无新花需要插入 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flowerbed[right] == <span class="number">1</span>)	<span class="comment">/* 刷新左边界 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = right+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        right ++;   </span><br><span class="line"></span><br><span class="line">        <span class="comment">/*分别判断在中间或花圃右边界是否能插入新花*/</span></span><br><span class="line">        <span class="keyword">if</span>(right-left&gt;=<span class="number">3</span> || (right == flowerbedSize &amp;&amp; (right-left)&gt;<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            n--;</span><br><span class="line">            left += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n&lt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p><em>星星之火</em></p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-03-最多糖果的孩子</title>
    <url>/2025/07/24/LeetCode-03-Kids_With_Candies/</url>
    <content><![CDATA[<p>LeetCode算法题：寻找糖果数最多的孩子。</p>
<span id="more"></span>
<h2 id="题目">题目</h2>
<p>LeetCode：<a href="https://leetcode.cn/studyplan/leetcode-75/">LeetCode 75 -
学习计划</a>-03-拥有最多糖果的孩子</p>
<p>有 <code>n</code> 个有糖果的孩子。给你一个数组
<code>candies</code>，其中 <code>candies[i]</code> 代表第 <code>i</code>
个孩子拥有的糖果数目，和一个整数 <code>extraCandies</code>
表示你所有的额外糖果的数量。</p>
<p>返回一个长度为 <code>n</code> 的布尔数组
<code>result</code>，如果把所有的 <code>extraCandies</code> 给第
<code>i</code> 个孩子之后，他会拥有所有孩子中 <strong>最多</strong>
的糖果，那么 <code>result[i]</code> 为 <code>true</code>，否则为
<code>false</code>。</p>
<p>注意，允许有多个孩子同时拥有 <strong>最多</strong> 的糖果数目。</p>
<h2 id="思路">思路</h2>
<p>题目简单，两次循环即可。首次遍历出最大值，二次将变化后的累加值与最大值比较。</p>
<h2 id="代码">代码</h2>
<p>以下代码时间复杂度为O(n)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span>* <span class="title function_">kidsWithCandies</span><span class="params">(<span class="type">int</span>* candies, <span class="type">int</span> candiesSize, <span class="type">int</span> extraCandies, <span class="type">int</span>* returnSize)</span> </span><br><span class="line">&#123;</span><br><span class="line">    assert(candies);</span><br><span class="line">    assert(returnSize);</span><br><span class="line">    <span class="type">bool</span> *result = (<span class="type">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>)*candiesSize);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> candiesMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; candiesSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        candiesMax &lt; candies[i]? ( candiesMax = candies[i] ):<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>; i&lt;candiesSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         result[i] = (candies[i] + extraCandies &gt;= candiesMax)?  <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = candiesSize;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p><em>有理想</em></p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>ZYNQ-01-ZYNQ7020 TCP例程自动协商失败解决办法</title>
    <url>/2025/07/19/ZYNQ-01-ZYNQ_TCP_Demo_Error/</url>
    <content><![CDATA[<p>本博文介绍ZYNQ SDK默认Lwip
Demo自动协商失败问题解决办法，如有相同情况，请先检查网线是不是千兆网…</p>
<span id="more"></span>
<h1 id="场景复现">场景复现</h1>
<ul>
<li>开发环境：Xilinx Vivado 18.3 SDK</li>
<li>芯片：ZYNQ 7020</li>
<li>调试工具：串口调试助手</li>
<li>接线：开发板直连PC口</li>
</ul>
<p>使用SDK工具新建TCP echo server模板项目后，板验证报错信息如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Start PHY autonegotiation </span><br><span class="line">Waiting <span class="keyword">for</span> PHY to complete autonegotiation.</span><br><span class="line">Auto negotiation error  </span><br><span class="line">Phy setup error  </span><br><span class="line">Assert due to phy setup failure </span><br></pre></td></tr></table></figure>
<p>博主在手动设定速率后重新配置为自动协商试图复现异常，但是结果却又协商成功了？如下图。</p>
<div>
<center>
<img src="image-20250719222443418.png" alt="image can't load." style="zoom:75%"> <br> 重新配置为自动协商
</center>
</div>
<h1 id="解决办法">解决办法</h1>
<p>优先放置解决办法，感兴趣的可以向下翻阅原因分析。</p>
<p>1.修改BSP配置</p>
<div>
<center>
<img src="image-20250719191118162.png" alt="image can't load." style="zoom:55%"> <br> phy link speed
</center>
</div>
<p>2.手动指定连接速度-100Mbps</p>
<div>
<center>
<img src="image-20250719191417696.png" alt="image can't load." style="zoom:55%"> <br> BSP’s Setting
</center>
</div>
<p>3.注释掉<code>platform_zynq.c</code>文件中定时器回调函数<code>time_callback</code>中代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* For detecting Ethernet phy link status periodically */</span></span><br><span class="line">	<span class="comment">/* if (DetectEthLinkStatus == ETH_LINK_DETECT_INTERVAL) &#123;</span></span><br><span class="line"><span class="comment">		eth_link_detect(echo_netif);</span></span><br><span class="line"><span class="comment">		DetectEthLinkStatus = 0;</span></span><br><span class="line"><span class="comment">	&#125;	*/</span></span><br></pre></td></tr></table></figure>
<p>4.配置ip</p>
<ul>
<li><p>ZYNQ</p>
<div>
<center>
<img src="image-20250719192756638.png" alt="image can't load." style="zoom:75%"> <br> ZYNQ Config
</center>
</div></li>
<li><p>PC</p>
<div>
<center>
<img src="image-20250719192930341.png" alt="image can't load." style="zoom:75%"> <br> PC Config
</center>
</div></li>
</ul>
<p>5.串口调试工具配置</p>
<div>
<center>
<img src="image-20250719193107631.png" alt="image can't load." style="zoom:65%"> <br> 串口工具
</center>
</div>
<h1 id="原因分析">原因分析</h1>
<h2 id="ip配置错误">IP配置错误？</h2>
<p>最先考虑的是PC与ZYNQ开发板的ip地址不在同一网段，但将ip均配置在<code>192.168.1.xx</code>网段下之后仍然出现异常。</p>
<h2 id="pc端速度限制">PC端速度限制？</h2>
<div>
<center>
<img src="image-20250719223948825.png" alt="image can't load." style="zoom:65%"> <br> PC端网口速度
</center>
</div>
<p>众所周知，PC机在连接以太网之后可以更改连接速度。参考<a href="https://blog.csdn.net/wsnd123321/article/details/129457547">资料3</a>手动将PC端网口速率从自动协商指定为1Gbps，喜提<span style="color:red"><strong>网络未连接</strong></span>。</p>
<p>速度和双工配置重新调整为自动协商后，连接状态变为上图100Mbps。</p>
<h2 id="劣质网线">劣质网线…</h2>
<p>破案，是劣质网线不支持1000Mbps…</p>
<p><span style="color:red"><strong>从水晶头看到线芯颜色是银白色，胶皮标识为CAT5E超五类，找到订单查材质是铝镁合金、商品名为百兆网线…</strong></span></p>
<p><strong>5m长的网线费用高达人民币3.39元，他能跑百兆我应该夸它耐造….</strong></p>
<h1 id="参考资料">参考资料</h1>
<ol type="1">
<li><a href="https://www.amengcc.cn/index.php/archives/1258/">zynq调试网口所遇到的问题记录
| AMENG</a></li>
<li><a href="https://www.amengcc.cn/index.php/archives/1260/">ZYNQ lwip
自适应网络速率 | AMENG</a></li>
<li><a href="https://blog.csdn.net/wsnd123321/article/details/129457547">修复
win10/11 以太网网速被限制在 100Mbps_win11千兆网卡只有100mbps |
CSDN博客</a></li>
</ol>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p><em>“少无适俗韵，性本爱丘山。”– 《 归园田居·其一》</em></p>
</blockquote>
]]></content>
      <categories>
        <category>电子类</category>
        <category>ZYNQ</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>自动协商</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP-协议详解</title>
    <url>/2025/07/19/TCP-Protocol/</url>
    <content><![CDATA[<p>本篇博文主要介绍TCP/IP协议特性。</p>
<span id="more"></span>
<h1 id="osi模型">OSI模型</h1>
<p>TCP/IP协议族常用的应用层协议包括：</p>
<ul>
<li>HTTP(Hyper Text Transfer
Protocol)：超文本传输协议，<客户端-服务端>形式。<span style="color:red"><strong>属于单向同步协议，耗费资源多，不适合实时控制场合。</strong></span></客户端-服务端></li>
<li>FTP(File Transfer
Protocl):文件传输协议，多个设备间共享文件，如文件上传/下载、目录操作、权限设置等。</li>
<li>MQTT(Messege Queue Telemerty
Transport):消息队列遥测传输，用于推送消息，实时聊天等。</li>
</ul>
<p>按照OSI模型，TCP/IP协议被分为7层：物理层、网络层、链路层、传输层、会话层、表示层。<strong>但实际使用时常用5层表示，由下至上分别为：</strong></p>
<ul>
<li><strong>物理层: PHY</strong></li>
<li><strong>链路层: MAC</strong></li>
<li><strong>网络层: IP、ICMP、ARP</strong></li>
<li><strong>传输层: TCP、UDP</strong></li>
<li><strong>应用层: DNS、HTTP、FTP、SMTP</strong></li>
</ul>
<h1 id="tcp协议特性">TCP协议特性</h1>
<p><strong>TCP是采用数据流形式传输的全双工通信方式，传输过程中，发送方将数据起始编号与长度放在TCP报文中，接收方将所有数据按编号拼接后返回确认，传输双方的数据标号互相独立。</strong></p>
<h2 id="连接确认与重传">连接、确认与重传</h2>
<p>TCP是面向连接的协议，传输前必须有双方IP地址与端口号进行连接验证。传输中接收方在收到数据后必须返回确认结果，否则超时未确认后发送方认为发送失败，进行数据重传。由于IP层是无连接的。数据和确认都可能丢失，因此发送端在超时还未收到确认时进行重传。</p>
<blockquote>
<p>类似于IIC或者CAN协议穿插在数据流中的应答位，TCP为附在其他报文中的确认机制</p>
</blockquote>
<p>TCP协议连接包括传输层与应用层的连接，每个主机有IP的主机可以提供不同Web、FTP、SMTP等不同线程，通过不同端口来实现线程区分。</p>
<blockquote>
<p>类似RTOS中多个任务有各自独特的TCB</p>
</blockquote>
<ul>
<li>20/21：FTP，文件传输协议</li>
<li>23：Telnet，远程登录终端协议</li>
<li>25：SMTP，简单邮件传输协议</li>
<li>69：TFTP，普通文件传输协议</li>
<li>80：HTTP，超文本传输协议</li>
<li>110：POP3，邮局协议版本3</li>
</ul>
<h3 id="三次握手">三次握手</h3>
<p>两个主机连接以后，由客户端A建立连接。A首先向B发送空包，通过3个包判断A、B两端的seqno和ackno序号是否一致判断是否连接成功。过程如下：</p>
<ol type="1">
<li><p>A向B发序号，B收到并将其+1作为应答序号，回送给A;</p>
<p>====&gt; B知晓A-&gt;B连通</p></li>
<li><p>A判断B发送的应答序号，同时将B的序号+1作为应答序号，回送给B；</p>
<p>A的seqno = B的ackno ====&gt; A知晓A-&gt;B、B-&gt;A连通</p></li>
<li><p>B收到A的应答序号；</p>
<p>A的ackno = B的seqno ====&gt; B知晓B-&gt;A联通</p></li>
</ol>
<p>同时引入SYN同步头标志与ACK应答标志，附加自己窗口大小(用于流量控制)，得流程简图如下：</p>
<div>
<center>
<img src="build_link.jpg" alt="image can't load." style="zoom:100%"> <br> TCP三次握手<!--标题-->
</center>
</div>
实际抓包结果如下:
<div>
<center>
<img src="image-20250720181903491.png" alt="image can't load." style="zoom:60%"> <br> Wireshrak三次握手抓包
</center>
</div>
<ol type="1">
<li>PC-&gt;ZYNQ: SYN = 1，发起同步；seqno = ..0698</li>
<li>ZYNQ-&gt;PC: SYN = 1，发起同步；ACK = 1，应答上一报文； seqno =
16326，ackno = seqno + 1 = ..00699；</li>
<li>PC-&gt;ZYNQ: SYN = 0，同步结束；ACK = 1，应答上一报文； seqno =
..00699，ackno = seqno + 1 = 16327；</li>
</ol>
<p>执行无误后即同步完成，双方建立连接。</p>
<p>###　四次挥手</p>
<p>通常来说，TCP协议断开时是四次挥手，分别断开两个主机间的两条信号通路。大致过程如下：</p>
<ul>
<li><p>C向D发送断开连接报文，D接收并应答</p>
<p>====&gt; D端知晓C端主动断开发送的请求</p></li>
<li><p>C收到D端应答</p>
<p>====&gt; 断开C-&gt;D的报文发送流向</p></li>
<li><p>D向C发送断开连接报文，C接收并应答</p>
<p>====&gt; C端知晓D端主动断开发送的请求</p></li>
<li><p>D收到C端应答</p>
<p>====&gt; 断开D-&gt;C的报文流向</p></li>
</ul>
<p>类似SYN同步头，引入FIN标志作为中止连接表示。</p>
<div>
<center>
<img src="break_link.jpg" alt="image can't load." style="zoom:100%"> <br> TCP四次挥手
</center>
</div>
<p><strong>为什么是四次挥手？</strong></p>
<p>下方小节提到，TCP通信双方均会设置一个缓存区，例如本例中PC端为65535、ZYNQ端为2048。有可能ZYNQ在主动断开连接后PC端的数据尚未完全发送，仍然有PC-&gt;ZYNQ方向的报文帧，ZYNQ停止发送但仍保持接收。直到PC端数据发送完成，PC主动断开连接，ZYNQ发送应答。共计4次。</p>
<h3 id="三次挥手tcp延时应答">三次挥手?TCP延时应答</h3>
<p>在实际测试过程中PC端断开TCP连接只发现3次挥手？似乎与常说的4次不符合，如下图。</p>
<div>
<center>
<img src="image-20250720215038251.png" alt="image can't load." style="zoom:75%"> <br> TCP三次挥手
</center>
</div>
<p>查阅TCP协议标准参考文档<a href="https://www.rfc-editor.org/rfc/rfc793">RFC 793</a>第3.5节有关Close
Connection的说明，其介绍了3种情况:</p>
<blockquote>
<p>There are essentially three cases: 1) The user initiates by telling
the TCP to CLOSE the connection 2) The remote TCP initiates by sending a
FIN control signal 3) Both users CLOSE simultaneously</p>
</blockquote>
<p>无论是单端关闭TCP还是双端同时关闭，均与实测结果不同。但网络上能查找到类似现象的解析，例如<a href="https://zorrozou.github.io/docs/tcp/wavehand/TCP_Wavehand.html">参考资料5</a>中对Linux下的源码进行分析，其中提到了<strong>延时应答机制</strong>。所以LwIP协议栈应当有类似的措施或解决办法，查阅<a href="https://www.cnblogs.com/lizhuming/p/17438743.html">参考资料6</a>中对LwIP的源码分析。</p>
<p>找到<code>tcp.c</code>文件中的<code>tcp_fasttmr()</code>函数：该函数用于每250ms处理被应用层拒绝的数据并且发送延时应答。</p>
<blockquote>
<p>Is called every TCP_FAST_INTERVAL (250 ms) and process data
previously “refused” by upper layer (application) and sends delayed
ACKs.</p>
</blockquote>
<p>其中有以下代码段：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pcb-&gt;flags &amp; TF_ACK_DELAY) <span class="comment">//到达延迟时间</span></span><br><span class="line">&#123;</span><br><span class="line">    LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_fasttmr: delayed ACK\n&quot;</span>));</span><br><span class="line">    tcp_ack_now(pcb);</span><br><span class="line">    tcp_output(pcb);</span><br><span class="line">    pcb-&gt;flags &amp;= ~(TF_ACK_DELAY | TF_ACK_NOW); <span class="comment">//ACK复位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即在每250ms时刻调用<code>tcp_ack_now(pcb)</code>函数使能立即发送延时ACK，并使用对外输出函数<code>tcp_output()</code>向外输出。函数<code>tcp_output()</code>中定义了延时ACK的处理方式：</p>
<ul>
<li><strong>如果TF_ACK_NOW使能且没有数据待发送，则组一个空的ACK报文立即发送</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* If the TF_ACK_NOW flag is set and no data will be sent (either</span></span><br><span class="line"><span class="comment"> * because the -&gt;unsent queue is empty or because the window does</span></span><br><span class="line"><span class="comment"> * not allow it), construct an empty ACK segment and send it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If data is to be sent, we will just piggyback the ACK (see below).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (pcb-&gt;flags &amp; TF_ACK_NOW &amp;&amp;</span><br><span class="line">   (seg == <span class="literal">NULL</span> ||</span><br><span class="line">    lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len &gt; wnd)) &#123;</span><br><span class="line">   <span class="keyword">return</span> tcp_send_empty_ack(pcb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="防御性设计">防御性设计</h2>
<ul>
<li><p>缓存</p>
<p>由于发送方的数据大小、类型不定，TCP提供缓存机制处理数据。<strong>数据量过小时，TCP将数据存储在缓存中，等到数据量够大时发送，待接收方应答后再删除(便于无应答时重传)</strong>。</p>
<blockquote>
<p>​ 类似于CAN短帧以8字节为单位发送</p>
</blockquote></li>
<li><p>流量控制</p>
<p><strong>两种控制方式本质是希望匹配收发双方和中间路由的传输速度。</strong>TCP
提供了流量控制服务（flow-control
service）以消除发送方使接收方缓冲区溢出的可能性。</p>
<p><strong>流量控制是速度匹配，用于匹配收发双方读写速率。</strong>TCP
通过让发送方维护一个称为接收窗口（receive
window）的变量来提供流量控制，用于给发送方指示：接收方还能接收多少数据，接收方会将此窗口值放在TCP
报文的首部中的窗口字段传递给发送方，窗口大小是在发送数据时动态调整的。</p>
<blockquote>
<p>如果接收方窗口为0，则发送方发送只有1个字节的报文段，直到缓存清空并在确认报文中包含一个非0的接收窗口值。</p>
</blockquote>
<p><strong>在确定接收方窗口值之后，发送方可动态调整窗口大小对外发送数据。</strong></p>
<blockquote>
<p>滑动窗口思路</p>
</blockquote></li>
<li><p>拥塞控制</p>
<p>如果两个千兆主机之间经过百兆路由，即便双方主机均有能力处理500Mbps的数据，但仍收到路由的限制，因此发送方需要实现自适应机制，对发送方成为拥塞机制。<strong>流量控制限制单次通信数据量，拥塞控制协调设备间速率。</strong></p></li>
<li><p>差错控制</p>
<p>或者说是校验机制。<strong>TCP协议采用校验和进行校验，主机接收时丢弃重复报文、重组乱序报文、请求重发丢失报文。</strong></p></li>
</ul>
<h1 id="tcp报文结构">TCP报文结构</h1>
<p>TCP是基于字节流方式的传输，各个协议层之间数据传输均会增删各层的数据头：</p>
<div>
<center>
<img src="osi.jpg" alt="image can't load." style="zoom:75%"> <br> TCP/IP协议栈报文封装
</center>
</div>
<p>在LwIP协议栈中<code>lwip-2.0.2/src/include/lwip/port/tcp.h</code>中，<code>tcp_hdr</code>定义TCP报文帧的组成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_hdr</span> &#123;</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u16_t</span> src);	<span class="comment">/* 源端口 */</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u16_t</span> dest);<span class="comment">/* 目标端口 */</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u32_t</span> seqno);<span class="comment">/* 序号 */</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u32_t</span> ackno);<span class="comment">/* 确认序号 */</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u16_t</span> _hdrlen_rsvd_flags);<span class="comment">/* 首部长度+保留位+标志 */</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u16_t</span> wnd);<span class="comment">/* 窗口大小 */</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u16_t</span> chksum);<span class="comment">/* 校验和 */</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u16_t</span> urgp); <span class="comment">/* 紧急指针 */</span></span><br><span class="line">&#125; PACK_STRUCT_STRUCT;</span><br></pre></td></tr></table></figure>
<p>可以与下方的TCP报文结构对应：</p>
<div>
<center>
<img src="tcp_msg.jpg" alt="image can't load." style="zoom:100%"> <br> TCP报文
</center>
</div>
<ul>
<li>src、dst：源端、目标端的端口</li>
<li>seqno：发送端起始字节位置码，方便对数据进行管理</li>
<li>ackno：上次已成功收到数据的最后一个字节序号+1，ACK=1时有效。<strong>ackno通常会封装在反向数据报文中。</strong></li>
<li>wnd：窗口大小。起始端配置seqno确定发送字节数，实现流量控制。接收方返回wnd=0时，发送端停止发送。</li>
<li>chksum：校验值。覆盖TCP所有数据。</li>
<li>urgp：紧急指针。相对于seqno的正偏移量，表示前urgp个数据为紧急数据。</li>
</ul>
<p>标志位说明：</p>
<ul>
<li><p>hdrlen：首部字节数，4bit，单位为字。最大60Byte。</p></li>
<li><p>rsvd：保留值</p></li>
<li><p>URG：urgp使能</p></li>
<li><p>ACK：ackno使能</p></li>
<li><p>PSH：push使能。=1时尽快将报文端推送给应用层</p></li>
<li><p>RST：复位tcp连接</p></li>
<li><p>SYN：首次建立新连接时，SYN=1，序号字段包含主机随机的初始序号ISN。该主机发送数据的第一个字节序号为ISN+1。</p></li>
<li><p>FIN：中止连接</p></li>
</ul>
<blockquote>
<p>与CAN类似，源节点+目标节点+应答+数据+校验，但多了窗口值、序号、应答序号、紧急指针。CAN可以8Byte为单帧进行收发。</p>
</blockquote>
<p>PC与ZYNQ建立连接时首次的“握手”的帧为例：</p>
<div>
<center>
<img src="image-20250720175218054.png" alt="image can't load." style="zoom:60%"> <br> PC建立连接
</center>
</div>
<ul>
<li>src: 61816</li>
<li>dst: 7</li>
<li>seqno: ..1677</li>
<li>ackno: 0</li>
<li>hdrlen: 32</li>
<li>SYN: 1</li>
<li>wnd: 65535</li>
<li>chksum: 0x7407</li>
<li>urgp: 0</li>
</ul>
<h1 id="tcp连接状态">TCP连接状态</h1>
<p>LwIP协议中，<code>lwip-2.0.2/src/core/tcp.c</code>文件内定义了TCP协议中11种状态。</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 限制初始报文发送段最大长度为536B，后续可在SYN连接里动态修改. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_MSS &gt; 536</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INITIAL_MSS 536</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INITIAL_MSS TCP_MSS</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* 11种连接状态 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> tcp_state_str[] = &#123;</span><br><span class="line">  <span class="string">&quot;CLOSED&quot;</span>,			<span class="comment">//关闭状态-无连接</span></span><br><span class="line">  <span class="string">&quot;LISTEN&quot;</span>,			<span class="comment">//监听态</span></span><br><span class="line">  <span class="string">&quot;SYN_SENT&quot;</span>,		<span class="comment">//发起SYN</span></span><br><span class="line">  <span class="string">&quot;SYN_RCVD&quot;</span>,		<span class="comment">//收到SYN</span></span><br><span class="line">  <span class="string">&quot;ESTABLISHED&quot;</span>, 	<span class="comment">//稳定连接</span></span><br><span class="line">  <span class="string">&quot;FIN_WAIT_1&quot;</span>,		<span class="comment">//单向终止</span></span><br><span class="line">  <span class="string">&quot;FIN_WAIT_2&quot;</span>,		<span class="comment">//对方应答终止</span></span><br><span class="line">  <span class="string">&quot;CLOSE_WAIT&quot;</span>,		<span class="comment">//等待终止</span></span><br><span class="line">  <span class="string">&quot;CLOSING&quot;</span>,		<span class="comment">//两端同时关闭</span></span><br><span class="line">  <span class="string">&quot;LAST_ACK&quot;</span>,		<span class="comment">//服务器等待对方关闭</span></span><br><span class="line">  <span class="string">&quot;TIME_WAIT&quot;</span>		<span class="comment">//关闭成功-2MSL等待状态</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>由于TCP为全双工通信，客户端与服务端的行为基本一致，通过以下流程图介绍客户端与服务器的状态变迁，其中，蓝色实线与红色实线是序号对应，可以组成一次完整的连接过程。红色虚线则表示特殊情况，即客户端与服务器同时发送SYN，使得客户端进入TCP_RSVD状态，如果此时：
+ 收到ACK，进入ESTABLISHED + 收到RST，恢复LISTEN +
内存不足导致客户端进程结束，或服务端ACK应答超时，进入FIN_WAIT_1</p>
<div>
<center>
<img src="tcp_state_change.jpg" alt="image can't load." style="zoom:60%"> <br> TCP状态切换
</center>
</div>
<h1 id="tcp数据结构">TCP数据结构</h1>
<p>类比FreeRTOS任务的任务控制块TCB，LwIP中有同样的协议控制块PCB：</p>
<p>IP块：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IP_PCB \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* ip addresses in network byte order */</span> \</span></span><br><span class="line"><span class="meta">  ip_addr_t local_ip; \</span></span><br><span class="line"><span class="meta">  ip_addr_t remote_ip; \</span></span><br><span class="line"><span class="meta">   <span class="comment">/* Socket options */</span>  \</span></span><br><span class="line"><span class="meta">  u8_t so_options;      \</span></span><br><span class="line"><span class="meta">   <span class="comment">/* Type Of Service */</span> \</span></span><br><span class="line"><span class="meta">  u8_t tos;              \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* Time To Live */</span>     \</span></span><br><span class="line"><span class="meta">  u8_t ttl               \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* link layer address resolution hint */</span> \</span></span><br><span class="line"><span class="meta">  IP_PCB_ADDRHINT</span></span><br></pre></td></tr></table></figure>
<p>本地端口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* members common to struct tcp_pcb and struct tcp_listen_pcb */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_PCB_COMMON(type) \</span></span><br><span class="line"><span class="meta">  type *next; <span class="comment">/* for the linked list */</span> \</span></span><br><span class="line"><span class="meta">  void *callback_arg; \</span></span><br><span class="line"><span class="meta">  enum tcp_state state; <span class="comment">/* TCP state */</span> \</span></span><br><span class="line"><span class="meta">  u8_t prio; \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* ports are in host byte order */</span> \</span></span><br><span class="line"><span class="meta">  u16_t local_port</span></span><br></pre></td></tr></table></figure>
<p>TCP协议控制块定义(部分)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** TCP protocol control block */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> &#123;</span></span><br><span class="line"><span class="comment">/** 通用PCB成员 */</span></span><br><span class="line">  IP_PCB;</span><br><span class="line"><span class="comment">/** 特定PCB成员 */</span></span><br><span class="line">  TCP_PCB_COMMON(<span class="keyword">struct</span> tcp_pcb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 服务端口号 */</span></span><br><span class="line">  <span class="type">u16_t</span> remote_port;</span><br><span class="line">	...</span><br><span class="line">  <span class="comment">/* the rest of the fields are in host byte order</span></span><br><span class="line"><span class="comment">     as we have to do some math with them */</span></span><br><span class="line">  <span class="comment">/* Timers */</span></span><br><span class="line">  <span class="type">u8_t</span> polltmr, pollinterval;</span><br><span class="line">  <span class="type">u8_t</span> last_timer; <span class="comment">/* 控制块最后一次被处理的时间 */</span></span><br><span class="line">  <span class="type">u32_t</span> tmr;</span><br><span class="line">  <span class="comment">/* receiver variables */</span></span><br><span class="line">  <span class="type">u32_t</span> rcv_nxt;   <span class="comment">/* 下一次期望收到的seqno */</span></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> rcv_wnd;   <span class="comment">/* 接收窗口大小 */</span></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> rcv_ann_wnd; <span class="comment">/* 告知对方的接收窗大小 */</span></span><br><span class="line">  <span class="type">u32_t</span> rcv_ann_right_edge; <span class="comment">/* 通知窗口右边缘 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Retransmission timer. */</span></span><br><span class="line">  <span class="type">s16_t</span> rtime;</span><br><span class="line">  <span class="type">u16_t</span> mss;   <span class="comment">/* maximum segment size */</span></span><br><span class="line">	....</span><br><span class="line">  <span class="comment">/* fast retransmit/recovery */</span></span><br><span class="line">  <span class="type">u8_t</span> dupacks;	<span class="comment">/* 快速重传 */</span></span><br><span class="line">  <span class="type">u32_t</span> lastack;<span class="comment">/* 最近一次确认序号 */</span> <span class="comment">/* Highest acknowledged seqno. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* congestion avoidance/control variables */</span></span><br><span class="line">  <span class="comment">/* 避免拥塞/流量控制 */</span></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> cwnd;		<span class="comment">/* 连接当前的窗口大小*/</span></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> ssthresh;	<span class="comment">/* 拥塞避免算法启动的阈值 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* sender variables */</span> <span class="comment">/* 发送方变量 */</span></span><br><span class="line">  <span class="type">u32_t</span> snd_nxt;   <span class="comment">/* next new seqno to be sent */</span></span><br><span class="line">  <span class="type">u32_t</span> snd_wl1, snd_wl2; <span class="comment">/* Sequence and acknowledgement numbers of last</span></span><br><span class="line"><span class="comment">                             window update. */</span></span><br><span class="line">  <span class="type">u32_t</span> snd_lbb;       <span class="comment">/* Sequence number of next byte to be buffered. */</span></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> snd_wnd;   <span class="comment">/* sender window */</span></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> snd_wnd_max; <span class="comment">/* the maximum sender window announced by the remote host */</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="comment">/* 保持空闲的控制变量 */</span></span><br><span class="line">  <span class="comment">/* idle time before KEEPALIVE is sent */</span></span><br><span class="line">  <span class="type">u32_t</span> keep_idle;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_TCP_KEEPALIVE</span></span><br><span class="line">  <span class="type">u32_t</span> keep_intvl;</span><br><span class="line">  <span class="type">u32_t</span> keep_cnt;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_TCP_KEEPALIVE */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Persist timer counter */</span></span><br><span class="line">  <span class="type">u8_t</span> persist_cnt;</span><br><span class="line">  <span class="comment">/* Persist timer back-off */</span></span><br><span class="line">  <span class="type">u8_t</span> persist_backoff;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* KEEPALIVE counter */</span> <span class="comment">/* 保活报文的发送次数 */</span></span><br><span class="line">  <span class="type">u8_t</span> keep_cnt_sent;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_WND_SCALE</span></span><br><span class="line">  <span class="type">u8_t</span> snd_scale;</span><br><span class="line">  <span class="type">u8_t</span> rcv_scale;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在两个ip的设备建立连接前，设备处于LISTEN监听态而非ESTABLISHED连接态，LwIP为节省资源定义了<code>tcp_pcb_listen</code>控制块，其中仅保留通用pcb块，在建立连接后将<code>tcp_pcb_listen</code>接入<code>tcp_pcb</code>即可。<code>tcp_pcb_listen</code>块定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** the TCP protocol control block for listening pcbs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb_listen</span> &#123;</span></span><br><span class="line"><span class="comment">/** Common members of all PCB types */</span></span><br><span class="line">  IP_PCB;</span><br><span class="line"><span class="comment">/** Protocol specific PCB members */</span></span><br><span class="line">  TCP_PCB_COMMON(<span class="keyword">struct</span> tcp_pcb_listen);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_CALLBACK_API</span></span><br><span class="line">  <span class="comment">/* Function to call when a listener has been connected. */</span></span><br><span class="line">  tcp_accept_fn accept;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_CALLBACK_API */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_LISTEN_BACKLOG</span></span><br><span class="line">  <span class="type">u8_t</span> backlog;</span><br><span class="line">  <span class="type">u8_t</span> accepts_pending;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_LISTEN_BACKLOG */</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>LwIP中管理各个PCB的链表如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The TCP PCB lists. */</span></span><br><span class="line"><span class="comment">/** List of all TCP PCBs bound but not yet (connected || listening) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">tcp_bound_pcbs</span>;</span></span><br><span class="line"><span class="comment">/** List of all TCP PCBs in LISTEN state */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">tcp_listen_pcbs_t</span> <span class="title">tcp_listen_pcbs</span>;</span></span><br><span class="line"><span class="comment">/** List of all TCP PCBs that are in a state in which</span></span><br><span class="line"><span class="comment"> * they accept or send data. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">tcp_active_pcbs</span>;</span></span><br><span class="line"><span class="comment">/** List of all TCP PCBs in TIME-WAIT state */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">tcp_tw_pcbs</span>;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>无连接时，<code>tcp_bound_pcbs</code>管理；</li>
<li>处于监听态时，<code>tcp_listen_pcbs</code>管理；</li>
<li>其他状态，<code>tcp_active_pcbs</code>管理；</li>
<li>Time-Wait态，<code>tcp_tw_pcbs</code>管理，主动关闭连接后进入；</li>
</ul>
<blockquote>
<p>同样类比FreeRTOS任务管理，阻塞态、就绪态、运行态、挂起态分别使用不同的链表控制，基本能按顺序一一对应。</p>
</blockquote>
<h1 id="tcp滑动窗口">TCP滑动窗口</h1>
<p>TCP是基于字节流的传输方式，每字节都有对应的seq号，窗口则是能发送/接收的segment字段。包括发送方窗口、接收方窗口，目的是利用收发双方的字节序号进行缓存区数据收发的流量控制与重传，设计上是一个滑动窗口。</p>
<h2 id="接收窗口">接收窗口</h2>
<div>
<center>
<img src="rcv_wnd.jpg" alt="image can't load." style="zoom:100%"> <br> TCP接收窗
</center>
</div>
<p>LwIP中关于接收窗的几个变量：</p>
<ul>
<li>rcv_wnd：received window，接收窗大小</li>
<li>rcv_ann_wnd：received annonce window，通知发送方接收窗大小</li>
<li>rcv_nxt：下次期望收到的seqno</li>
<li>rcv_ann_right_edge：通知发送方的窗口右边界</li>
</ul>
<p>收到对端数据后，接收窗口会减小；应用层读走数据后接收窗口会增加。但是窗口的每次增减并不总是会告知对方。</p>
<h2 id="发送窗口">发送窗口</h2>
<div>
<center>
<img src="snd_wnd.jpg" alt="image can't load." style="zoom:100%"> <br> TCP发送窗
</center>
</div>
<p>LwIP中关于发送窗的几个变量：</p>
<ul>
<li>lastack：接收方应答回来的seq序号</li>
<li>snd_wnd：发送方窗口大小</li>
<li>snd_nxt：待发送的下一字节的seq</li>
<li>snd_lbb：load byte to buffer，装载到缓冲区的下一字节seq</li>
</ul>
<p><strong>发送窗口会存在“飞行数据”的情况，即发送端已发送，但未收到确认/应答。<span style="color:red">此时发送窗并不会做出其他操作，直到收到接收方的ackno，随后更新lastack、snd_wnd、snd_nxt、snd_lbb等变量。</span></strong></p>
<h2 id="糊涂窗口">糊涂窗口？</h2>
<p>TCP的窗口采用动态刷新的滑动窗口机制，变量的更改不仅与己方有关，也需要对端的ackno。那么假设一种可能：</p>
<ol type="1">
<li>rcv端窗口接收后应用层一直未读取，直到rcv_wnd与rcv_ann_wnd缩小至20B</li>
<li>snd端收到rcv应答，snd_wnd设为20B，随后发送20B报文</li>
<li>rcv端应用层收到20B，rcv_wnd变为0，向snd应答</li>
<li>rcv端应用层读取20B，随后重复1-4。</li>
</ol>
<p><strong>简单说，当rcv端通告小窗，snd端立即填充小窗，应用层继续读取少量数据，则会出现糊涂窗口综合征SWS
(Silly WindowSyndrome)
。</strong>这种状况将导致大量TCP报文帧只有少量(20B)有效数据，而大量的小包会降低网络利用率甚至造成网络拥塞，降低网络性能。</p>
<p>产生原因有两个：</p>
<ul>
<li>接收端通告较小的rcv_wnd</li>
<li>发送端收到较小的rcv_wnd时，立即响应发出对应小包。</li>
</ul>
<p>按照RFC1122协议，避免SWS的措施：</p>
<ul>
<li><p>对于接收端要避免通告小窗口</p>
<p>避免以小的增量来推进接收窗的右边沿(rcv_nxt+rcv_wnd)，即使接收的数据包都是小包。只有当接收窗口的增量大于min(
Fr * rcv_buff, snd_mss
)的时候才通告新的窗口。其中Fr是一个分数因子，协议建议值为1/2，snd_mss为对端的发送最大段长。</p></li>
<li><p>对于发送端来说在不超出对端接收窗口的前提下至少满足下列三个条件中的一个才能发送数据：</p>
<ol type="1">
<li>一个full-sized的数据包(即大小满足snd_mss)可以被发送；</li>
<li>数据包的大小超过对端曾经通告过的rcv_ann_wnd的一半；</li>
<li>TCP发送端禁用了Nagle算法；</li>
<li>所有发出的数据都已经被对端ACK确认；</li>
</ol></li>
</ul>
<h1 id="tcp报文段">TCP报文段</h1>
<h2 id="报文段缓冲队列">报文段缓冲队列</h2>
<p>tcp_pcb块维护发送/接收端的缓冲区队列指针，定义tcp_seg管理所有未发送、已发送未确认、或已收到的无序报文。</p>
<p>tcp_seg的结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This structure represents a TCP segment on the unsent, unacked and ooseq queues */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_seg</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_seg</span> *<span class="title">next</span>;</span>    <span class="comment">/* 链向下一个报文段 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">p</span>;</span>          <span class="comment">/* 报文段pbuf - buffer containing data + TCP header */</span></span><br><span class="line">  <span class="type">u16_t</span> len;               <span class="comment">/* the TCP length of this segment */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_OVERSIZE_DBGCHECK</span></span><br><span class="line">  <span class="type">u16_t</span> oversize_left;     <span class="comment">/* 当前 未发送数据队列（unsent） 中最后一个 pbuf 的 超出MSS（最大报文段大小）的字节数。 */</span> </span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_OVERSIZE_DBGCHECK */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_CHECKSUM_ON_COPY</span></span><br><span class="line">  <span class="type">u16_t</span> chksum;</span><br><span class="line">  <span class="type">u8_t</span>  chksum_swapped;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_CHECKSUM_ON_COPY */</span></span></span><br><span class="line">  <span class="type">u8_t</span>  flags;			<span class="comment">/* 报文段标志属性 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TF_SEG_OPTS_MSS         (u8_t)0x01U <span class="comment">/* Include MSS option. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TF_SEG_OPTS_TS          (u8_t)0x02U <span class="comment">/* Include timestamp option. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TF_SEG_DATA_CHECKSUMMED (u8_t)0x04U <span class="comment">/* ALL data (not the header) is</span></span></span><br><span class="line"><span class="comment"><span class="meta">                                               checksummed into &#x27;chksum&#x27; */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TF_SEG_OPTS_WND_SCALE   (u8_t)0x08U <span class="comment">/* Include WND SCALE option */</span></span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_hdr</span> *<span class="title">tcphdr</span>;</span>  <span class="comment">/* the TCP header */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>tcp_pcb块中需要维护三个指针，在其定义里有：</p>
<ul>
<li>unsent：未发送的报文段缓冲队列</li>
<li>unacked：已发送但未确认的缓冲队列</li>
<li>ooseq：已收到的无序报文队列</li>
</ul>
<p><strong>可以这么理解，最顶层的tcp_active_pcb变量管理CLOSED、LISTEN、Time-Wait以外状态的tcp_pcb块变量。各个tcp_pcb块包含不同的ip和port，管理各自的unsent、unacked、ooseq链表，每个链表又包含多个不同的tcp_seg报文段，同样用链表管理。</strong></p>
<div>
<center>
<img src="tcp_cache_queue.jpg" alt="image can't load." style="zoom:100%"> <br> TCP缓存队列
</center>
</div>
<h2 id="报文段发送">报文段发送</h2>
<p>若使用NETCONN
API编程，当数据到达传输层后，会调用<code>lwip_netconn_do_writemore()</code>函数对发送数据，处理TCP报文段缓存操作是在<code>tcp_write()</code>函数中。LwIP在将数据写入缓冲区，利用Nagle算法进行发送，最后调用<code>tcp_output()</code>
函数将数据传输至IP层，tcp_out源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">err_t</span></span><br><span class="line"><span class="title function_">tcp_output</span><span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_seg</span> *<span class="title">seg</span>, *<span class="title">useg</span>;</span></span><br><span class="line">  <span class="type">u32_t</span> wnd, snd_nxt;</span><br><span class="line">  <span class="type">err_t</span> err;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netif</span> *<span class="title">netif</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_CWND_DEBUG</span></span><br><span class="line">  <span class="type">s16_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_CWND_DEBUG */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* pcb-&gt;state LISTEN not allowed here */</span></span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;don&#x27;t call tcp_output for listen-pcbs&quot;</span>,</span><br><span class="line">    pcb-&gt;state != LISTEN);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 当前控制块正在处理输入数据，则退出 */</span></span><br><span class="line">  <span class="keyword">if</span> (tcp_input_pcb == pcb) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERR_OK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 获取发送窗snd_wnd与流量/拥塞控制窗cwnd中较小的 */</span></span><br><span class="line">  wnd = LWIP_MIN(pcb-&gt;snd_wnd, pcb-&gt;cwnd);</span><br><span class="line">  <span class="comment">/* 报文段切换为pcb中未发送的unsent链表 */</span></span><br><span class="line">  seg = pcb-&gt;unsent;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* flag中ACK被置位为立即发送，但是 </span></span><br><span class="line"><span class="comment">   * 1)无数据待发</span></span><br><span class="line"><span class="comment">   * 2)本次发送的报文段占据的序列号空间seqno-lastack +len大于接收方窗口大小wnd，接收方没有能力接收</span></span><br><span class="line"><span class="comment">   * 立即发送一个空包ACK</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;flags &amp; TF_ACK_NOW &amp;&amp;</span><br><span class="line">     (seg == <span class="literal">NULL</span> ||</span><br><span class="line">      lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len &gt; wnd)) &#123;</span><br><span class="line">     <span class="keyword">return</span> tcp_send_empty_ack(pcb);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* useg指向最近一次发送但未应答队列unacked报文段，便于超时重传 */</span></span><br><span class="line">  useg = pcb-&gt;unacked;</span><br><span class="line">  <span class="keyword">if</span> (useg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; useg-&gt;next != <span class="literal">NULL</span>; useg = useg-&gt;next);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 底层调用ip4_route函数进行路由查找，检查网口是否可用（UP+链路+IP），匹配子网或路由 */</span></span><br><span class="line">  netif = ip_route(&amp;pcb-&gt;local_ip, &amp;pcb-&gt;remote_ip);</span><br><span class="line">  <span class="keyword">if</span> (netif == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERR_RTE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 若pcb未绑定本地ip，调用ip_netif_get_local_ip从netif中获取ip */</span></span><br><span class="line">  <span class="keyword">if</span> (ip_addr_isany(&amp;pcb-&gt;local_ip)) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">ip_addr_t</span> *local_ip = ip_netif_get_local_ip(netif, &amp;pcb-&gt;remote_ip);</span><br><span class="line">    <span class="keyword">if</span> (local_ip == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ERR_RTE;</span><br><span class="line">    &#125;</span><br><span class="line">    ip_addr_copy(pcb-&gt;local_ip, *local_ip);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_OUTPUT_DEBUG</span></span><br><span class="line">  <span class="keyword">if</span> (seg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, (<span class="string">&quot;tcp_output: nothing to send (%p)\n&quot;</span>,</span><br><span class="line">                                   (<span class="type">void</span>*)pcb-&gt;unsent));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_OUTPUT_DEBUG */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_CWND_DEBUG</span></span><br><span class="line">  <span class="keyword">if</span> (seg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    LWIP_DEBUGF(TCP_CWND_DEBUG, (<span class="string">&quot;tcp_output: snd_wnd %&quot;</span>TCPWNDSIZE_F</span><br><span class="line">                                 <span class="string">&quot;, cwnd %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;, wnd %&quot;</span>U32_F</span><br><span class="line">                                 <span class="string">&quot;, seg == NULL, ack %&quot;</span>U32_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                                 pcb-&gt;snd_wnd, pcb-&gt;cwnd, wnd, pcb-&gt;lastack));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LWIP_DEBUGF(TCP_CWND_DEBUG,</span><br><span class="line">                (<span class="string">&quot;tcp_output: snd_wnd %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;, cwnd %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;, wnd %&quot;</span>U32_F</span><br><span class="line">                 <span class="string">&quot;, effwnd %&quot;</span>U32_F<span class="string">&quot;, seq %&quot;</span>U32_F<span class="string">&quot;, ack %&quot;</span>U32_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                 pcb-&gt;snd_wnd, pcb-&gt;cwnd, wnd,</span><br><span class="line">                 lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len,</span><br><span class="line">                 lwip_ntohl(seg-&gt;tcphdr-&gt;seqno), pcb-&gt;lastack));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_CWND_DEBUG */</span></span></span><br><span class="line">    <span class="comment">/* 处理不适合窗口的报文段 */</span></span><br><span class="line">  <span class="keyword">if</span> (seg != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">      lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len &gt; wnd &amp;&amp;</span><br><span class="line">      wnd &gt; <span class="number">0</span> &amp;&amp; wnd == pcb-&gt;snd_wnd &amp;&amp; pcb-&gt;unacked == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* 启动persist持久化定时器 */</span></span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;persist_backoff == <span class="number">0</span>) &#123;</span><br><span class="line">      pcb-&gt;persist_cnt = <span class="number">0</span>;</span><br><span class="line">      pcb-&gt;persist_backoff = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> output_done; <span class="comment">//跳转至最后</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 数据可用且窗口允许发送，while直到发送完成 */</span></span><br><span class="line">  <span class="keyword">while</span> (seg != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">         lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len &lt;= wnd) </span><br><span class="line">  &#123;</span><br><span class="line">        LWIP_ASSERT(<span class="string">&quot;RST not expected here!&quot;</span>,</span><br><span class="line">                    (TCPH_FLAGS(seg-&gt;tcphdr) &amp; TCP_RST) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* tcp_do_output_nagel(pcb)检查nagle算法是否允许发送,1允许，0禁止。在Nagle禁止时</span></span><br><span class="line"><span class="comment">       * 1)若Nagle内存出错，及时发送ACK</span></span><br><span class="line"><span class="comment">       * 2)FIN已在队列中，终端连接</span></span><br><span class="line"><span class="comment">       * RST不使用tcp_output发送</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">if</span> ((tcp_do_output_nagle(pcb) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">          ((pcb-&gt;flags &amp; (TF_NAGLEMEMERR | TF_FIN)) == <span class="number">0</span>)) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> TCP_CWND_DEBUG</span></span><br><span class="line">        LWIP_DEBUGF(TCP_CWND_DEBUG, (<span class="string">&quot;tcp_output: snd_wnd %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;, cwnd %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;, wnd %&quot;</span>U32_F<span class="string">&quot;, effwnd %&quot;</span>U32_F<span class="string">&quot;, seq %&quot;</span>U32_F<span class="string">&quot;, ack %&quot;</span>U32_F<span class="string">&quot;, i %&quot;</span>S16_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                                pcb-&gt;snd_wnd, pcb-&gt;cwnd, wnd,</span><br><span class="line">                                lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) + seg-&gt;len -</span><br><span class="line">                                pcb-&gt;lastack,</span><br><span class="line">                                lwip_ntohl(seg-&gt;tcphdr-&gt;seqno), pcb-&gt;lastack, i));</span><br><span class="line">        ++i;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_CWND_DEBUG */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 未处于建立连接的SYN态，需要在tcp结构里置位ACK，捎带应答 */</span></span><br><span class="line">        <span class="keyword">if</span> (pcb-&gt;state != SYN_SENT) &#123;</span><br><span class="line">          TCPH_SET_FLAG(seg-&gt;tcphdr, TCP_ACK); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> TCP_OVERSIZE_DBGCHECK</span></span><br><span class="line">        seg-&gt;oversize_left = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_OVERSIZE_DBGCHECK */</span></span></span><br><span class="line">        <span class="comment">/* IP传输层使用ip_output_if函数，发送当前pcb块中的unsent报文段 */</span></span><br><span class="line">        err = tcp_output_segment(seg, pcb, netif);</span><br><span class="line">        <span class="keyword">if</span> (err != ERR_OK) &#123;</span><br><span class="line">          <span class="comment">/* 无论何种原因，报文段未发送 */</span></span><br><span class="line">          pcb-&gt;flags |= TF_NAGLEMEMERR; <span class="comment">/* Nagle 存储错误 */</span></span><br><span class="line">          <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pcb-&gt;unsent = seg-&gt;next; <span class="comment">/* 未发送链表指向下一个seg段 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pcb-&gt;state != SYN_SENT) &#123;</span><br><span class="line">          pcb-&gt;flags &amp;= ~(TF_ACK_DELAY | TF_ACK_NOW);<span class="comment">/* 发送完后设定延时应答状态 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 计算下一个snd_nxt新序列号 seq+length(seq) */</span></span><br><span class="line">        snd_nxt = lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) + TCP_TCPLEN(seg); </span><br><span class="line">        <span class="keyword">if</span> (TCP_SEQ_LT(pcb-&gt;snd_nxt, snd_nxt)) &#123;</span><br><span class="line">          pcb-&gt;snd_nxt = snd_nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 本段有效长度大于0放入unacked链表，等待rcv端ACK */</span></span><br><span class="line">        <span class="keyword">if</span> (TCP_TCPLEN(seg) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          seg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">          <span class="comment">/* unacked list is empty? */</span></span><br><span class="line">          <span class="keyword">if</span> (pcb-&gt;unacked == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pcb-&gt;unacked = seg;</span><br><span class="line">            useg = seg;</span><br><span class="line">          <span class="comment">/* unacked list is not empty? */</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 如果当前报文段seq序号小于未收到应答unacked链表最近的seq序号，需要对链表进行重排(按序) */</span></span><br><span class="line">            <span class="keyword">if</span> (TCP_SEQ_LT(lwip_ntohl(seg-&gt;tcphdr-&gt;seqno), lwip_ntohl(useg-&gt;tcphdr-&gt;seqno))) 			&#123;</span><br><span class="line">              <span class="comment">/* 将报文段按顺序增加在中间位置 */</span></span><br><span class="line">              <span class="keyword">struct</span> tcp_seg **cur_seg = &amp;(pcb-&gt;unacked);</span><br><span class="line">              <span class="comment">/* 找到unacked中第一个seqno ≥ 当前发送报文段seqno的节点 */</span></span><br><span class="line">              <span class="keyword">while</span> (*cur_seg &amp;&amp;</span><br><span class="line">                TCP_SEQ_LT(lwip_ntohl((*cur_seg)-&gt;tcphdr-&gt;seqno), lwip_ntohl(seg-&gt;tcphdr-&gt;seqno))) 	   &#123;</span><br><span class="line">                  cur_seg = &amp;((*cur_seg)-&gt;next );</span><br><span class="line">              &#125;</span><br><span class="line">              seg-&gt;next = (*cur_seg); <span class="comment">/*seg-&gt;next 指向原序列较大seq的节点（*cur_seg）*/</span></span><br><span class="line">              (*cur_seg) = seg; <span class="comment">/* 原序列较大seq的节点（*cur_seg）的前驱节点的 next 指针指向 seg */</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">/* seg插入unacked尾部 */</span></span><br><span class="line">              useg-&gt;next = seg;</span><br><span class="line">              useg = useg-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">/* 报文段len=0的空包 */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          tcp_seg_free(seg);</span><br><span class="line">        &#125;</span><br><span class="line">        seg = pcb-&gt;unsent; <span class="comment">/* 下一个报文段，直到循环结束所有seg发送完毕 */</span></span><br><span class="line">  &#125;</span><br><span class="line">output_done:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_OVERSIZE</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;unsent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* last unsent has been removed, reset unsent_oversize */</span></span><br><span class="line">    pcb-&gt;unsent_oversize = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_OVERSIZE */</span></span></span><br><span class="line"></span><br><span class="line">  pcb-&gt;flags &amp;= ~TF_NAGLEMEMERR;</span><br><span class="line">  <span class="keyword">return</span> ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="报文段接收">报文段接收</h2>
<p>类似应用层向传输层发送接口<code>tcp_output()</code>,还有传输层(IP层)向应用层发送<code>tcp_input()</code>函数，其源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">tcp_input</span><span class="params">(<span class="keyword">struct</span> pbuf *p, <span class="keyword">struct</span> netif *inp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">pcb</span>, *<span class="title">prev</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb_listen</span> *<span class="title">lpcb</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SO_REUSE</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">lpcb_prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb_listen</span> *<span class="title">lpcb_any</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SO_REUSE */</span></span></span><br><span class="line">  <span class="type">u8_t</span> hdrlen_bytes;</span><br><span class="line">  <span class="type">err_t</span> err;</span><br><span class="line"></span><br><span class="line">  LWIP_UNUSED_ARG(inp);</span><br><span class="line"></span><br><span class="line">  PERF_START;</span><br><span class="line"></span><br><span class="line">  TCP_STATS_INC(tcp.recv);</span><br><span class="line">  MIB2_STATS_INC(mib2.tcpinsegs);</span><br><span class="line"></span><br><span class="line">  tcphdr = (<span class="keyword">struct</span> tcp_hdr *)p-&gt;payload;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_INPUT_DEBUG</span></span><br><span class="line">  tcp_debug_print(tcphdr);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 报文段是否有有效数据 */</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;len &lt; TCP_HLEN) &#123;</span><br><span class="line">    <span class="comment">/* 没有就丢弃报文段 */</span></span><br><span class="line">    LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: short packet (%&quot;</span>U16_F<span class="string">&quot; bytes) discarded\n&quot;</span>, p-&gt;tot_len));</span><br><span class="line">    TCP_STATS_INC(tcp.lenerr);</span><br><span class="line">    <span class="keyword">goto</span> dropped;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 不处理传入的广播/多播报文段 */</span></span><br><span class="line">  <span class="keyword">if</span> (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||</span><br><span class="line">      ip_addr_ismulticast(ip_current_dest_addr())) &#123;</span><br><span class="line">    TCP_STATS_INC(tcp.proterr);</span><br><span class="line">    <span class="keyword">goto</span> dropped;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CHECKSUM_CHECK_TCP</span></span><br><span class="line">  IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_TCP) &#123;</span><br><span class="line">    <span class="comment">/* Verify TCP checksum. */</span></span><br><span class="line">    <span class="type">u16_t</span> chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p-&gt;tot_len,</span><br><span class="line">                               ip_current_src_addr(), ip_current_dest_addr());</span><br><span class="line">    <span class="keyword">if</span> (chksum != <span class="number">0</span>) &#123;</span><br><span class="line">        LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: packet discarded due to failing checksum 0x%04&quot;</span>X16_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">          chksum));</span><br><span class="line">      tcp_debug_print(tcphdr);</span><br><span class="line">      TCP_STATS_INC(tcp.chkerr);</span><br><span class="line">      <span class="keyword">goto</span> dropped;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CHECKSUM_CHECK_TCP */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* TCP报文段首部长度 */</span></span><br><span class="line">  hdrlen_bytes = TCPH_HDRLEN(tcphdr) * <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">if</span> ((hdrlen_bytes &lt; TCP_HLEN) || (hdrlen_bytes &gt; p-&gt;tot_len)) &#123;</span><br><span class="line">     <span class="comment">/* uint16 溢出，无法处理*/</span></span><br><span class="line">    LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: invalid header length (%&quot;</span>U16_F<span class="string">&quot;)\n&quot;</span>, (<span class="type">u16_t</span>)hdrlen_bytes));</span><br><span class="line">    TCP_STATS_INC(tcp.lenerr);</span><br><span class="line">    <span class="keyword">goto</span> dropped;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将pbuf指针从tcp header指向data区 */</span></span><br><span class="line">  tcphdr_optlen = hdrlen_bytes - TCP_HLEN;</span><br><span class="line">  tcphdr_opt2 = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;len &gt;= hdrlen_bytes) &#123;</span><br><span class="line">    <span class="comment">/* all options are in the first pbuf */</span></span><br><span class="line">    tcphdr_opt1len = tcphdr_optlen;</span><br><span class="line">    pbuf_header(p, -(<span class="type">s16_t</span>)hdrlen_bytes); <span class="comment">/* cannot fail */</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">u16_t</span> opt2len;</span><br><span class="line">    <span class="comment">/* TCP header fits into first pbuf, options don&#x27;t - data is in the next pbuf */</span></span><br><span class="line">    <span class="comment">/* there must be a next pbuf, due to hdrlen_bytes sanity check above */</span></span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;p-&gt;next != NULL&quot;</span>, p-&gt;next != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* advance over the TCP header (cannot fail) */</span></span><br><span class="line">    pbuf_header(p, -TCP_HLEN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* determine how long the first and second parts of the options are */</span></span><br><span class="line">    tcphdr_opt1len = p-&gt;len;</span><br><span class="line">    opt2len = tcphdr_optlen - tcphdr_opt1len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* options continue in the next pbuf: set p to zero length and hide the</span></span><br><span class="line"><span class="comment">        options in the next pbuf (adjusting p-&gt;tot_len) */</span></span><br><span class="line">    pbuf_header(p, -(<span class="type">s16_t</span>)tcphdr_opt1len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check that the options fit in the second pbuf */</span></span><br><span class="line">    <span class="keyword">if</span> (opt2len &gt; p-&gt;next-&gt;len) &#123;</span><br><span class="line">      <span class="comment">/* drop short packets */</span></span><br><span class="line">      LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: options overflow second pbuf (%&quot;</span>U16_F<span class="string">&quot; bytes)\n&quot;</span>, p-&gt;next-&gt;len));</span><br><span class="line">      TCP_STATS_INC(tcp.lenerr);</span><br><span class="line">      <span class="keyword">goto</span> dropped;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remember the pointer to the second part of the options */</span></span><br><span class="line">    tcphdr_opt2 = (<span class="type">u8_t</span>*)p-&gt;next-&gt;payload;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* advance p-&gt;next to point after the options, and manually</span></span><br><span class="line"><span class="comment">        adjust p-&gt;tot_len to keep it consistent with the changed p-&gt;next */</span></span><br><span class="line">    pbuf_header(p-&gt;next, -(<span class="type">s16_t</span>)opt2len);</span><br><span class="line">    p-&gt;tot_len -= opt2len;</span><br><span class="line"></span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;p-&gt;len == 0&quot;</span>, p-&gt;len == <span class="number">0</span>);</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;p-&gt;tot_len == p-&gt;next-&gt;tot_len&quot;</span>, p-&gt;tot_len == p-&gt;next-&gt;tot_len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 提取tcp头部各字段的值 */</span></span><br><span class="line">  tcphdr-&gt;src = lwip_ntohs(tcphdr-&gt;src);</span><br><span class="line">  tcphdr-&gt;dest = lwip_ntohs(tcphdr-&gt;dest);</span><br><span class="line">  seqno = tcphdr-&gt;seqno = lwip_ntohl(tcphdr-&gt;seqno);</span><br><span class="line">  ackno = tcphdr-&gt;ackno = lwip_ntohl(tcphdr-&gt;ackno);</span><br><span class="line">  tcphdr-&gt;wnd = lwip_ntohs(tcphdr-&gt;wnd);</span><br><span class="line"></span><br><span class="line">  flags = TCPH_FLAGS(tcphdr);</span><br><span class="line">  tcplen = p-&gt;tot_len + ((flags &amp; (TCP_FIN | TCP_SYN)) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Demultiplex an incoming segment. First, we check if it is destined</span></span><br><span class="line"><span class="comment">     for an active connection. */</span></span><br><span class="line">  prev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历活跃的tcp_active_pcbs寻找对应TCP控制块 */</span></span><br><span class="line">  <span class="keyword">for</span> (pcb = tcp_active_pcbs; pcb != <span class="literal">NULL</span>; pcb = pcb-&gt;next) &#123;</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;tcp_input: active pcb-&gt;state != CLOSED&quot;</span>, pcb-&gt;state != CLOSED);</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;tcp_input: active pcb-&gt;state != TIME-WAIT&quot;</span>, pcb-&gt;state != TIME_WAIT);</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;tcp_input: active pcb-&gt;state != LISTEN&quot;</span>, pcb-&gt;state != LISTEN);</span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;remote_port == tcphdr-&gt;src &amp;&amp;</span><br><span class="line">        pcb-&gt;local_port == tcphdr-&gt;dest &amp;&amp;</span><br><span class="line">        ip_addr_cmp(&amp;pcb-&gt;remote_ip, ip_current_src_addr()) &amp;&amp;</span><br><span class="line">        ip_addr_cmp(&amp;pcb-&gt;local_ip, ip_current_dest_addr())) &#123;</span><br><span class="line">      <span class="comment">/* Move this PCB to the front of the list so that subsequent</span></span><br><span class="line"><span class="comment">         lookups will be faster (we exploit locality in TCP segment</span></span><br><span class="line"><span class="comment">         arrivals). */</span></span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;tcp_input: pcb-&gt;next != pcb (before cache)&quot;</span>, pcb-&gt;next != pcb);</span><br><span class="line">      <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        prev-&gt;next = pcb-&gt;next;</span><br><span class="line">        pcb-&gt;next = tcp_active_pcbs;</span><br><span class="line">        tcp_active_pcbs = pcb;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TCP_STATS_INC(tcp.cachehit);</span><br><span class="line">      &#125;</span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;tcp_input: pcb-&gt;next != pcb (after cache)&quot;</span>, pcb-&gt;next != pcb);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    prev = pcb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pcb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* 如果没找到active连接，则检查TW(Time-Wait)状态连接 */</span></span><br><span class="line">    <span class="keyword">for</span> (pcb = tcp_tw_pcbs; pcb != <span class="literal">NULL</span>; pcb = pcb-&gt;next) &#123;</span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;tcp_input: TIME-WAIT pcb-&gt;state == TIME-WAIT&quot;</span>, pcb-&gt;state == TIME_WAIT);</span><br><span class="line">      <span class="keyword">if</span> (pcb-&gt;remote_port == tcphdr-&gt;src &amp;&amp;</span><br><span class="line">          pcb-&gt;local_port == tcphdr-&gt;dest &amp;&amp;</span><br><span class="line">          ip_addr_cmp(&amp;pcb-&gt;remote_ip, ip_current_src_addr()) &amp;&amp;</span><br><span class="line">          ip_addr_cmp(&amp;pcb-&gt;local_ip, ip_current_dest_addr())) &#123;</span><br><span class="line">        <span class="comment">/* We don&#x27;t really care enough to move this PCB to the front</span></span><br><span class="line"><span class="comment">           of the list since we are not very likely to receive that</span></span><br><span class="line"><span class="comment">           many segments for connections in TIME-WAIT. */</span></span><br><span class="line">        LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: packed for TIME_WAITing connection.\n&quot;</span>));</span><br><span class="line">        tcp_timewait_input(pcb); <span class="comment">/* 有匹配的ip和端口 */</span></span><br><span class="line">        pbuf_free(p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若仍未找到，则在LISTENING态的网口中查找连接. */</span></span><br><span class="line">    prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != <span class="literal">NULL</span>; lpcb = lpcb-&gt;next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (lpcb-&gt;local_port == tcphdr-&gt;dest) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IP_IS_ANY_TYPE_VAL(lpcb-&gt;local_ip)) &#123;</span><br><span class="line">          <span class="comment">/* found an ANY TYPE (IPv4/IPv6) match */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SO_REUSE</span></span><br><span class="line">          lpcb_any = lpcb;</span><br><span class="line">          lpcb_prev = prev;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* SO_REUSE */</span></span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SO_REUSE */</span></span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IP_ADDR_PCB_VERSION_MATCH_EXACT(lpcb, ip_current_dest_addr())) &#123;</span><br><span class="line">          <span class="keyword">if</span> (ip_addr_cmp(&amp;lpcb-&gt;local_ip, ip_current_dest_addr())) &#123;</span><br><span class="line">            <span class="comment">/* found an exact match */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ip_addr_isany(&amp;lpcb-&gt;local_ip)) &#123;</span><br><span class="line">            <span class="comment">/* found an ANY-match */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SO_REUSE</span></span><br><span class="line">            lpcb_any = lpcb;</span><br><span class="line">            lpcb_prev = prev;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* SO_REUSE */</span></span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SO_REUSE */</span></span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      prev = (<span class="keyword">struct</span> tcp_pcb *)lpcb;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SO_REUSE</span></span><br><span class="line">    <span class="comment">/* first try specific local IP */</span></span><br><span class="line">    <span class="keyword">if</span> (lpcb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">/* only pass to ANY if no specific local IP has been found */</span></span><br><span class="line">      lpcb = lpcb_any;</span><br><span class="line">      prev = lpcb_prev;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SO_REUSE */</span></span></span><br><span class="line">    <span class="keyword">if</span> (lpcb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">/* Move this PCB to the front of the list so that subsequent</span></span><br><span class="line"><span class="comment">         lookups will be faster (we exploit locality in TCP segment</span></span><br><span class="line"><span class="comment">         arrivals). */</span></span><br><span class="line">      <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ((<span class="keyword">struct</span> tcp_pcb_listen *)prev)-&gt;next = lpcb-&gt;next;</span><br><span class="line">              <span class="comment">/* our successor is the remainder of the listening list */</span></span><br><span class="line">        lpcb-&gt;next = tcp_listen_pcbs.listen_pcbs;</span><br><span class="line">              <span class="comment">/* put this listening pcb at the head of the listening list */</span></span><br><span class="line">        tcp_listen_pcbs.listen_pcbs = lpcb;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TCP_STATS_INC(tcp.cachehit);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: packed for LISTENing connection.\n&quot;</span>));</span><br><span class="line">      tcp_listen_input(lpcb);</span><br><span class="line">      pbuf_free(p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_INPUT_DEBUG</span></span><br><span class="line">  LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;+-+-+-+-+-+-+-+-+-+-+-+-+-+- tcp_input: flags &quot;</span>));</span><br><span class="line">  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));</span><br><span class="line">  LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n&quot;</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_INPUT_DEBUG */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pcb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* The incoming segment belongs to a connection. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_INPUT_DEBUG</span></span><br><span class="line">    tcp_debug_print_state(pcb-&gt;state);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_INPUT_DEBUG */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up a tcp_seg structure. */</span></span><br><span class="line">    inseg.next = <span class="literal">NULL</span>;</span><br><span class="line">    inseg.len = p-&gt;tot_len;</span><br><span class="line">    inseg.p = p;</span><br><span class="line">    inseg.tcphdr = tcphdr;</span><br><span class="line"></span><br><span class="line">    recv_data = <span class="literal">NULL</span>;</span><br><span class="line">    recv_flags = <span class="number">0</span>;</span><br><span class="line">    recv_acked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; TCP_PSH) &#123;</span><br><span class="line">      p-&gt;flags |= PBUF_FLAG_PUSH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If there is data which was previously &quot;refused&quot; by upper layer */</span></span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;refused_data != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((tcp_process_refused_data(pcb) == ERR_ABRT) ||</span><br><span class="line">        ((pcb-&gt;refused_data != <span class="literal">NULL</span>) &amp;&amp; (tcplen &gt; <span class="number">0</span>))) &#123;</span><br><span class="line">        <span class="comment">/* pcb has been aborted or refused data is still refused and the new</span></span><br><span class="line"><span class="comment">           segment contains data */</span></span><br><span class="line">        <span class="keyword">if</span> (pcb-&gt;rcv_ann_wnd == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">/* this is a zero-window probe, we respond to it with current RCV.NXT</span></span><br><span class="line"><span class="comment">          and drop the data segment */</span></span><br><span class="line">          tcp_send_empty_ack(pcb);</span><br><span class="line">        &#125;</span><br><span class="line">        TCP_STATS_INC(tcp.drop);</span><br><span class="line">        MIB2_STATS_INC(mib2.tcpinerrs);</span><br><span class="line">        <span class="keyword">goto</span> aborted;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tcp_input_pcb = pcb;</span><br><span class="line">    err = tcp_process(pcb);</span><br><span class="line">    <span class="comment">/* A return value of ERR_ABRT means that tcp_abort() was called</span></span><br><span class="line"><span class="comment">       and that the pcb has been freed. If so, we don&#x27;t do anything. */</span></span><br><span class="line">    <span class="keyword">if</span> (err != ERR_ABRT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (recv_flags &amp; TF_RESET) &#123;</span><br><span class="line">        <span class="comment">/* TF_RESET means that the connection was reset by the other</span></span><br><span class="line"><span class="comment">           end. We then call the error callback to inform the</span></span><br><span class="line"><span class="comment">           application that the connection is dead before we</span></span><br><span class="line"><span class="comment">           deallocate the PCB. */</span></span><br><span class="line">        TCP_EVENT_ERR(pcb-&gt;state, pcb-&gt;errf, pcb-&gt;callback_arg, ERR_RST);</span><br><span class="line">        tcp_pcb_remove(&amp;tcp_active_pcbs, pcb);</span><br><span class="line">        memp_free(MEMP_TCP_PCB, pcb);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = ERR_OK;</span><br><span class="line">        <span class="comment">/* If the application has registered a &quot;sent&quot; function to be</span></span><br><span class="line"><span class="comment">           called when new send buffer space is available, we call it</span></span><br><span class="line"><span class="comment">           now. */</span></span><br><span class="line">        <span class="keyword">if</span> (recv_acked &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="type">u16_t</span> acked16;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_WND_SCALE</span></span><br><span class="line">          <span class="comment">/* recv_acked is u32_t but the sent callback only takes a u16_t,</span></span><br><span class="line"><span class="comment">             so we might have to call it multiple times. */</span></span><br><span class="line">          <span class="type">u32_t</span> acked = recv_acked;</span><br><span class="line">          <span class="keyword">while</span> (acked &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            acked16 = (<span class="type">u16_t</span>)LWIP_MIN(acked, <span class="number">0xffffu</span>);</span><br><span class="line">            acked -= acked16;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">          &#123;</span><br><span class="line">            acked16 = recv_acked;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            TCP_EVENT_SENT(pcb, (<span class="type">u16_t</span>)acked16, err);</span><br><span class="line">            <span class="keyword">if</span> (err == ERR_ABRT) &#123;</span><br><span class="line">              <span class="keyword">goto</span> aborted;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          recv_acked = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (recv_flags &amp; TF_CLOSED) &#123;</span><br><span class="line">          <span class="comment">/* The connection has been closed and we will deallocate the</span></span><br><span class="line"><span class="comment">             PCB. */</span></span><br><span class="line">          <span class="keyword">if</span> (!(pcb-&gt;flags &amp; TF_RXCLOSED)) &#123;</span><br><span class="line">            <span class="comment">/* Connection closed although the application has only shut down the</span></span><br><span class="line"><span class="comment">               tx side: call the PCB&#x27;s err callback and indicate the closure to</span></span><br><span class="line"><span class="comment">               ensure the application doesn&#x27;t continue using the PCB. */</span></span><br><span class="line">            TCP_EVENT_ERR(pcb-&gt;state, pcb-&gt;errf, pcb-&gt;callback_arg, ERR_CLSD);</span><br><span class="line">          &#125;</span><br><span class="line">          tcp_pcb_remove(&amp;tcp_active_pcbs, pcb);</span><br><span class="line">          memp_free(MEMP_TCP_PCB, pcb);</span><br><span class="line">          <span class="keyword">goto</span> aborted;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE</span></span><br><span class="line">        <span class="keyword">while</span> (recv_data != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">rest</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">          pbuf_split_64k(recv_data, &amp;rest);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE */</span></span></span><br><span class="line">        <span class="keyword">if</span> (recv_data != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE */</span></span></span><br><span class="line"></span><br><span class="line">          LWIP_ASSERT(<span class="string">&quot;pcb-&gt;refused_data == NULL&quot;</span>, pcb-&gt;refused_data == <span class="literal">NULL</span>);</span><br><span class="line">          <span class="keyword">if</span> (pcb-&gt;flags &amp; TF_RXCLOSED) &#123;</span><br><span class="line">            <span class="comment">/* received data although already closed -&gt; abort (send RST) to</span></span><br><span class="line"><span class="comment">               notify the remote host that not all data has been processed */</span></span><br><span class="line">            pbuf_free(recv_data);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE</span></span><br><span class="line">            <span class="keyword">if</span> (rest != <span class="literal">NULL</span>) &#123;</span><br><span class="line">              pbuf_free(rest);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE */</span></span></span><br><span class="line">            tcp_abort(pcb);</span><br><span class="line">            <span class="keyword">goto</span> aborted;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Notify application that data has been received. */</span></span><br><span class="line">          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);</span><br><span class="line">          <span class="keyword">if</span> (err == ERR_ABRT) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE</span></span><br><span class="line">            <span class="keyword">if</span> (rest != <span class="literal">NULL</span>) &#123;</span><br><span class="line">              pbuf_free(rest);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE */</span></span></span><br><span class="line">            <span class="keyword">goto</span> aborted;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* If the upper layer can&#x27;t receive this data, store it */</span></span><br><span class="line">          <span class="keyword">if</span> (err != ERR_OK) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE</span></span><br><span class="line">            <span class="keyword">if</span> (rest != <span class="literal">NULL</span>) &#123;</span><br><span class="line">              pbuf_cat(recv_data, rest);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE */</span></span></span><br><span class="line">            pcb-&gt;refused_data = recv_data;</span><br><span class="line">            LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: keep incoming packet, because pcb is \&quot;full\&quot;\n&quot;</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Upper layer received the data, go on with the rest if &gt; 64K */</span></span><br><span class="line">            recv_data = rest;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE */</span></span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If a FIN segment was received, we call the callback</span></span><br><span class="line"><span class="comment">           function with a NULL buffer to indicate EOF. */</span></span><br><span class="line">        <span class="keyword">if</span> (recv_flags &amp; TF_GOT_FIN) &#123;</span><br><span class="line">          <span class="keyword">if</span> (pcb-&gt;refused_data != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Delay this if we have refused data. */</span></span><br><span class="line">            pcb-&gt;refused_data-&gt;flags |= PBUF_FLAG_TCP_FIN;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* correct rcv_wnd as the application won&#x27;t call tcp_recved()</span></span><br><span class="line"><span class="comment">               for the FIN&#x27;s seqno */</span></span><br><span class="line">            <span class="keyword">if</span> (pcb-&gt;rcv_wnd != TCP_WND_MAX(pcb)) &#123;</span><br><span class="line">              pcb-&gt;rcv_wnd++;</span><br><span class="line">            &#125;</span><br><span class="line">            TCP_EVENT_CLOSED(pcb, err);</span><br><span class="line">            <span class="keyword">if</span> (err == ERR_ABRT) &#123;</span><br><span class="line">              <span class="keyword">goto</span> aborted;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tcp_input_pcb = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">/* Try to send something out. */</span></span><br><span class="line">        tcp_output(pcb);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_INPUT_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_DEBUG</span></span><br><span class="line">        tcp_debug_print_state(pcb-&gt;state);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_DEBUG */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_INPUT_DEBUG */</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).</span></span><br><span class="line"><span class="comment">       Below this line, &#x27;pcb&#x27; may not be dereferenced! */</span></span><br><span class="line">aborted:</span><br><span class="line">    tcp_input_pcb = <span class="literal">NULL</span>;</span><br><span class="line">    recv_data = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* give up our reference to inseg.p */</span></span><br><span class="line">    <span class="keyword">if</span> (inseg.p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      pbuf_free(inseg.p);</span><br><span class="line">      inseg.p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If no matching PCB was found, send a TCP RST (reset) to the</span></span><br><span class="line"><span class="comment">       sender. */</span></span><br><span class="line">    LWIP_DEBUGF(TCP_RST_DEBUG, (<span class="string">&quot;tcp_input: no PCB match found, resetting.\n&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (!(TCPH_FLAGS(tcphdr) &amp; TCP_RST)) &#123;</span><br><span class="line">      TCP_STATS_INC(tcp.proterr);</span><br><span class="line">      TCP_STATS_INC(tcp.drop);</span><br><span class="line">      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),</span><br><span class="line">        ip_current_src_addr(), tcphdr-&gt;dest, tcphdr-&gt;src);</span><br><span class="line">    &#125;</span><br><span class="line">    pbuf_free(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;tcp_input: tcp_pcbs_sane()&quot;</span>, tcp_pcbs_sane());</span><br><span class="line">  PERF_STOP(<span class="string">&quot;tcp_input&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">dropped:</span><br><span class="line">  TCP_STATS_INC(tcp.drop);</span><br><span class="line">  MIB2_STATS_INC(mib2.tcpinerrs);</span><br><span class="line">  pbuf_free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>正常接收处理的数据，如果收到的报文段是复位报文或终止连接应答报文，则释放pbuf，终止连接；</li>
<li>TCP 协议确认报文段是新数据，调用带参宏TCP_EVENT_SENT（sent
的回调函数）处理；</li>
<li>如果报文段中包含有效的数据，就调用TCP_EVENT_RECV 去处理；</li>
<li>如果是收到FIN 报文，则调用TCP_EVENT_CLOSED 去处理；</li>
</ul>
<h1 id="参考资料">参考资料</h1>
<ol type="1">
<li><a href="https://blog.csdn.net/2301_76144863/article/details/139028540?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-139028540-blog-120524798.235%5Ev43%5Epc_blog_bottom_relevance_base5&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=3">TCP协议_tcp全双工-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/zjcjava/article/details/103133607?ops_request_misc=&amp;request_id=&amp;biz_id=&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~es_rank~default-2-103133607.pc_search_all_es&amp;utm_term=为什么tcp挥手只有三次&amp;spm=1018.2226.3001.4187">tcp/ip
只有四次挥手？还有三次挥手_四次挥手中会出现只有3此的情况嘛-CSDN博客</a></li>
<li>[linux - What is the reason and how to avoid the <a href="https://stackoverflow.com/questions/15182106/what-is-the-reason-and-how-to-avoid-the-fin-ack-rst-and-rst-ack">FIN,
ACK] , [RST] and [RST, ACK] - Stack Overflow</a></li>
<li><a href="https://blog.csdn.net/weixin_40803011/article/details/121794141">Wireshark抓包分析TCP，发现居然只有三次挥手_只抓到三次挥手-CSDN博客</a></li>
<li><a href="https://zorrozou.github.io/docs/tcp/wavehand/TCP_Wavehand.html">Linux的TCP实现之：四次挥手
| Zorro’s Linux Book</a></li>
<li><a href="https://www.cnblogs.com/lizhuming/p/17438743.html">【lwip】14-TCP协议之可靠传输的实现（TCP干货）
- 李柱明 - 博客园</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc793#section-3.5">RFC 793:
Transmission Control Protocol-S3.5</a></li>
<li><a href="https://www.cnblogs.com/lizhuming/p/16883586.html">【lwip】12-一文解决TCP原理
- 李柱明 - 博客园</a></li>
<li><a href="https://www.cnblogs.com/lshs/p/6038658.html">TCP系列33—窗口管理&amp;流控—7、Silly
Window Syndrome(SWS) - lshs - 博客园</a></li>
<li><a href="https://www.cnblogs.com/lizhuming/p/17438682.html">【lwip】13-TCP协议分析之源码篇
- 李柱明 - 博客园</a></li>
</ol>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p>“江山如此多娇，引无数英雄竞折腰。” —— 《沁园春·雪》</p>
</blockquote>
]]></content>
      <categories>
        <category>协议类</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-02-字符串寻找最大公因子</title>
    <url>/2025/07/19/LeetCode-02-GCD_Of_String/</url>
    <content><![CDATA[<p>LeetCode算法题：字符串找最大公因子。</p>
<span id="more"></span>
<h2 id="题目">题目</h2>
<p>LeetCode：<a href="https://leetcode.cn/studyplan/leetcode-75/">LeetCode 75 -
学习计划</a>-02-字符串最大公因子</p>
<p>对于字符串 <code>s</code> 和 <code>t</code>，只有在
<code>s = t + t + t + ... + t + t</code>（<code>t</code> 自身连接 1
次或多次）时，我们才认定 “<code>t</code> 能除尽 <code>s</code>”。</p>
<p>给定两个字符串 <code>str1</code> 和 <code>str2</code> 。返回
<em>最长字符串 <code>x</code>，要求满足 <code>x</code> 能除尽
<code>str1</code> 且 <code>x</code> 能除尽 <code>str2</code></em> 。</p>
<h2 id="思路">思路</h2>
<p>如果存在最大公因子，最长的相同元素一定是str1与str2中短的那个。</p>
<p>方案A：
<strong>若存在字符串最大公因子，则str1或str2必定只有x元素。即str1与str2之间辗转对比一定能找到最终的x，否则不存在最大公因子。</strong></p>
<p>方案B：字符串的公因子是按照长度定义，只需要找到字符串str1与str2长度的最大公因子，以次长度为基准，比对str1与str2的元素。</p>
<h2 id="代码">代码</h2>
<h3 id="方案a">方案A</h3>
<p>辗转相除，以较短的字符串为基准，不断向后移动并缩减比对字符串的长度，也是希望找到<strong>长度的最大公因子</strong>。</p>
<div>
<center>
<img src="image-20250719114305253.png" alt="image can't load." style="zoom:55%"> <br> 长度上辗转相除
</center>
</div>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">gcdOfStrings</span><span class="params">(<span class="type">char</span>* str1, <span class="type">char</span>* str2)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="built_in">strlen</span>(str1);</span><br><span class="line">    <span class="type">int</span> n2 = <span class="built_in">strlen</span>(str2);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n1==n2 &amp;&amp; <span class="built_in">strncmp</span>(str1,str2,n1)==<span class="number">0</span> ) <span class="comment">//字符串长度相等</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> str1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n1&gt;n2 &amp;&amp; <span class="built_in">strncmp</span>(str1,str2,n2)==<span class="number">0</span>) <span class="comment">//str1长，向后移动</span></span><br><span class="line">        &#123;</span><br><span class="line">            str1 += n2;</span><br><span class="line">            n1 -= n2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n1&lt;n2 &amp;&amp; <span class="built_in">strncmp</span>(str1,str2,n1)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            str2 += n1;</span><br><span class="line">            n2 -= n1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="方案b">方案B</h3>
<p>如果考虑不到方案A的辗转相除，那么可以尝试找到长度公因子，并使用长度对应的元素分别与str1和str2后续的字符做比较，理论上应当完全一致。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//int gcd = iGcd(6,4);</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">iGcd</span><span class="params">(<span class="type">int</span> len1,<span class="type">int</span> len2)</span>;</span><br><span class="line"><span class="comment">//int result = (&quot;ABABAB&quot;,&quot;AB&quot;,2);</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">iCheck</span><span class="params">(<span class="type">char</span> *str1, <span class="type">char</span> *str2, <span class="type">int</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">gcdOfStrings</span><span class="params">(<span class="type">char</span>* str1, <span class="type">char</span>* str2)</span> &#123;</span><br><span class="line">     <span class="comment">//str1与str2前n个元素不同</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str1[i] &amp;&amp; str2[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str1[i]!=str2[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n1 = <span class="built_in">strlen</span>(str1);</span><br><span class="line">    <span class="type">int</span> n2 = <span class="built_in">strlen</span>(str2);</span><br><span class="line">    <span class="type">int</span> result = iGcd(n1,n2);<span class="comment">//找到长度最大公因子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len =result;len&gt;<span class="number">0</span>;len--) <span class="comment">//例如偶数可能是4、2、1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n1%len || n2%len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(iCheck(str1,str2,len)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            str1[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> str1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找长度的最大公因子</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">iGcd</span><span class="params">(<span class="type">int</span> len1,<span class="type">int</span> len2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(len1!=len2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(len1 &gt; len2)</span><br><span class="line">        &#123;</span><br><span class="line">            len1 -= len2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            len2 -= len1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">iCheck</span><span class="params">(<span class="type">char</span> *str1, <span class="type">char</span> *str2, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//str1前len长度字符与后续对比</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=len; str1[j] ;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str1[i]!=str1[j]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i = (i+<span class="number">1</span>)%len;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//str1前len长度字符与str2后续字符对比	</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=len; str2[j] ;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str1[i]!=str2[j]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i = (i+<span class="number">1</span>)%len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p><em>“天长地久有时尽，此恨绵绵无绝期。”– 《长恨歌》</em></p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-01-字符串交叉拼接</title>
    <url>/2025/07/19/LeetCode-01-String_Composition/</url>
    <content><![CDATA[<p>LeetCode算法题：字符串交叉拼接。</p>
<span id="more"></span>
<h2 id="题目">题目</h2>
<p>LeetCode：<a href="https://leetcode.cn/studyplan/leetcode-75/">LeetCode 75 -
学习计划</a>-1-交替合并字符串</p>
<p>题目简述：给你两个字符串 <code>word1</code> 和 <code>word2</code>
。请你从 <code>word1</code>
开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。</p>
<p>返回 <strong>合并后的字符串</strong> 。</p>
<ul>
<li><code>1 &lt;= word1.length, word2.length &lt;= 100</code></li>
<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>
</ul>
<h2 id="思路">思路</h2>
<p>从题干中可得到以下关键信息：</p>
<ul>
<li>两字符串不等长</li>
<li>交替添加</li>
</ul>
<p>因此推论出两个要点：</p>
<ul>
<li>strlen计算输入字符串长度</li>
<li>读取时可共用同一索引值/双指针</li>
</ul>
<p>因此可根据输入字符串长度动态分配内存，随后循环读取两数组的元素。</p>
<ul>
<li>malloc分配内存长度应为len1+len2+1，末尾存放’\0’;</li>
</ul>
<h2 id="代码">代码</h2>
<h3 id="方案a">方案A</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">mergeAlternately</span><span class="params">(<span class="type">char</span>* word1, <span class="type">char</span>* word2)</span> &#123;</span><br><span class="line">    assert(word1);</span><br><span class="line">    assert(word2);</span><br><span class="line">    <span class="type">int</span> word1_len = <span class="built_in">strlen</span>(word1);</span><br><span class="line">    <span class="type">int</span> word2_len = <span class="built_in">strlen</span>(word2);</span><br><span class="line">    <span class="type">int</span> word_rd_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> string_wr_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* string_out = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (word1_len + word2_len + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span> ((word_rd_idx &lt; word1_len) || (word_rd_idx &lt; word2_len))</span><br><span class="line">    &#123;</span><br><span class="line">        word_rd_idx &lt; word1_len ? (string_out[string_wr_idx++] = word1[word_rd_idx]) : <span class="number">0</span>;</span><br><span class="line">        word_rd_idx &lt; word2_len ? (string_out[string_wr_idx++] = word2[word_rd_idx]) : <span class="number">0</span>;</span><br><span class="line">        word_rd_idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    string_out[string_wr_idx] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> string_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方案A中无论哪个字符串更长，while中均会判断两次。如果AB长度差异过大影响效率。</p>
<h3 id="方案b">方案B</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">mergeAlternately</span><span class="params">(<span class="type">char</span>* word1, <span class="type">char</span>* word2)</span> &#123;</span><br><span class="line">    assert(word1);</span><br><span class="line">    assert(word2);</span><br><span class="line">    <span class="type">int</span> word1_len = <span class="built_in">strlen</span>(word1);</span><br><span class="line">    <span class="type">int</span> word2_len = <span class="built_in">strlen</span>(word2);</span><br><span class="line">    <span class="type">int</span> word_rd_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> string_wr_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* string_out = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (word1_len + word2_len + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span> ((word_rd_idx &lt; word1_len) &amp;&amp; (word_rd_idx &lt; word2_len))</span><br><span class="line">    &#123;</span><br><span class="line">        word_rd_idx &lt; word1_len ? (string_out[string_wr_idx++] = word1[word_rd_idx]) : <span class="number">0</span>;</span><br><span class="line">        word_rd_idx &lt; word2_len ? (string_out[string_wr_idx++] = word2[word_rd_idx]) : <span class="number">0</span>;</span><br><span class="line">        word_rd_idx++;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(word1_len&gt;=word2_len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (word_rd_idx &lt; word1_len)</span><br><span class="line">        &#123;</span><br><span class="line"> 			string_out[string_wr_idx++] = word1[word_rd_idx];</span><br><span class="line">            word_rd_idx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (word_rd_idx &lt; word2_len)</span><br><span class="line">        &#123;</span><br><span class="line"> 			string_out[string_wr_idx++] = word2[word_rd_idx];</span><br><span class="line">            word_rd_idx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string_out[string_wr_idx] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> string_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方案c">方案C</h3>
<p>采用双指针，进一步减少定义变量的个数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">mergeAlternately</span><span class="params">(<span class="type">char</span>* word1, <span class="type">char</span>* word2)</span> &#123;</span><br><span class="line">    assert(word1);</span><br><span class="line">    assert(word2);</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(word1) + <span class="built_in">strlen</span>(word2) + <span class="number">1</span>));<span class="comment">//起始指针</span></span><br><span class="line">    <span class="type">char</span> *string_out = p;<span class="comment">//写入字符的移动指针</span></span><br><span class="line">    <span class="keyword">while</span>(*word1 &amp;&amp; *word2)</span><br><span class="line">    &#123;</span><br><span class="line">        *string_out++=*word1++;</span><br><span class="line">        *string_out++=*word2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*word1)</span><br><span class="line">    &#123;</span><br><span class="line">        *string_out++=*word1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*word2)</span><br><span class="line">    &#123;</span><br><span class="line">        *string_out++=*word2++;</span><br><span class="line">    &#125;</span><br><span class="line">    *string_out = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度">复杂度</h3>
<p>方案ABC的复杂度一致，<strong>时间复杂度为O(n+m)</strong>:源于strlen(word1)与strlen(word2)。<strong>空间复杂度为O(n+m)</strong>:源于malloc分配内存</p>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p><em>“试玉要烧三日满，辨材须待七年期。”– 《放言五首·其三》</em></p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Altium-02-异常与解决办法</title>
    <url>/2025/07/18/Altium-02-Error_And_Solution/</url>
    <content><![CDATA[<p>本博客记录Altium
Designer设计PCB时遇到的各种问题与解决办法，按照原理图与PCB进行归类…</p>
<span id="more"></span>
<h2 id="原理图">原理图</h2>
<p>None.</p>
<h2 id="pcb">PCB</h2>
<h3 id="器件位置类">器件位置类</h3>
<ol type="1">
<li><p>器件无法拖动到原点左侧和下方</p>
<p>如下图。绝对原点限制了器件摆放位置。</p>
<div>
<center>
<img src="image-20250718094118825.png" alt="image can't load." style="zoom:40%"> <br> 辅助中心
</center>
</div>
<p>Re:使用<code>EJA</code>跳转至绝对原点，若板框距离原点有差距，选中所有器件移动至合适位置即可。</p></li>
</ol>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p><em>“我住长江头，君住长江尾。”–卜算子·我住长江头</em></p>
</blockquote>
]]></content>
      <categories>
        <category>电子类</category>
        <category>PCB</category>
      </categories>
      <tags>
        <tag>Altium Designer</tag>
        <tag>PCB</tag>
      </tags>
  </entry>
  <entry>
    <title>SI-01-PCB特性阻抗</title>
    <url>/2025/07/09/SI-01-Impedance/</url>
    <content><![CDATA[<p>本博客记录PCB阻抗与叠层设计的参考思路。</p>
<span id="more"></span>
<h2 id="特性阻抗">特性阻抗</h2>
<p><span style="color:red"><strong>特性阻抗为高频信号在均匀传输线上的等效阻抗。</strong></span>信号线在传输信号时会与参考平面（地平面、电源平面）建立电场产生瞬间电流，由电压电流<em>V/I</em>得等效阻值<em>Z<sub>0</sub></em>，具体取决于介电常数<em>ε<sub>0</sub></em>与每单位长度的电容<em>C<sub>L</sub></em>。
<span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.891ex;" xmlns="http://www.w3.org/2000/svg" width="13.412ex" height="4.928ex" role="img" focusable="false" viewbox="0 -1342 5928.2 2178"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44D" d="M58 8Q58 23 64 35Q64 36 329 334T596 635L586 637Q575 637 512 637H500H476Q442 637 420 635T365 624T311 598T266 548T228 469Q227 466 226 463T224 458T223 453T222 450L221 448Q218 443 202 443Q185 443 182 453L214 561Q228 606 241 651Q249 679 253 681Q256 683 487 683H718Q723 678 723 675Q723 673 717 649Q189 54 188 52L185 49H274Q369 50 377 51Q452 60 500 100T579 247Q587 272 590 277T603 282H607Q628 282 628 271Q547 5 541 2Q538 0 300 0H124Q58 0 58 8Z"/></g><g data-mml-node="mn" transform="translate(716,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(1397.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mfrac" transform="translate(2453.1,0)"><g data-mml-node="mn" transform="translate(359.8,676)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"/><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(500,0)"/></g><g data-mml-node="msub" transform="translate(220,-686)"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(748,-150) scale(0.707)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g></g><rect width="1479.5" height="60" x="120" y="220"/></g><g data-mml-node="msqrt" transform="translate(4172.6,0)"><g transform="translate(853,0)"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D700" d="M190 -22Q124 -22 76 11T27 107Q27 174 97 232L107 239L99 248Q76 273 76 304Q76 364 144 408T290 452H302Q360 452 405 421Q428 405 428 392Q428 381 417 369T391 356Q382 356 371 365T338 383T283 392Q217 392 167 368T116 308Q116 289 133 272Q142 263 145 262T157 264Q188 278 238 278H243Q308 278 308 247Q308 206 223 206Q177 206 142 219L132 212Q68 169 68 112Q68 39 201 39Q253 39 286 49T328 72T345 94T362 105Q376 103 376 88Q376 79 365 62T334 26T275 -8T190 -22Z"/></g><g data-mml-node="mn" transform="translate(499,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g><g data-mml-node="mo" transform="translate(0,-41.5)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="902.6" height="60" x="853" y="698.5"/></g></g></g></svg></mjx-container></span>
对于非均匀传输线，称为“瞬时阻抗”，而非特征阻抗。<strong>对一条线宽变化的传输线，瞬时阻抗没有意义。</strong>线宽不变时，信号传输时的阻抗就是固定的，但PCB上的铜线也有厚度，比如常见的1oz、0.5oz铜厚，所以更准确的说法是横截面不变时，阻抗是固定的（<strong>一般同一层的铜厚一致，所以可以说线宽影响阻抗</strong>）。</p>
<p>而根据产生电场的条件，传输介质介电常数<em>ε<sub>0</sub></em>不变的情况下，信号传输线与参考平面的距离<em>d</em>越近/面积（线宽）<em>S</em>越大，等效电容（寄生电容）<em>C</em>越大，进而等效阻抗<em>Z<sub>0</sub></em>越小。
<span class="math display"><em>C</em> = <em>ε</em><sub>0</sub> * <em>S</em>/<em>d</em></span></p>
<p><span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.308ex;" xmlns="http://www.w3.org/2000/svg" width="11.977ex" height="5.407ex" role="img" focusable="false" viewbox="0 -1370 5293.7 2390"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44D" d="M58 8Q58 23 64 35Q64 36 329 334T596 635L586 637Q575 637 512 637H500H476Q442 637 420 635T365 624T311 598T266 548T228 469Q227 466 226 463T224 458T223 453T222 450L221 448Q218 443 202 443Q185 443 182 453L214 561Q228 606 241 651Q249 679 253 681Q256 683 487 683H718Q723 678 723 675Q723 673 717 649Q189 54 188 52L185 49H274Q369 50 377 51Q452 60 500 100T579 247Q587 272 590 277T603 282H607Q628 282 628 271Q547 5 541 2Q538 0 300 0H124Q58 0 58 8Z"/></g><g data-mml-node="mn" transform="translate(716,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(1397.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mfrac" transform="translate(2453.1,0)"><g data-mml-node="mrow" transform="translate(660.3,676)"><g data-mml-node="mn"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"/><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(500,0)"/></g><g data-mml-node="mi" transform="translate(1000,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g></g><g data-mml-node="mrow" transform="translate(220,-730.7)"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="msqrt" transform="translate(645,0)"><g transform="translate(853,0)"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D700" d="M190 -22Q124 -22 76 11T27 107Q27 174 97 232L107 239L99 248Q76 273 76 304Q76 364 144 408T290 452H302Q360 452 405 421Q428 405 428 392Q428 381 417 369T391 356Q382 356 371 365T338 383T283 392Q217 392 167 368T116 308Q116 289 133 272Q142 263 145 262T157 264Q188 278 238 278H243Q308 278 308 247Q308 206 223 206Q177 206 142 219L132 212Q68 169 68 112Q68 39 201 39Q253 39 286 49T328 72T345 94T362 105Q376 103 376 88Q376 79 365 62T334 26T275 -8T190 -22Z"/></g><g data-mml-node="mn" transform="translate(499,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g><g data-mml-node="mo" transform="translate(0,-89.3)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="902.6" height="60" x="853" y="650.7"/></g></g><rect width="2600.6" height="60" x="120" y="220"/></g></g></g></svg></mjx-container></span></p>
<p>根据上式也能得出结论，对于电源/地两个参考平面，其截面大阻抗低（约1Ω），对于带状线与微带线线宽窄阻抗高（约60-90Ω）。</p>
<p>特征阻抗的影响因素包括线宽、铜厚、板厚、层数、基板材料、表面工艺，可根据实际的阻抗设计值、阻抗公差计算线宽线距。<strong>介质越厚、线距越大阻抗越大；介电常数、铜厚、线宽、阻焊厚度越大阻抗越小。</strong></p>
<ul>
<li><p>介电常数</p>
<p>对FR-4，介电常数为3.9-4.5；</p>
<p>对聚四氟乙烯，介电常数为2.2-3.9；</p></li>
<li><p>阻焊厚度</p>
<p>刷绿油/黑油（阻焊）一次使单端阻抗降低2Ω，差分阻抗降低8Ω。两次时翻倍，三次时不再变化。</p></li>
</ul>
<h2 id="阻抗计算">阻抗计算</h2>
<p>传输线就像水管，水管粗细突变时水流会被阻拦。同样，一根传输线上阻抗突变意味着信号会发生反射，进而产生噪声干扰正常信号。</p>
<p><strong>做阻抗的目的就是减少信号反射点，降低传输损耗。</strong>一般在设计<em>f<sub>clock</sub>&gt;100MHz</em>的高速电路时就需要做阻抗。</p>
<p>可使用<a href="https://tools.jlc.com/jlcTools/index.html#/impedanceCalculatenew">嘉立创阻抗计算</a>或者SI9000输入参数进行线宽线距计算。以嘉立创为例，计算时需要区分单端/差分阻抗与共面单端/共面差分阻抗。</p>
<ul>
<li><p>单端阻抗：单根信号线与参考平面之间的阻抗</p></li>
<li><p>差分阻抗：差分线对间、与相邻参考层间的耦合阻抗。</p></li>
<li><p>共面单端阻抗：单根信号线与参考平面间（尽量完整参考地）、以及<strong>与同层两侧地铜皮的耦合阻抗。</strong></p>
<div>
<center>
<img src="image-20250712230625507.png" alt="image can't load." style="zoom:55%"><!-- alt内为提示词--> <br> 共面单端阻抗
</center>
</div></li>
<li><p>共面差分阻抗：差分信号线现对间、与参考平面间（尽量完整参考地）、<strong>与同层两侧地铜皮的的耦合阻抗。</strong>共面差分则与之类似。</p></li>
</ul>
<p><strong>共面地是为了抑制串扰、增加回流路径。</strong>对于多层板，可利用单端阻抗和差分阻抗计算设计，但是对于以下情况，通常需要使用共面单端与共面差分：</p>
<ul>
<li>两层板。板厚过大，根据公式限制较小阻抗时线宽较大(可能达到100mil)，而且两层板通常没有完整的参考地。</li>
<li>射频天线</li>
<li>高速信号</li>
</ul>
<h2 id="常用接口">常用接口</h2>
<ul>
<li>RS232:可不做（低频高压摆特性）</li>
<li>LVDS：100Ω差分</li>
<li>CAN：100Ω差分</li>
<li>USB：90Ω差分</li>
<li>SATA：90Ω差分</li>
<li>Ethernet:CAN：100Ω差分</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li><a href="https://blog.csdn.net/yinuoheqian123/article/details/129390510">传输线的物理基础（四）：传输线的特征阻抗-CSDN博客</a></li>
<li><a href="https://tools.jlc.com/jlcTools/index.html#/impedanceCalculatenew">嘉立创阻抗计算</a></li>
<li><a href="https://www.bilibili.com/video/BV1idAhe2E3a/?spm_id_from=333.337.search-card.all.click&amp;vd_source=5465b0f4790ebae45362caa6519f3b79">如何理解共面差分阻抗，共面单端阻抗？有哪些影响因素？如何用嘉立创阻抗计算神器计算阻抗值？哔哩哔哩</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/520196609">差分走线有5个常见误区，你是否出现？
- 知乎</a></li>
<li><a href="https://wwwangguan.github.io/2023/08/10/dian-zi-dian-li/layout-yao-qiu/chang-yong-tong-xin-zu-kang-yao-qiu/">常用通信阻抗要求
| WwWangGuan</a></li>
</ol>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p><em>“没有调查，没有发言权。”–毛泽东《反对本本主义》</em></p>
</blockquote>
]]></content>
      <categories>
        <category>电子类</category>
        <category>SI</category>
      </categories>
      <tags>
        <tag>信号完整性</tag>
        <tag>特性阻抗</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-使用指南</title>
    <url>/2025/06/17/Git-Using_Guide/</url>
    <content><![CDATA[<p>本博客存放在Git使用过程中的常用指令与配置，随使用过程逐步更新。</p>
<span id="more"></span>
<h2 id="指令">指令</h2>
<ol type="1">
<li><p>查看配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="配置">配置</h2>
<h3 id="lf与crlf换行">LF与CRLF换行</h3>
<h4 id="具体措施">具体措施</h4>
<p>使用Hexo博客工具在推送至Github时，Bash内弹出大量警告：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">warning: <span class="keyword">in</span> the working copy of <span class="string">&#x27;tags/.../index.html&#x27;</span>, LF will be replby CRLF the next <span class="keyword">time</span> Git touches it</span><br></pre></td></tr></table></figure>
<p>查阅网络资料，发现<code>LF(\n)</code>与<code>CRLF(\r\n)</code>分别是Linux与Windows下的换行符。Git
Bash为Linux环境，Git工作区默认CRLF。最终push到远程仓库时git会统一格式全部转化为用<code>CRLF</code>作为换行符。</p>
<p>使用如下指令禁用如下转换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf <span class="literal">false</span> //禁用自动转换</span><br></pre></td></tr></table></figure>
<p>对于每一类文件的转换配置可以在
<code>.gitattributes</code>内配置，可见参考资料3。因目前未涉及不同文件，暂时不做其他调整。</p>
<h4 id="参考资料">参考资料</h4>
<ol type="1">
<li><a href="https://www.jianshu.com/p/783f7736e77e">解决hexo
deploy时出现的警告：LF will be replaced by CRLF - 简书</a></li>
<li><a href="https://stackoverflow.com/questions/17628305/windows-git-warning-lf-will-be-replaced-by-crlf-is-that-warning-tail-backwar">Windows
git “warning: LF will be replaced by CRLF”, is that warning tail
backward? - Stack Overflow</a></li>
<li><a href="https://juejin.cn/post/6942320745494085669">Git
优雅处理行结束符 - 掘金</a></li>
<li><a href="https://www.cnblogs.com/youpeng/p/11243871.html">git
core.autocrlf配置说明 - Youpeng - 博客园</a></li>
</ol>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p><em>人越脱离自然便越发恐惧孤独。</em></p>
</blockquote>
]]></content>
      <categories>
        <category>工具类</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>流量卡-性价比推荐</title>
    <url>/2025/06/10/Sideline-SIM_Card/</url>
    <content><![CDATA[<p>本篇博客存放博主个人觉得有点性价比的流量卡链接，顺便赚一点外快（如果可以的话……</p>
<p>每周五晚9:00更新链接，有需要的可以点击链接查看。</p>
<span id="more"></span>
<h2 id="订单查询">订单查询</h2>
<p><a href="https://vip.777haoka.cn/cha?k=bHJ1MGp0Vlg0RW89">点击查询订单状态</a></p>
<h2 id="办理链接2025.08.24更新">办理链接(2025.08.24更新)</h2>
<p>该链接主要放一些博主觉得不错的全国发货的流量卡，部分流量卡限制收货地所在省份，此处并未放置。如果有需求，也可以<a href="https://space.bilibili.com/405856572?spm_id_from=333.788.0.0">点击此处</a>在B站私信我。</p>
<p><span style="color:red"><strong>注意：下单之前请点击链接内的详细资料一栏，判断是否是禁发送区域，如果是则会审核失败，可以更换另外的链接…</strong></span></p>
<h3 id="移动">移动</h3>
<ol type="1">
<li><a href="https://vip.777haoka.cn/order/index.php?uid=bHJ1MGp0Vlg0RW89&amp;pid=2436">新移动淘气卡【选号后报单发货】29元100G通用+80G定向+200分钟+权益会员(自主激活，18-26岁,没有视频会员)</a></li>
<li></li>
<li></li>
</ol>
<h3 id="联通">联通</h3>
<ol type="1">
<li><a href="https://vip.777haoka.cn/order/index.php?uid=bHJ1MGp0Vlg0RW89&amp;pid=2455">联通小豹卡【三照下单】19元150G通用+300分钟(到期可续，18-25，自主激活,限量)</a></li>
<li><a href="https://vip.777haoka.cn/order/index.php?uid=bHJ1MGp0Vlg0RW89&amp;pid=2494">联通叮当卡26元125G【全国发货】无短信，自主激活(全国发货无禁区,自主激活,无短信功能,佣金可合追溯)</a></li>
<li><a href="https://vip.777haoka.cn/order/index.php?uid=bHJ1MGp0Vlg0RW89&amp;pid=2305">联通沃派卡【发货快】39元280G通用+100分钟+会员权益(自主激活，全国发货，18-26)</a></li>
<li><a href="https://vip.777haoka.cn/order/index.php?uid=bHJ1MGp0Vlg0RW89&amp;pid=2306">联通沃龙卡29元150G通用+300分钟(自主激活，18-25岁)</a></li>
<li><a href="https://vip.777haoka.cn/order/index.php?uid=bHJ1MGp0Vlg0RW89&amp;pid=2298">联通水花卡T2【四照发货】29元230G通用+300分钟+会员权益(自主激活，需上传一证通查发货,18-30)</a></li>
<li></li>
</ol>
<h3 id="电信">电信</h3>
<ol start="2" type="1">
<li></li>
</ol>
<h2 id="自用截图">自用截图</h2>
<p>博主个人自用移动保号套餐+联通流量卡，未出现流量限速和网络丢失的情况。</p>
<div>
<center>
<img src="image-20250610141933596.png" alt="image can't load." style="zoom:55%"> <br> 自用套餐
</center>
</div>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p><em>若待上林花似锦，出门俱是看花人。–城东早春</em></p>
</blockquote>
]]></content>
      <categories>
        <category>见闻类</category>
        <category>流量卡</category>
      </categories>
      <tags>
        <tag>流量卡</tag>
      </tags>
  </entry>
  <entry>
    <title>南昌大学-873控制工程考研形势</title>
    <url>/2025/06/02/NCU-873_Trends/</url>
    <content><![CDATA[<p>本篇博文简要介绍南昌大学控制科学与工程、控制工程截止2025年的考研形式…</p>
<span id="more"></span>
<p>整理的考情如下：</p>
<iframe src="/pdfjs/web/viewer.html?file=https://MicroPrism.github.io/2025/06/02/NCU-873_Trends/NCU873.pdf" width="80%" height="750" frameborder="0">
</iframe>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p><em>寒来暑往，来日方长。</em></p>
</blockquote>
]]></content>
      <categories>
        <category>见闻类</category>
        <category>考研形势</category>
      </categories>
      <tags>
        <tag>南昌大学</tag>
        <tag>873控制工程</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA-02-Verilog语法</title>
    <url>/2025/05/29/FPGA-02-Verilog_Syntax/</url>
    <content><![CDATA[<p>本文介绍Verilog
HDL基本语法，主要将该代码与类似的C/C#语言代码进行对比，根据架构的不同强调表示形式的差异（相较于上一篇FPGA博文更像基础内容…</p>
<span id="more"></span>
<h1 id="语法">语法</h1>
<h2 id="逻辑值">逻辑值</h2>
<p>FPGA内逻辑值除0、1外新增高阻态Z，表示无驱动。而实际运行中还可能出现亚稳态。</p>
<h2 id="标识符">标识符</h2>
<p>标识符用于定义常数、变量、信号、端口、子模块或参数名称，大小写则为不同变量。自定义标识符需要为数字、字母、下划线、$等，且首字母需要为字母或者下划线。</p>
<blockquote>
<p>类似于C语言的关键字，如int、void、const等等。自定义标识符不能与关键字冲突。</p>
</blockquote>
<h2 id="常量">常量</h2>
<p>Verilog中不变的值，分为整形、实型、字符串型。</p>
<p>在表示整形数据时可以有以下几种：</p>
<p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span>    <span class="comment">//位宽32的整数</span></span><br><span class="line"><span class="number">8&#x27;hab</span> <span class="comment">//8位hex值0xab</span></span><br><span class="line"><span class="number">8&#x27;d171</span><span class="comment">//8位dec值171</span></span><br><span class="line"><span class="number">8&#x27;o253</span><span class="comment">//8位oct值0253</span></span><br><span class="line"><span class="number">8&#x27;b101</span><span class="comment">//8位bin值</span></span><br></pre></td></tr></table></figure></p>
<p><strong><span style="color:red">
类似于C语言存在整形提升或数据截断，Verilog也存在此种问题。</span></strong></p>
<p>例如，C语言使用<code>uint8_t data_a = 0x123;uint8_t data_b =0x1;</code>定义两个变量，数据类型为8bit位宽，显然前者溢出而后者补足。类比到Verilog中只是修改了表述方式，在赋值时赋予位宽，而且不用按8bit对齐：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">a = <span class="number">8&#x27;h123</span>; <span class="comment">//溢出，随后截断为0x23</span></span><br><span class="line">b = <span class="number">12&#x27;h1</span>;	<span class="comment">//不足，补充为0x001</span></span><br></pre></td></tr></table></figure>
<p>实型数据，说白了就是浮点型，小数，可以采用<code>123.45e2</code>表示数值12345。</p>
<p>字符串指双信号中的字符序列，与C一致，存储的ASCII码值。例如下方字符串
<code>Open log file.</code>可以用C的printf输出，同样可以在verilog内用$display输出
:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> * log_str = <span class="string">&quot;Open log file.&quot;</span>;</span><br><span class="line">pringtf(<span class="string">&quot;%s&quot;</span>,log_str);</span><br><span class="line">...</span><br><span class="line">$display(<span class="string">&quot;Open log file.&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="变量类型">变量类型</h2>
<p>Verilog的变量类型基于FPGA的结构基础。FPGA可以抽象成若干门电路，其内部是<strong>电路的连接</strong>，因此定义变量时即分为：</p>
<ul>
<li>线网：<strong>物理电路层面的通路</strong>，wire；</li>
<li>寄存器：<strong>软件层面的变量</strong>，reg；</li>
</ul>
<p>always或initial中被赋值的量数据reg量，assign分配的量属于wire型量。</p>
<blockquote>
<p>C语言最底层的设计最多是操作硬件IO，大多数是存储在堆、栈里的软件量，进行软件层面的运算。Verilog是直接基于电路，搭的是电路，软件量用于进行辅佐运算。</p>
</blockquote>
<h2 id="参数">参数</h2>
<p>此处参数是指module块内部的参数，用于定义状态机的状态、数据位宽和计数器计数个数大小等。例如下方定义的的<code>CNT_MAX</code>：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Parameter CNT_MAX = <span class="number">25&#x27;d24_999_999</span></span><br></pre></td></tr></table></figure>
<p>在实例化模块时可以配置参数：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">counter </span><br><span class="line">#( </span><br><span class="line">    <span class="variable">.CNT_MAX</span> (<span class="number">25&#x27;d24</span> ) <span class="comment">//实例化时参数可修改 </span></span><br><span class="line"> )</span><br><span class="line">counter_inst </span><br><span class="line">(</span><br><span class="line">    <span class="variable">.sys_clk</span> (sys_clk ), <span class="comment">//input sys_clk</span></span><br><span class="line">    <span class="variable">.sys_rst_n</span> (sys_rst_n ), <span class="comment">//input sys_rst_n</span></span><br><span class="line">	<span class="variable">.led_out</span> (led_out ) <span class="comment">//output led_out </span></span><br><span class="line">);          </span><br></pre></td></tr></table></figure>
<p>那么我们可以这么类比C语言，一个module可以当做一个函数，如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test(</span><br><span class="line">	<span class="keyword">input</span> a,</span><br><span class="line">    <span class="keyword">inout</span> b,</span><br><span class="line">    <span class="keyword">output</span> c</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在不管内部如何处理的情况下，其中的输入、输出、输入输出就可以类似为下方的a、b、c，只不过所处的位置不同，修饰也更加直观:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a,<span class="type">int</span> * b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c = a + *b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="赋值">赋值</h2>
<p>此处应当注意，Verliog中包括
<code>=</code>以及<code>&lt;=</code>两种符号。首先思考其底层结构——门电路，搭建的不同的物理电路当然可以执行多个程序流（目前还没学到，暂时这么称呼），也就是常说的<strong>并行逻辑</strong>。</p>
<blockquote>
<p>MCU则是顺序执行逻辑，从上至下，从外至内逐步执行。为了达到类似的并行效果，衍生出了FreeRTOS、uCOSIII等操作系统，频繁切换线程达到并行的假象。</p>
</blockquote>
<p>MCU上有顺序转并行的方案，FPGA上也有类似的顺序执行的模块，比如说每个always块上是一个互相独立的并行块，那么always内部应该可以通过某种方式来达到顺序执行的效果——引出阻塞、非阻塞赋值。</p>
<ul>
<li><p>非阻塞赋值 &lt;=</p>
<p>非阻塞赋值不会影响下一个语句的执行。<strong>在某个时刻，一段非阻塞赋值代码是同时执行的，所有代码执行完后再进行赋值操作、刷新结果。</strong>例如下方代码，假设a初值为1：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">a &lt;= a+<span class="number">1</span>;  <span class="comment">//line 1</span></span><br><span class="line">b &lt;= a;	<span class="comment">//line 2</span></span><br></pre></td></tr></table></figure>
<p>那么在运行时，line 1 与 line 2
同时执行，用于运算的a值为1，运行完后<code>a=2，b=1</code>。</p></li>
<li><p>阻塞赋值 =</p>
<p><strong>阻塞赋值语句按照顺序执行，执行完立即进行赋值操作、刷新结果</strong>，上一句代码会影响下一句的执行。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">a = a + <span class="number">1</span>; <span class="comment">//line 1</span></span><br><span class="line">b = a; 	   <span class="comment">//line 2</span></span><br></pre></td></tr></table></figure>
<p>上方的代码在运行时，执行完line
1得<code>a = 2</code>，立刻将该值用于下一句代码，得到<code>b=2</code>。</p></li>
</ul>
<p>这种思路与C中<code>a++</code>和
<code>++a</code>类似，阻塞就是<code>a++</code>用上一时刻的值进行计算，随后刷新，而非阻塞就是<code>++a</code>，我执行完代码，立刻用新的值进行后续运算。</p>
<h2 id="运算符">运算符</h2>
<ul>
<li><p>算术运算：<code>+、-、*、/</code></p></li>
<li><p>关系运算：<code>&gt;、&lt;、&gt;=、&lt;=</code>，在没有括号的情况下优先进行算术运算。</p></li>
<li><p><strong>归约运算/位运算</strong>：<code>&amp;、|、^、~&amp;、~|、~^</code></p>
<p>C语言中的位运算符属于双目运算符(C++、C#暂且不说)，而Verilog中可以用于一个变量得出一个bit值，如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">&amp;<span class="number">4</span>b&#x27;<span class="number">1010</span> = <span class="number">1</span>&amp;<span class="number">0</span>&amp;<span class="number">1</span>&amp;<span class="number">0</span> = <span class="number">1&#x27;b0</span></span><br></pre></td></tr></table></figure>
<p>如果把1个bit当作一个门的输出，那么一个数据的归约运算当然可以看作多个电路接入一个与或非门。</p>
<p>在Verilog中，双目运算和C基本一致，但是<strong>限定左右参数位宽一致</strong></p></li>
<li><p>逻辑运算：<code>&amp;&amp;、||、!=</code>等，不再赘述</p></li>
<li><p>移位运算符：<code>&lt;&lt;、&gt;&gt;</code>，逻辑与C基本一致。<strong>但是右操作数如果为x（不定值）或z（高阻），那么运算结果为不定值。</strong></p></li>
<li><p>条件运算符：<code>exp1 ? action1 : action2</code>，这个表达式与C一致，多层嵌套时也是就近结合。</p></li>
</ul>
<p>运算符的优先级：一元（归约）&gt;二元（算术、移位、关系、等和不等、按位运算）&gt;三元（条件运算）。</p>
<p>其优先级也类似C语言，一般使用<code>()</code>区分。</p>
<ul>
<li>位拼接标识符：<code>&#123;,&#125;</code>，常用来拼接不同位宽的数据，同时可以实现数据右移和左移。</li>
</ul>
<h2 id="选择语句">选择语句</h2>
<p>与C语言相同，包括<code>if-else</code> 和<code>case</code>
语句，在此不再赘述。但是需要注意：</p>
<ul>
<li>如果if语句没有else块，可能会在组合逻辑中产生latch</li>
<li>if语句尽量写成多个else if的分支形式，而不建议写成if else 内嵌套if
else的语句</li>
</ul>
<h2 id="参数类型">参数类型</h2>
<p>把该节起名为参数类型的原因是希望参照C语言的函数，划分输入输出的思路。</p>
<p>Verilog的参数类型可以划分为<code>input、output、inout</code>三类，我们可以这么类比：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">input</span> <span class="keyword">wire</span> sel,</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">input</span> <span class="keyword">wire</span> data_out,</span><br><span class="line">        <span class="keyword">inout</span> <span class="keyword">wire</span> data_bus,</span><br><span class="line">        <span class="keyword">output</span> <span class="keyword">wire</span> data_in</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li>sel、data_out: 物理线型输入参数</li>
<li>data_bus: 物理线型可输入可输出参数，例如I2C数据线</li>
<li>data_in: 物理线型输出参数</li>
</ul>
<p>那么显式的对比到C语言中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">uint8_t</span> <span class="title function_">test</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">volatile</span> <span class="type">const</span> <span class="type">uint8_t</span> sel,      <span class="comment">//只能输入</span></span></span><br><span class="line"><span class="params">	<span class="keyword">volatile</span> <span class="type">const</span> <span class="type">uint8_t</span> data_out, <span class="comment">//只能输入</span></span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">    <span class="keyword">volatile</span> <span class="type">uint8_t</span> * data_bus <span class="comment">//可做输入，可修改值</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">return</span> data_in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中的volatile表示易变量。每次从硬件地址重新读取</li>
<li>其中的const显示表示这个量不可被软件层面修改</li>
<li>verilog中若有多个输出，C中可集成在一个结构体中</li>
</ul>
<h1 id="仿真">仿真</h1>
<p>时间单位与精度</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns </span><span class="comment">// 单位1ns 精度1ns</span></span><br><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/10ps </span><span class="comment">// 单位1ns 精度10ps，则#10.11表示10.11ns = 10110 ps</span></span><br></pre></td></tr></table></figure>
<p>其中<strong>前者是时间单位，后者是仿真的最小刻度，精度必须小于时间单位。</strong></p>
<h2 id="调试函数">调试函数</h2>
<p>FPGA里的函数依靠<code>$</code>符号为区分，功能类似C。</p>
<ol type="1">
<li><p>$display 打印信息,打印后自动换行</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;%d+%d=%d&quot;</span>,a,b,c);</span><br><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>等价于printf，例如printf(“%d”,a);但是$display可以不加格式符，默认为十进制。</p>
<p>这个例子用C#函数来解释就是Console.WriteLine(…);函数</p>
</blockquote></li>
<li><p>$write打印信息</p>
<p>用法几乎完全同
<code>$display</code>，但是<code>write</code>可以使用换行符</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$write</span>(<span class="string">&quot;%d+%d=%d\n&quot;</span>,a,b,c);</span><br></pre></td></tr></table></figure></li>
<li><p><span class="math inline"><em>s</em><em>t</em><em>r</em><em>o</em><em>b</em><em>e</em>，<em>格</em><em>式</em><em>同</em></span>display。<strong>但是该函数是在触发操作后执行的。</strong>
例如下方代码，在 <code>initial</code>块触发最后执行。</p>
<div>
<center>
<img src="image-20250601142141567.png" alt="image can't load." style="zoom:75%"> <br> $strobe代码示意
</center>
</div>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">display:<span class="number">0101</span>+xxxx=x</span><br><span class="line">strobe:<span class="number">0101</span>+<span class="number">0110</span>=<span class="number">11</span></span><br></pre></td></tr></table></figure></li>
<li><p>$
monitor，持续监测量，使用格式同上方几个函数。但可以理解为C语言中的数据断点，当监测量变发生化时输出调试信息。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    a = <span class="number">5</span>; <span class="comment">//输出</span></span><br><span class="line">    #<span class="number">100</span>;</span><br><span class="line">    b = <span class="number">6</span>; <span class="comment">//输出</span></span><br><span class="line">    #<span class="number">100</span>;</span><br><span class="line">    c = a + b; <span class="comment">//输出</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">initial</span> <span class="built_in">$monitor</span>(<span class="string">&quot;%d+%d=%d&quot;</span>,a,b,c);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="终止函数">终止函数</h2>
<ol type="1">
<li>$stop，暂停仿真。可使用modelsim指令或按键继续仿真。</li>
<li>$finish，结束仿真。只可重新开始。</li>
</ol>
<h2 id="配置函数">配置函数</h2>
<ol type="1">
<li><p>$time，返回64bit<strong>当前仿真时间</strong></p></li>
<li><p>$random，产生随机数</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> #<span class="number">10</span> a = <span class="built_in">$random</span>;</span><br><span class="line"><span class="keyword">initial</span> <span class="built_in">$monitor</span>(<span class="string">&quot;a = %d @time %d&quot;</span>,a,<span class="built_in">$time</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>$readmemb，读取二进制文件</p></li>
<li><p>$readmemh，读取十六进制文件</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] a [<span class="number">20</span>:<span class="number">0</span>]; <span class="comment">// 21位位深，8位位宽的数组</span></span><br><span class="line"><span class="comment">//等价于 uint8_t a[21];</span></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$readmemb</span>(<span class="string">&quot;text.txt&quot;</span>,a);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;=<span class="number">20</span>; i=i+<span class="number">1</span> ) <span class="keyword">begin</span></span><br><span class="line">           	#<span class="number">10</span>;</span><br><span class="line">            <span class="built_in">$write</span>(<span class="string">&quot;%s&quot;</span>,a[i]);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p><em>与人同行的前提是，你要先在路上。</em></p>
</blockquote>
]]></content>
      <categories>
        <category>电子类</category>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA-01-关于ZYNQ</title>
    <url>/2025/04/20/FPGA-01-About_ZYNQ/</url>
    <content><![CDATA[<p>该博文记录学习FPGA的演变过程、主要功能、性能差异等基础知识（感觉并没有什么参考意义….</p>
<span id="more"></span>
<h1 id="pld器件">PLD器件</h1>
<p>FPGA: Field Programmable Gate
Array，即现场可编程门阵列，属于可编程器件PLD（Programmable Logic
Device），类似的有PLA、PAL、CPLD等器件。</p>
<h2 id="pla与prom">PLA与PROM</h2>
<p>PLA与PROM为早期反熔丝型PLD电路。PLA（Programmable Logic
array）中通过与门、非门构成“与平面”，“或平面”，以及一次性的编程矩阵。</p>
<div>
<center>
<img src="image-20250420205204194.png" alt="image can't load." style="zoom:75%"> <br> PLA内部结构
</center>
</div>
<p>可编程只读存储器PROM（Programmable Read-Only
Memory）与PLA类似，均是通过“与连接矩阵与“或连接矩阵”组成，<strong>但是PROM的结构上与连接矩阵固定，仅”或矩阵”可进行一次编程</strong>，如下图。</p>
<div>
<center>
<img src="image-20250420210628775.png" alt="image can't load." style="zoom:75%"> <br> PROM内部结构
</center>
</div>
<h2 id="pal与gal">PAL与GAL</h2>
<p>在PLA与PROM的基础上又延伸出其他两种类型，即PAL（Programmable Array
Logic）和GAL（Generic Array Logic）。</p>
<p>其中PAL相对于PROM结构类似，只是<strong>PAL是仅”与连接矩阵”可编程</strong>，仍然为反熔丝工艺，仅可编程1次。</p>
<p>PAL根据输出电路工作模式可分为三类：</p>
<ul>
<li>三态输出</li>
<li>寄存器输出</li>
<li>互补输出</li>
</ul>
<div>
<center>
<img src="image-20250420211339732.png" alt="image can't load." style="zoom:75%"> <br> PAL内部结构
</center>
</div>
<p>GAL相对于PAL改进：</p>
<ul>
<li>CMOS工艺，电可擦除，可多次编程</li>
<li>可编程的输出逻辑宏单元OLMC（Output Logic Macro Cell）</li>
</ul>
<p>其中OLMC可通过编程控制GAL输出，覆盖PAL的三种模式。</p>
<h2 id="cpld与fpga">CPLD与FPGA</h2>
<p>复杂可编程逻辑器件CPLD（Complex Programmable Logic
Device）可以看作若干PLA与可编程连接矩阵的集合。内部结构如图。</p>
<div>
<center>
<img src="image-20250420215617600.png" alt="image can't load." style="zoom:75%"> <br> CPLD内部结构
</center>
</div>
<p>FPGA内大量使用LUT查找表和寄存器，可分为SRAM、反熔丝、Flash三种类型，包括可编程的：</p>
<ul>
<li>逻辑块</li>
<li>布线资源</li>
<li>IO口</li>
</ul>
<div>
<center>
<img src="image-20250420204136714.png" alt="image can't load." style="zoom:75%"> <br> FPGA与CPLD对比
</center>
</div>
<p>FPGA的应用场景对比单片机和ARM，主要优势9是灵活高效、高吞吐量、低批量延时、快速并行运算、可重构、可重复编程、可实现定制性能和定制功耗。</p>
<h1 id="zynq">ZYNQ</h1>
<p>Xilinx内的ZYNQ系列芯片内包括一块Cortex-A9的硬件ARM处理器，称为为PS。其余的逻辑部分，称为PL，PL上可以使用逻辑块搭载MicroBlaze软核处理器。</p>
<h2 id="ps-端">PS 端</h2>
<p>ZYNQ内除去ARM外，还包括应用处理单元APU（Application Processing
Unit）、扩展外设、cache存储器、存储器接口、互联接口、时钟发生电路。</p>
<h2 id="apu">APU</h2>
<div>
<center>
<img src="image-20250425103918783.png" alt="image can't load." style="zoom:75%"> <br>
<center>
APU框架
</center></center></div>
<ul>
<li>双ARM核、NEONTM媒体处理引擎MPE（Media Processing
Engine）、浮点计算单元FPU（Floating Point
Unit）、内存管理单元MMU（Memory Management
Unit）、一级cache存储器（指令+数据）</li>
<li>一致性控制单元SCU（Snoop Control
Unit）：ARM与OCM和二级cache之间的连接桥。可用加速一致端口ACP（Accelerator
Coherency Port）管理PS与PL的访问</li>
<li>二级cache、片上存储器OCM（On Chip
Memory），包括256kB的RAM和128kB的BootRAM。</li>
</ul>
<h3 id="存储器接口">存储器接口</h3>
<p>ZYNQ-7000系列存储器接口包括动态+静态口。</p>
<ul>
<li><p>动态存储器控制器</p>
<ol type="1">
<li>核心存储控制器和调度器DDRC</li>
<li>AXI存储器端口接口DDRI</li>
<li>数字PHY及控制器DDBP，可用于DDR2/3、DDR3L、LPDDR2</li>
</ol></li>
<li><p>静态存储控制器</p>
<p>SMC（Static Memory
Controller），可用作NAND闪存控制器、或并口存储器控制器，支持NAND闪存、NOR闪存、异步SRAM。</p></li>
<li><p>QSPI</p>
<p>程序烧录，程序固化。</p></li>
</ul>
<h3 id="外部接口">外部接口</h3>
<p>PS和外部通信主要通过复用的输入/输出MIO（Multiplexed
Input/Output，MIO）实现，直接连接在PS端。但扩展的MIO即EMIO需要通过PL端转接，QSPI、USB、SMC不适用于PL的EMIO接口。</p>
<p>出去4组32位的GPIO外，对外接口还包括各2组：SPI、I2C、CAN、UART、SD、USB、GigE（Ethernet）。</p>
<h2 id="pl端">PL端</h2>
<p>Xilinx
FPGA芯片的组成部分：可编程输入输出单元IOB、可配置逻辑块CLB、嵌入式块RAM、布线资源、底层内嵌功能单元、底层内嵌专用硬核等。</p>
<h3 id="iob">IOB</h3>
<p>需要注意，FPGA每个Bank的VCC电压不同，一个Bank仅有一个电压。</p>
<p>I/O组被分类为高性能HP（High Performance）和高范围HR（High
Range）。</p>
<ul>
<li>HP：VCC为1.8V，常作连接存储器和其他芯片的高速接口</li>
<li>HR：VCC为3.3V，适合各种IO标准</li>
</ul>
<p>HP与HR均支持单端、差分输入，具体可以查阅引脚说明。</p>
<p><strong>每个IOB包括IOSERDER，可作串转并或并转串。</strong></p>
<h3 id="clb">CLB</h3>
<p>CLB指可编程逻辑块，逻辑单元最小规模。Slice片是CLB的子单元。</p>
<p><strong>ZYNQ的片是由4个查找表（LUT）+8触发前+其他逻辑组成的。</strong></p>
<h3 id="bram">BRAM</h3>
<p>嵌入式块RAM，用于生成RAM、ROM、FIFO及移位寄存器等常用的存储模块。</p>
<p>ZYNQ的BRAM由60个存储块组成：</p>
<ul>
<li>每个块RAM由2个18kB的BRAM组成；</li>
<li>以块为单位使用；</li>
<li>3类分组，即BRAM（36kB）；BRAM（18kB）+BRAM（18kB），BRAM+FIFO。由于仅包括1个FIFO
Logic，只能生成一组FIFO控制信号。</li>
</ul>
<p><strong>使用块RAM即在片内用小物理空间存储大量数据</strong>。</p>
<h3 id="硬核">硬核</h3>
<p>ZYNQPL端内嵌XADC，即两个模数转换器。且有接口可以连接至PS端。</p>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p><em>大梦谁先觉，平生我自知。–《三国演义》</em></p>
</blockquote>

]]></content>
      <categories>
        <category>电子类</category>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>ZYNQ</tag>
      </tags>
  </entry>
  <entry>
    <title>SpaceDesk-Win与iPad有线扩展</title>
    <url>/2025/04/19/SpaceDesk-Secondary_Screen/</url>
    <content><![CDATA[<p>Win与平板在同一无线网络下，很容易实现无线连接，但无线延迟较高、设备易发热。有线连接延迟低、帧率高，这篇博客可以让闲置的iPad来跳“最后一舞”，前提是有一个正在吃灰的iPad…
<span id="more"></span></p>
<h1 id="设备说明">设备说明</h1>
<ul>
<li>Windows 11, Type-C</li>
<li>iPad Air4， Type-C</li>
<li>iPad原装双端Type-C数据线</li>
</ul>
<h1 id="软件说明">软件说明</h1>
<h2 id="win端">Win端</h2>
<ol type="1">
<li><p>下载安装SpaceDesk</p>
<p>SpaceDesk官网：<a href="https://www.spacedesk.net/download/#server-driver">最新版本
点击下载</a></p>
<p>百度网盘：<a href="https://pan.baidu.com/s/18-q_8Ee8a7pfuRcNfBlofw?pwd=8eis">v2.1.15
点击下载</a></p></li>
<li><p>下载安装iTunes</p>
<p>打开Win自带的微软商店，搜索下载。</p>
<div>
<center>
<img src="image-20250419103753851.png" alt="image can't load." style="zoom:75%"> <br> Fig.1 Microsoft Store
</center>
</div>
<p>疑似v2.1.15
版本的SpaceDesk不具备iPad连接的驱动，需要使用iTunes连接1次，后续就不再使用。</p></li>
</ol>
<h2 id="ipad-端">iPad 端</h2>
<p>App Store 搜索spacedesk下载。</p>
<div>
<center>
<img src="image-20250419104020718.png" alt="image can't load." style="zoom:50%"> <br> Fig.2 App Store
</center>
</div>
<p>安装完成后打开软件，设置最高画质、自动旋转、自动改变IP等，iPad端无需其他操作。</p>
<h1 id="常见问题">常见问题</h1>
<h2 id="黑白显示">黑白显示</h2>
<p>原因：SpaceDesk并非是最新版本。下载官网最新版本。</p>
<h2 id="连接type-c无反应">连接Type-c无反应</h2>
<p>原因：汉化包Bug。</p>
<p>打开安装包，Remove当前安装版本，重新安装，不要打汉化</p>
<h1 id="参考资料">参考资料</h1>
<p>【1】<a href="https://blog.csdn.net/qq_42013947/article/details/136596644?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=LXHYouth&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-136596644.142%5Ev102%5Epc_search_result_base6&amp;spm=1018.2226.3001.4187">LXHYouth|使用SpaceDesk实现iPad成为电脑拓展屏(保姆级教程)-CSDN博客</a></p>
<p>【2】<a href="https://www.bilibili.com/video/BV1NQ4y1A7PD/?share_source=copy_web&amp;vd_source=793e603d878f9531350764468aa132ce">我想当饼藏|ipad作为副屏与Windows电脑有线连接-哔哩哔哩</a></p>
<p>【3】<a href="https://www.bilibili.com/opus/912838630992510994?spm_id_from=333.1387.0.0">咸鱼羊同学|Windows与iPad有线副屏SpaceDesk扩展与常见问题
- 哔哩哔哩</a></p>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p><em>他山之石，可以攻玉。–《诗·小雅·鹤鸣》</em></p>
</blockquote>
]]></content>
      <categories>
        <category>工具类</category>
        <category>副屏扩展</category>
      </categories>
      <tags>
        <tag>SpaceDesk</tag>
        <tag>副屏扩展</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-博客搭建</title>
    <url>/2025/04/09/Hexo-Build_Blog/</url>
    <content><![CDATA[<p>该博客主要介绍使用Hexo工具在Github上搭建Next主题个人博客的简要过程，列举所参考的视频与帖子连接，同时汇总个人搭建过程中遇到的各种错误和解决办法。</p>
<span id="more"></span>
<h1 id="参考资料">参考资料</h1>
<p>博客搭建所使用的部件如下：</p>
<ul>
<li>Github：用于博客线上浏览</li>
<li>Git: 线上推送工具</li>
<li>Hexo：用于管理本地博客内容、主题与线上推送</li>
<li>Sublime Text：用于管理博客文件夹，无需来回跳转</li>
</ul>
<p>博客搭建所用的参考视频为：</p>
<p>【1】<a href="https://www.bilibili.com/video/BV1cW411A7Jx/?spm_id_from=333.337.top_right_bar_window_history.content.click&amp;vd_source=5465b0f4790ebae45362caa6519f3b79">hojun_cn|手把手教你搭建属于自己的hexo+github博客-BiliBili</a></p>
<p>博客美化参考的教程如下：</p>
<p>【1】<a href="https://hexo-next.readthedocs.io/zh-cn/latest/">Hexo-NexT</a></p>
<p>【2】<a href="https://vic.kim/2019/05/25/Hexo博客优化之Next主题美化/">Hexo博客优化之Next主题美化
| Vicの博客</a></p>
<p>【3】<a href="https://xiamu-ssr.github.io/Hexo/2024/06/19/2024-H1/2024-06-19-12-31-52/">如何优雅的使用Github
Action服务来将Hexo部署到Github Pages - Hexo</a></p>
<p>【4】<a href="https://github.com/theme-next/theme-next-canvas-nest/blob/master/README.md">Hexo
v7.0+的canvas-nest插件配置-Github</a></p>
<p>【5.1】<a href="https://blog.csdn.net/Aoman_Hao/article/details/89416634">Hexo博客Next主题建立标签云-CSDN博客</a></p>
<p>【5.2】<a href="https://github.com/D0n9X1n/hexo-tag-cloud/blob/master/README.ZH.md">Hexo的hexo-tag-cloud插件使用手册-Github</a></p>
<p>【6】<a href="https://blog.csdn.net/kantaiyang/article/details/129159055">Hexo无法显示本地图片的问题-CSDN博客</a></p>
<p>【7】<a href="https://tanwucheng.github.io/2021/03/03/4.Hexo博客NexT主题设置RSS订阅/">HEXO笔记④-Hexo博客NexT主题设置RSS订阅
| Ten’s Blog</a></p>
<p>【8.1】<a href="https://blog.mrshallwe.com/2022/03/16/hexo%20的%20Next%20主题%20中添加首页文章置顶功能及置顶图标/">hexo
的 Next 主题 中添加首页文章置顶功能及置顶图标 | ShallWe -
官方博客</a></p>
<p>【8.2】<a href="https://blog.csdn.net/qq_41603102/article/details/117203360">Hexo+Next8的升级踩坑之旅_next
8 config-CSDN博客</a></p>
<p>【9】<a href="https://www.cai-like.com/blog/2025/07/hexo-render-latex/">Hexo主题插入代码块
| Like’s Blog</a></p>
<h1 id="常用指令">常用指令</h1>
<p>Hexo创建本地博客仓库后，使用<strong>控制台</strong>或<strong>Git Bash
Here</strong>输入指令进行博文管理，详见<a href="https://hexo.io/zh-cn/docs/commands">指令 |
Hexo</a>，以下简要介绍常用指令</p>
<ol type="1">
<li><p>网站生成–生成本地网站</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure></li>
<li><p>网站推送–推送至github</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></li>
<li><p>创建本地端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s -p 5555</span><br></pre></td></tr></table></figure>
<p>该指令将创建本地5555端口，可在浏览器中输入<code>localhost:5555</code>进行查看，但并未推送至线上。</p></li>
</ol>
<h1 id="常见问题">常见问题</h1>
<p>虽然有视频参考，但作者在使用时仍然出现一些问题，在此种树帮后人乘凉。</p>
<h2 id="问题速查">问题速查</h2>
<ol type="1">
<li><a href="#本地仓库初始化失败">本地仓库初始化失败</a>
<ol type="1">
<li>仓库名不一致</li>
<li>无法在某个硬盘的根目录下创建仓库</li>
<li>SSL证书报错</li>
</ol></li>
<li><a href="#更改主题后生成时报错">更改主题后生成时报错</a>
<ol type="1">
<li>主题包与配置文件内不一致</li>
<li>已生成缓存未更新</li>
</ol></li>
<li><a href="#无法推送至Github仓库">无法推送至Github仓库</a></li>
<li><a href="#新增侧边栏项目后出错">新增侧边栏项目后出错</a></li>
<li><a href="#创建新标签后访问错误">创建新标签后访问错误</a></li>
<li><a href="#自定义图标不显示">自定义图标不显示</a></li>
<li><a href="#GitHub端推送错误(Fatal:502)">GitHub端推送错误(无法访问镜像站，Fatal:502)</a></li>
<li><a href="#网页端公式渲染异常">网页端公式渲染异常</a></li>
</ol>
<h2 id="插件版本">插件版本</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo: 7.3.0</span><br><span class="line">node: 22.14.0</span><br><span class="line">next: 8.23.0</span><br></pre></td></tr></table></figure>
<h2 id="本地仓库初始化失败">本地仓库初始化失败</h2>
<p><strong>原因1：在Github创建仓库时的仓库名与本地仓库名不一致。</strong></p>
<p>举个栗子：作者在Github的仓库名为<code>AAA</code>，那么使用<code>hexo init AAA</code>指令时的本地仓库路径应该为<code>C:\Blog</code>，文件夹名称为<code>AAA</code>。</p>
<p><strong>原因2：无法在某个硬盘的根目录下创建仓库。例如在<code>C:</code>文件夹下初始化将失败。</strong></p>
<p>举个栗子：在本地文件夹下应该创建子文件夹，如<code>C:\Blog</code>或者你喜欢的其他名称。</p>
<p><strong>原因3：SSL证书报错，如下。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init AAA</span><br><span class="line">INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git</span><br><span class="line">fatal: unable to access <span class="string">'https://github.com/hexojs/hexo-starter.git/'</span>: SSL certificate problem: unable to get <span class="built_in">local</span> issuer certificate</span><br><span class="line">WARN  git <span class="built_in">clone</span> failed. Copying data instead</span><br><span class="line">INFO  Install dependencies</span><br><span class="line">INFO  Start blogging with Hexo!</span><br></pre></td></tr></table></figure>
<p>解决办法：首先下载最新版本Git，某些旧版本可能会失败。其次，Git在下载后默认为Linux终端加密，使用以下指令修改配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global http.sslbackend schannel</span><br></pre></td></tr></table></figure>
<p><span style="color:red"><strong>不建议使用以下指令：该指令关闭安全检查，可能会受到外部攻击。</strong></span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global http.sslVerify <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="更改主题后生成时报错">更改主题后生成时报错</h2>
<p>此时进行本地查看，网页端将显示空白界面。生成阶段的报错信息如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">WARN  No layout: 2025/04/09/hello-world/index.html</span><br><span class="line">WARN  No layout: archives/index.html</span><br><span class="line">WARN  No layout: archives/2025/index.html</span><br><span class="line">WARN  No layout: archives/2025/04/index.html</span><br><span class="line">WARN  No layout: index.html</span><br></pre></td></tr></table></figure>
<p>原因1：主题包名称与<code>_config.yml</code>中不一致，检查文件名。</p>
<p>举个例子：作者使用<code>next</code>主题，在github上下载的主题包名称为<code>xxxx_next_xxx</code>形式。将主题包与<code>_config.yml</code>中修改为<code>next</code>或其他相同的名称即可。</p>
<p>原因2：原有缓存内容未更新。使用以下指令重新生成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g</span><br></pre></td></tr></table></figure>
<h2 id="无法推送至github仓库">无法推送至Github仓库</h2>
<p>仓库分支名有误。Github默认仓库名曾由<code>master</code>修改为<code>mian</code>，
但Hexo默认分支为<code>master</code>。</p>
<p>解决办法：在<code>_config.yml</code>内找到<code>branch</code>分支，并修改为<code>main</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">	<span class="string">type:git</span></span><br><span class="line">	<span class="string">repo:xxx</span> <span class="comment">#你的Github仓库</span></span><br><span class="line">	<span class="string">branch：main</span></span><br></pre></td></tr></table></figure>
<h2 id="新增侧边栏项目后出错">新增侧边栏项目后出错</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">YAMLException: can not <span class="built_in">read</span> a block mapping entry; a multiline key may not be an implicit key (4:1)</span><br></pre></td></tr></table></figure>
<p>原因1：文件的<code>front-matter</code>内存在中英文字符混用。</p>
<p>解决办法：使用英文字符，并且后跟空格。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: 关于</span><br><span class="line"><span class="built_in">date</span>: 2025-04-16 13:20:26</span><br><span class="line">tags: about</span><br></pre></td></tr></table></figure>
<h2 id="创建新标签后访问错误">创建新标签后访问错误</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Cannot GET /about/</span><br></pre></td></tr></table></figure>
<p><strong>可能并未创建对应的文件夹，或者文件名称有误。</strong></p>
<p>解决办法：new
page创建新文件夹，文件夹内的文件名<strong>必须为<code>index.md</code></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page about</span><br></pre></td></tr></table></figure>
<p>并且注意，此时需要更改内部的tags，比如</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: 关于</span><br><span class="line"><span class="built_in">date</span>: 2025-04-16 13:20:26</span><br><span class="line">tags: about</span><br></pre></td></tr></table></figure></p>
<h2 id="自定义图标不显示">自定义图标不显示</h2>
<p>网络上大多数是旧版本Hexo
或者Next主题的配置方案，按照他们的步骤可能找不到相同的文件 …
如本节内4篇博客方案，均无法复刻。</p>
<p>【1】<a href="https://blog.csdn.net/weixin_44634406/article/details/122777058">hexo
next 解决自定义侧边栏用户社交链接小图标 custom sidebar social
icon_next自定义图标-CSDN博客</a></p>
<p>【2】<a href="https://ouyen.github.io/hexo-icon/">给hexo next扩展图标
| 纯白的小站</a></p>
<p>【3】<a href="https://lockrim.top/2023/03/29/Next主题fa图标问题/">Next主题fa图标问题
| LockRim·小站</a></p>
<p>【4】<a href="https://yelog.org/2020/12/28/3-hexo-add-icon/">3-hexo添加自定义图标
| 叶落阁</a></p>
<p>原因：参照<a href="https://lockrim.top/2023/03/29/Next主题fa图标问题/">博客3</a>发现可能涉及到不同版本Font
Awesome(简称fa)图标库，V5和V6涵盖的图标数不同。其他图标可在<a href="https://www.iconfont.cn/?spm=a313x.search_index.i3.2.7d813a81xrirca">iconfont图标库</a>下载。</p>
<p>解决办法：next
v8.23.0版本<code>_config.yml</code>文件注释表明其已集成fa库，在<a href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">链接6</a>中搜索图标名，如<code>bilibili</code>。如果有结果，则可在Next主题配置文件中使用<code>fab fa-bilibili</code>，在<code>.md</code>文档内中按如下格式使用：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">'fa-brands fa-bilibili'</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">'fa-brands fa-bilibili'</span> <span class="attr">style</span>=<span class="string">'font-size:20px'</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">'fa-brands fa-bilibili'</span> <span class="attr">style</span>=<span class="string">'font-size:36px;color:red'</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">'custom-button'</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">'fa-brands fa-bilibili'</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> <span class="language-xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><i class="fa-brands fa-bilibili"></i>
<i class="fa-brands fa-bilibili" style="font-size:20px"></i>
<i class="fa-brands fa-bilibili" style="font-size:36px;color:red"></i>
<button class="custom-button"><i class="fa-brands fa-bilibili"></i>
</button></p>
<p>但该版本Next主题中，即使从<a href="https://www.iconfont.cn/?spm=a313x.search_index.i3.2.7d813a81xrirca">iconfont</a>下载图标代码也难以插入到本地<code>.css</code>或者<code>.styl</code>文件。</p>
<p>【5】<a href="https://www.iconfont.cn/?spm=a313x.search_index.i3.2.7d813a81xrirca">iconfont-阿里巴巴矢量图标库</a></p>
<p>【6】<a href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css</a></p>
<p>【7】<a href="https://fontawesomeicons.com/tryit/fa/v6/bilibili">fa-brands
fa-bilibili — Tryit Editor</a></p>
<h2 id="网页端无法预览pdf">网页端无法预览PDF</h2>
<p>在使用Hexo的过程中发现除去可以插入图像文件外，还可以插入pdf文件进行在线预览。类似以下样例，一个网页内插入了一个方框显示pdf内容：</p>
<div>
<center>
<img src="image-20250604084524431.png" alt="image can't load." style="zoom:75%"> <br> Fig.1 PDF预览(参考资料1)
</center>
</div>
<p>博主预期在Next主题下实现类似功能。</p>
<p><strong>解决方案：</strong></p>
<p>首先在<code>next/_config.yml</code>主题配置文件内使能pdf配置。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pdf:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="string">enable</span></span><br><span class="line">  <span class="comment"># Default height</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">600px</span></span><br></pre></td></tr></table></figure>
<p><strong>方案一：hexo-pdf插件（不推荐）</strong></p>
<p>通过搜索其他人搭建个人博客的经验，部分作者使用<code>hexo-pdf</code>插件用于显示pdf文件，尝试该方案。</p>
<ul>
<li><p>在博文根目录下安装插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install --save hexo-pdf</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>source</code>文件夹内创建pdf文件夹，在<code>.md</code>文档内插入以下语句。</p>
<p><strong>此方式在本地生成后弹出了IDM文件下载链接，未出现预览窗口，如下图。如果显示<code>Cannot GET /2025/06/04/Test.pdf</code>说明文件路径有问题</strong></p>
<p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">{% pdf  /pdf/Test.pdf %}</span><br></pre></td></tr></table></figure></p>
<div>
<center>
<img src="image-20250604091556759.png" alt="image can't load." style="zoom:75%"> <br> Fig.2 弹出下载界面，无预览
</center>
</div></li>
<li><p>尝试更改文件夹，在<code>_post</code>文件夹下创建与<code>.md</code>同名的文件夹
，在<code>.md</code>文档内插入以下两句语句。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">{% pdf ./Test.pdf %}</span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">{% pdf  Test.pdf %}</span><br></pre></td></tr></table></figure>
<p>结果与第2步放入<code>source</code>文件夹类似，本地预览弹出文件下载框，但是无法加载出内容。</p>
<p>该方案推送至Github后可正常浏览，效果如下：</p>
<div class="pdf-container" data-target="Test.pdf" data-height="400px"></div></li>
</ul>
<p><strong>缺点：该方案只能在部署到服务器后在PC端预览，手机端查看博文则会显示文件丢失。也无法在本地生成后查看效果。</strong></p>
<p><strong>方案二：PDF.js工具（推荐）</strong></p>
<p>有很多博主在个人博客使用这个pdf工具，但多数应用主题是butterfly或者fluid主题，博主希望尝试应用在next主题上，便于在手机与电脑端实现双端浏览。</p>
<ol type="1">
<li><p><a href="https://mozilla.github.io/pdf.js/getting_started/#download">下载PDF.js</a>工具包，博主选择下载modern
browsers v5.3.31版本，<a href="https://github.com/mozilla/pdf.js/tags">点击此处下载其他版本</a></p></li>
<li><p>在next主题，存放解压文件</p></li>
<li><p>在博客根目录的 <code>_config.yml</code>文件中设置，取消渲染</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">skip_render:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">pdfjs/**/*</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用以下代码插入pdf，其中<code>src</code>参量的<code>/pdfjs/web/viewer.html</code>为预览窗口，后面紧跟的<code>file=https://MicroPrism.github.io/2025/04/09/Hexo-Build_Blog/Test.pdf"</code>是Github上的文件路径。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">"/pdfjs/web/viewer.html?file=https://MicroPrism.github.io/2025/04/09/Hexo-Build_Blog/Test.pdf"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">width</span>=<span class="string">"80%"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">height</span>=<span class="string">"750"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">frameborder</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此种方式部署到Github之后出现404 File Not
Found的文件无法加载的错误，如下图：</p>
<div>
<center>
<img src="image-20250609113753049.png" alt="image can't load." style="zoom:50%"><!-- alt内为提示词--> <br> <!--换行--> Fig.3
404 File Not Found <!--标题-->
</center>
</div></li>
</ol>
<p>最初博主误认为是和大多数博主一样出现的文件<strong>跨域问题</strong>，但发现<code>https://MicroPrism.github.io/2025/04/09/Hexo-Build_Blog/Test.pdf</code>网页可以单独打开，因此推测可能是文件加载路径出错，也就是<code>viewer.html</code>路径出错。</p>
<p>查找原因时发现该路径被博主多写了一个
<code>pdfjs/pdfjs/..</code>，而正确路径需要和pdfjs的存储路径对应，应为
<code>pdfjs/web/viewer.html</code>，至此问题解决。</p>
<ol start="5" type="1">
<li><p>查看<code>viewer.html</code>源码，能看到PDF.js工具在4.0版本开始后引用了<code>pdf.mjs</code>和<code>viewer.mjs</code>两个资源文件，如下图：</p>
<div>
<center>
<img src="image-20250609120409051.png" alt="image can't load." style="zoom:50%"> <br> Fig.4 v5.3.31 viewer.html资源引用
</center>
</div></li>
</ol>
<p>在此之前的版本则使用<code>.js</code>资源文件，如下图：</p>
<div>
<center>
<img src="image-20250609164024819.png" alt="image can't load." style="zoom:50%"><!-- alt内为提示词--> <br> <!--换行-->
Fig.5 v3.11.174 viewer.html资源引用 <!--标题-->
</center>
</div>
<p>效果预览如下：</p>
<iframe src="/pdfjs/web/viewer.html?file=https://MicroPrism.github.io/2025/04/09/Hexo-Build_Blog/Test.pdf" width="80%" height="750" frameborder="0">
</iframe>
<ol start="6" type="1">
<li><p>打开<code>web/viewer.mjs</code>资源文件，更改以下两个配置值为
<code>true</code>：</p>
<figure class="highlight mjs"><table><tr><td class="code"><pre><span class="line"><span class="attr">disableAutoFetch</span>: {</span><br><span class="line">  <span class="attr">value</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">kind</span>: <span class="title class_">OptionKind</span>.<span class="property">API</span> + <span class="title class_">OptionKind</span>.<span class="property">PREFERENCE</span></span><br><span class="line">},</span><br><span class="line">  <span class="attr">disableStream</span>: {</span><br><span class="line">  <span class="attr">value</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">kind</span>: <span class="title class_">OptionKind</span>.<span class="property">API</span> + <span class="title class_">OptionKind</span>.<span class="property">PREFERENCE</span></span><br><span class="line">},</span><br></pre></td></tr></table></figure>
<p>该措施可以实现pdf文件的按需加载，提升观感与加载速度。</p></li>
</ol>
<blockquote>
<p>其他人的博客上有提到文件跨域导致的文件无法显示，但截止目前，博主没有遇到此问题，如果遇到，请参考第6条参考资料。</p>
</blockquote>
<p><strong>参考资料：</strong></p>
<ol type="1">
<li><a href="https://awesomeyouthzhang.github.io/2020/02/05/hexo%20%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8F%92%E5%85%A5pdf%E6%8F%92%E4%BB%B6/">hexo
中如何插入pdf | 智贤</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/550626417">hexo中插入PDF
|知乎</a></li>
<li><a href="https://www.poetyin.com/posts/4a17b156/">The Details Usage
of the Hexo Next-Theme Plugin <code>next-pdf</code> | Poetry
Continent</a></li>
<li><a href="https://jiqiren116.github.io/2024/03/24/hexo博客显示pdf/">hexo博客显示pdf
| robot-x Blog</a></li>
<li><a href="https://www.bilibili.com/opus/771629864647131138">Hexo内嵌PDF.js |
哔哩哔哩</a></li>
<li><a href="https://blog.csdn.net/weixin_44657449/article/details/119894091">pdf.js｜CSDN博客</a></li>
</ol>
<h2 id="github端推送错误fatal502">GitHub端推送错误(Fatal:502)</h2>
<p>博主在先前使用Hexo部署博文时，直接使用在git
bash中使用推送命令<code>$ hexo d</code>即可把当前的文档推送到服务器，并且在线查看。</p>
<p>而本次typora完成文档编辑后生成网页，本地端口预览正常，但部署至github时报错，大致报错信息如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">fatal: unable to access 'https://github.com/MicroPrism/MicroPrism.github.io.git/': The requested URL returned error: 502</span><br><span class="line">FATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: Spawn failed</span><br><span class="line"><span class="code">    at ChildProcess.&lt;anonymous&gt; (F:\Blog\MicroPrism\node_modules\hexo-deployer-git\node_modules\hexo-util\lib\spawn.js:51:21)</span></span><br><span class="line"><span class="code">    at ChildProcess.emit (node:events:518:28)</span></span><br><span class="line"><span class="code">    at cp.emit (F:\Blog\MicroPrism\node_modules\cross-spawn\lib\enoent.js:34:29)</span></span><br><span class="line"><span class="code">    at ChildProcess._handle.onexit (node:internal/child_process:293:12)</span></span><br></pre></td></tr></table></figure>
<p><strong>差异分析：</strong></p>
<ol type="1">
<li>相对于上一次博客推送，本次使用ios手机热点，运营商为中国联通，而上次连接单位的wifi</li>
<li>此次推送博文以html语法插入了图片(2026.01.03更新下方代码块已作废，请以
<a href="#公式渲染异常">公式渲染异常</a>一节内的为准)</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>			<span class="comment">&lt;!--块级封装--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">center</span>&gt;</span>	<span class="comment">&lt;!--将图片和文字居中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"dir-name/image-name.png"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">alt</span>=<span class="string">"image can't load."</span></span></span><br><span class="line"><span class="tag">         <span class="attr">style</span>=<span class="string">"zoom:75%"</span>/&gt;</span><span class="comment">&lt;!-- alt内为提示词--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span>		<span class="comment">&lt;!--换行--&gt;</span></span><br><span class="line">    title	<span class="comment">&lt;!--标题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>解决办法：</strong></p>
<p>在此优先将解决办法写在此处，为其他人提供参考。</p>
<ol type="1">
<li><p>根据报错信息，确认与服务器联通状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ping github.com</span><br></pre></td></tr></table></figure>
<p>能ping通说明不是github服务器问题。</p></li>
<li><p>尝试使用ssh访问github服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>如果能访问成功，说明本地密钥和github能匹配，连接异常不是密钥问题。连接正常时显示以下信息：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Hi repo-name! You've successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<p>3.更改推送时的repo。打开hexo根目录<code>_config.yml</code>文件，更改为下方样式，其中repo-name为自己的仓库名。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:repo-name/repo-name.github.io.git</span> <span class="comment">##更换为ssh推送</span></span><br><span class="line">  <span class="comment">#repo: https://github.com/repo-name/repo-name.github.io.git ##https推送</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>
<p>至此，问题解决，有兴趣的可以观察下方的问题分析。</p></li>
</ol>
<p><strong>问题分析：</strong></p>
<p>博主首先对问题最直观的定位是<strong>插入图片的语法不统一</strong>导致的异常。相对于大多数网友选择的直接插入的方案，比如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">image name</span>](<span class="link">image-path/image.png</span>)</span><br></pre></td></tr></table></figure>
<p>我选择使用html语法插入，这种语法有几个好处：</p>
<ol type="1">
<li>参数和提示信息更多。比如可以调节图片的位置，center、left、right。或者缩放比例，再或者是图片无法加载的提示信息。</li>
<li>可以加入对图片的解释，对于曲线类的图片，有题注说明会更清晰。</li>
<li>markdown和localhost都可以直接预览。</li>
</ol>
<p>随后到hexo官方查阅<a href="https://hexo.io/zh-cn/docs/troubleshooting">故障排除 |
Hexo</a>的资料，搜索关键词“somthing
wrong”定位到<strong>模型渲染错误</strong>一节，认为是语法错误，按其意见尝试修改，见下方第1点。同时在网络上搜索使用html语法插入图片的相关问题与解决方案，逐步查找原因：</p>
<ol type="1">
<li>在html语法段加上<code>{{}}</code>，仍然异常。</li>
<li>删除所有html语法，仍然异常。</li>
<li>删除 .md文件名的空格，仍然异常。</li>
</ol>
<p>到此，即可排除是文件名空格、中文字符解析、html语法兼容的问题。<span style="color:red"><strong>后来发现something
wrong是很笼统的错误提示，需要向前或向后找更详细的提示。</strong></span></p>
<p>考虑到hexo推送机制底层还是调用git工具，那么如果出现问题，作为hexo的子集，git应该能获得更多错误信息。果然搜索到类似的帖子，在此进行概括：</p>
<blockquote>
<p>错误代码502意味着网络问题，可能是服务器端关闭或者是访问端的网络波动。首先需要检查你的防火墙、代理、以及网关是否拦截了访问。</p>
</blockquote>
<p>从这段解释里引出了对场景变化的第二个考虑，<strong>网络变化-从单位的网络变为手机热点，可能是运营商拦截？</strong></p>
<p>但是本地却能ping通github。所以<strong>进一步考虑到是否是密钥过期，或者是电脑上的密钥被清理</strong>。（早期github曾使用过短期密钥，因为密钥过期导致无法推送）</p>
<p>随后建立新的密钥：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"you-email@emil.com"</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/lenovo/.ssh/id_rsa):</span><br></pre></td></tr></table></figure>
<p>回车保存在默认路径下，覆盖原有文件。使用下方指令copy密钥值粘贴到github端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>新建密钥之后将ssh连接的端口从默认22修改为不常被拦截的443端口，用记事本或者notepad等打开git安装目录下/etc/ssh/ssh_config文件，在末尾加入：</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    Hostname ssh.github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line">    Port 443</span><br></pre></td></tr></table></figure></p>
<p>重新使用ssh访问github，记得输入yes确认：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>截止到此，ssh访问应该不会出问题了。但是hexo部署仍然有问题，继续查找原因，发现ssh访问没问题的话，<strong>可能出在git端的配置上</strong>。</p>
<p>查找网络资料，发现git可以通过以下两条指令切换https、或者ssh协议：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote set-url origin https://github.com/repo-name/repo-name.github.io.git <span class="comment">##切换https协议</span></span><br><span class="line">$ git remote set-url origin git@github.com:repo-name/repo-name.github.io.git                </span><br></pre></td></tr></table></figure>
<p>类比思考，hexo是将协议集成在了配置文件
<code>_config.yml</code>内，如下方配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:repo-name/repo-name.github.io.git</span> <span class="comment">##更换为ssh推送</span></span><br><span class="line">  <span class="comment">#repo: https://github.com/repo-name/repo-name.github.io.git ##https推送</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>
<p>因此，将修改repo参数即可修改deploy时的协议，更换为ssh协议后即推送成功。</p>
<p><strong>参考资料：</strong></p>
<p>【1】<a href="https://hexo.io/zh-cn/docs/troubleshooting">故障排除 |
Hexo</a></p>
<p>【2】<a href="https://blog.xihann.top/2024/01/21/hexo-d报错及原因分析/">hexo
d报错及原因分析 | 惜寒のBlog~</a></p>
<p>【3】<a href="https://www.cnblogs.com/zolich/p/12906838.html#1-先看看本地有没有ssh密钥">GitHub使用SSH连接以及生成修改添加密钥详细过程
| zolich - 博客园</a></p>
<p>【4】<a href="https://stackoverflow.com/questions/44594353/the-requested-url-returned-error-502-corporate">The
requested URL returned error 502, corporate? | Stack overflow</a></p>
<p>【5】<a href="https://blog.csdn.net/2303_79611263/article/details/140346864">解决将Hexo部署到GitHub时报错：Error:
Spawn failed_hexo无法部署到github | CSDN博客</a></p>
<p>【6】<a href="https://blog.csdn.net/qq_33316784/article/details/104538400">git相互切换ssh和http协议(一看就懂版)_git
修改 ssh url | CSDN博客</a></p>
<h2 id="网页端公式渲染异常">网页端公式渲染异常</h2>
<p><strong>解决日期：2026.01.03</strong></p>
<p>此问题博主在最初并没有发现（<del>不是太久没写博客</del>），近期更新博客本地浏览时发现部分公式块以源代码形式显示，比如：
<span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.552ex;" xmlns="http://www.w3.org/2000/svg" width="16.959ex" height="4.855ex" role="img" focusable="false" viewbox="0 -1460 7496.1 2146"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mi" transform="translate(646,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(1398,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mfrac" transform="translate(2453.8,0)"><g data-mml-node="mrow" transform="translate(220,710)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(989,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(2176.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(3177,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(4213.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g><g data-mml-node="mn" transform="translate(2271.1,-686)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><rect width="4802.3" height="60" x="120" y="220"/></g></g></g></svg></mjx-container></span> 会显示为源码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">S<span class="emphasis">_n = \frac{n(a_</span>1+a<span class="emphasis">_n)}{2}</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure>
<p>先给出博主的解决方案，删除原有的渲染插件<code>hexo-renderer-marked</code>，下载新插件
<code>hexo-renderer-pandoc</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ winget install --<span class="built_in">source</span> winget --exact --<span class="built_in">id</span> JohnMacFarlane.Pandoc</span><br></pre></td></tr></table></figure>
<p>随后重启git bash窗口，更新环境变量和签名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看pandoc是否安装成功</span></span><br><span class="line">$ pandoc --<span class="built_in">help</span></span><br><span class="line">$ npm uninstall hexo-renderer-marked --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装开源渲染引擎MathJax</span></span><br><span class="line">$ npm install hexo-filter-mathjax --save</span><br><span class="line">$ npm list hexo-filter-mathjax</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装pandoc渲染器</span></span><br><span class="line">$ npm install hexo-renderer-pandoc --save</span><br><span class="line">$ npm list hexo-renderer-pandoc <span class="comment">#查看是否成功</span></span><br></pre></td></tr></table></figure>
<p>执行完以上指令序列，分别对hexo和next主题做如下配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo根目录_config.xml</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">none</span> <span class="comment"># or 'ams' or 'all'</span></span><br><span class="line">  <span class="attr">single_dollars:</span> <span class="literal">true</span> <span class="comment"># enable single dollar signs as in-line math delimiters</span></span><br><span class="line">  <span class="attr">cjk_width:</span> <span class="number">0.9</span> <span class="comment"># relative CJK char width</span></span><br><span class="line">  <span class="attr">normal_width:</span> <span class="number">0.6</span> <span class="comment"># relative normal (monospace) width</span></span><br><span class="line">  <span class="attr">append_css:</span> <span class="literal">true</span> <span class="comment"># add CSS to pages rendered by MathJax</span></span><br><span class="line">  <span class="attr">every_page:</span> <span class="literal">false</span> <span class="comment"># if true, every page will be rendered by MathJax regardless the `mathjax` setting in Front-matter</span></span><br><span class="line">  <span class="attr">packages:</span> <span class="comment"># extra packages to load</span></span><br><span class="line">  <span class="attr">extension_options:</span> {}</span><br><span class="line">    <span class="comment"># you can put your extension options here</span></span><br><span class="line">    <span class="comment"># see http://docs.mathjax.org/en/latest/options/input/tex.html#tex-extension-options for more detail</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># theme/next目录_config.xml</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="comment"># Default (false) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in front-matter.</span></span><br><span class="line">  <span class="comment"># If you set it to true, it will load mathjax / katex script EVERY PAGE.</span></span><br><span class="line">  <span class="attr">every_page:</span> <span class="literal">false</span>	<span class="comment">#取消每页都渲染，节省资源</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>	<span class="comment">#激活mathjax引擎</span></span><br><span class="line">    <span class="comment"># Available values: none | ams | all</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">none</span></span><br></pre></td></tr></table></figure>
<p>设计好.md文档后，在文档title添加以下选项，重新生成即可。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">mathjax: true</span><br></pre></td></tr></table></figure>
<p>或许会出警告，但并不影响显示效果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[WARNING] Could not convert TeX math  \gamma_{up} = \frac{Q_{up}}{\int_{t_0}^{t_1} P_{0}(t) dt} , rendering as TeX</span><br></pre></td></tr></table></figure>
<p><strong>此处更换渲染器后，博文内的图片显示异常，直接显示为原始html块代码。（<del>果然，当代码能动就不要改bug</del>）</strong></p>
<p>最终查出的原因是：html代码块使用<code>&lt;div&gt; &lt;/div&gt;</code>插入图片，在typora中加载无误。但pandoc渲染器或许自带一些bug(Github上的issue似乎到现在都没有解决)，注释、回车/空格似乎都会影响识别，影响渲染结果：
因此插入图片可复制以下模板：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"a blog directory name/image-2025040011.png"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">alt</span>=<span class="string">"image can't load."</span></span></span><br><span class="line"><span class="tag">         <span class="attr">style</span>=<span class="string">"zoom:75%"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">Microsoft Store</span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>尽量不要插入过多空格和注释。此处参阅以下两篇博文，可以配置pandoc渲染时的参数，但最终使用与否并无差异，因此保留备用。</p>
<ul>
<li><a href="https://pandoc.org/MANUAL.html#raw-htmltex">Pandoc - Pandoc
User’s Guide</a></li>
<li><a href="https://horizon86.github.io/2025/09/24/hexo的pandoc渲染器配置/">hexo的pandoc渲染器配置
- horizon86的博客</a></li>
</ul>
<p><strong>原因分析：</strong></p>
<p>博主的文档在本地使用Typora编辑器编写，可以实时渲染出图、出公式，方便好使。</p>
<p>查找网络资料后发现Markdown文档可以渲染latex公式，但只支持基本的符号/公式，hexo生成的html文件显示原始文本。其中，两者差异在于hexo默认使用hexo-math插件，而typora使用hexo-filter-mathjax（<a href="https://www.typora.net/1741.html">具体为Katex</a>），因此首先更换渲染引擎为mathjax。</p>
<p>其次遇到新问题，默认渲染器为<code>hexo-renderer-marked</code>，其功能不全：不支持emoji扩展、不支持mathjax插件扩展。参考网络资料，有以下两种选择：</p>
<ul>
<li><code>hexo-renderer-kramed</code></li>
<li><code>hexo-renderer-pandoc</code></li>
</ul>
<p>最初博主尝试kramed，但安装后需调整rule.js文件。参考<a href="https://blog.csdn.net/weixin_45511189/article/details/115798563">此博文</a>配置后，或许某处操作不正确，导致原有的公式渲染没解决，还出现新问题，上下角标不能使用，因此找到pandoc作为替代品。</p>
<p>pandoc依赖外部渲染引擎，需要下载安装单独的程序。但操作简单，渲染效果还不错，本文的解决方案主要参考<a href="https://blog.barku.re/2024/04/20/彻底解决-Hexo-的数学公式渲染问题/">Barkure</a>、<a href="https://www.cai-like.com/blog/2025/07/hexo-render-latex/">Like</a>两位的博文，对其方案做了融合，小白可用。</p>
<p><strong>参考资料：</strong></p>
<p>【1】<a href="https://blog.csdn.net/weixin_45511189/article/details/115798563">hexo博客next主题添加对数学公式的支持_hexo
next 公式-CSDN博客</a></p>
<p>【2】<a href="https://blog.barku.re/2024/04/20/彻底解决-Hexo-的数学公式渲染问题/">彻底解决
Hexo 的数学公式渲染问题 | Barkure</a></p>
<p>【3】<a href="https://blog.bere.top/Hexo-Next-博客-Markdown-数学公式完全指南/">Hexo
Next 博客 Markdown 数学公式完全指南 | 浩跃霖希的博客</a></p>
<p>【4】<a href="https://miustannis.github.io/2025/03/27/250327/">Hexo博客插入数学公式
| Miao’s Blog</a></p>
<p>【5】<a href="https://www.cai-like.com/blog/2025/07/hexo-render-latex/">render
latex in hexo blog | Like’s Blog</a></p>
<h1 id="使用技巧">使用技巧</h1>
<h2 id="博客分类">博客分类</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure>
<p>此时这篇文章同时包括三个分类： <code>PlayStation</code> 和
<code>Games</code> 分别都是父分类 <code>Diary</code> 的子分类，同时
<code>Life</code> 是一个没有子分类的分类。</p>
<h2 id="修改分类间隔符">修改分类间隔符</h2>
<p>如果希望保留多语言支持，可以修改翻译文件中的
<code>symbol.comma</code> 定义：</p>
<ol type="1">
<li><p>找到主题的语言文件（如中文）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">themes/next/languages/zh-CN.yml</span><br></pre></td></tr></table></figure></li>
<li><p>修改 <code>symbol.comma</code> 的值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">symbol:</span><br><span class="line">  comma: <span class="string">" / "</span>  <span class="comment"># 将逗号改为斜杠</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p><em>且视他人之疑目如盏盏鬼火，大胆地去走你的夜路。–史铁生
《病隙随笔》</em></p>
</blockquote>
]]></content>
      <categories>
        <category>工具类</category>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo博客</tag>
        <tag>常见问题</tag>
      </tags>
  </entry>
</search>
