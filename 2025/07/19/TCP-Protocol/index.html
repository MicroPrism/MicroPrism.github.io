<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="[object Object]">
<link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap" rel="stylesheet">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"microprism.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="本篇博文主要介绍TCP&#x2F;IP协议特性…。">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP&#x2F;IP-协议详解">
<meta property="og:url" content="https://microprism.github.io/2025/07/19/TCP-Protocol/index.html">
<meta property="og:site_name" content="Young&#39;s Blog">
<meta property="og:description" content="本篇博文主要介绍TCP&#x2F;IP协议特性…。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://microprism.github.io/2025/07/19/TCP-Protocol/build_link.jpg">
<meta property="og:image" content="https://microprism.github.io/2025/07/19/TCP-Protocol/image-20250720181903491.png">
<meta property="og:image" content="https://microprism.github.io/2025/07/19/TCP-Protocol/break_link.jpg">
<meta property="og:image" content="https://microprism.github.io/2025/07/19/TCP-Protocol/image-20250720215038251.png">
<meta property="og:image" content="https://microprism.github.io/2025/07/19/TCP-Protocol/osi.jpg">
<meta property="og:image" content="https://microprism.github.io/2025/07/19/TCP-Protocol/tcp_msg.jpg">
<meta property="og:image" content="https://microprism.github.io/2025/07/19/TCP-Protocol/image-20250720175218054.png">
<meta property="og:image" content="https://microprism.github.io/2025/07/19/TCP-Protocol/tcp_state_change.jpg">
<meta property="og:image" content="https://microprism.github.io/2025/07/19/TCP-Protocol/rcv_wnd.jpg">
<meta property="og:image" content="https://microprism.github.io/2025/07/19/TCP-Protocol/snd_wnd.jpg">
<meta property="og:image" content="https://microprism.github.io/2025/07/19/TCP-Protocol/tcp_cache_queue.jpg">
<meta property="article:published_time" content="2025-07-19T07:23:23.000Z">
<meta property="article:modified_time" content="2026-01-11T11:56:55.491Z">
<meta property="article:author" content="Youngs">
<meta property="article:tag" content="TCP&#x2F;IP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://microprism.github.io/2025/07/19/TCP-Protocol/build_link.jpg">


<link rel="canonical" href="https://microprism.github.io/2025/07/19/TCP-Protocol/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://microprism.github.io/2025/07/19/TCP-Protocol/","path":"2025/07/19/TCP-Protocol/","title":"TCP/IP-协议详解"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>TCP/IP-协议详解 | Young's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YXT2GQNX59"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-YXT2GQNX59","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js" defer></script>

  <script src="/js/third-party/analytics/baidu-analytics.js" defer></script>
  <script async src="https://hm.baidu.com/hm.js?e31b8387d0a02f9c3c7c74c21377751b"></script>







  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.3.1/pdfobject.min.js","integrity":"sha256-jI72I8ZLVflVOisZIOaLvRew3tyvzeu6aZXFm7P7dEo="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js" defer></script>




  <script src="/js/third-party/pace.js" defer></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/rss.xml" title="Young's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Young's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">不完全体攻城狮</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">23</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">18</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">25</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#osi%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">OSI模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#tcp%E5%8D%8F%E8%AE%AE%E7%89%B9%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text">TCP协议特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E7%A1%AE%E8%AE%A4%E4%B8%8E%E9%87%8D%E4%BC%A0"><span class="nav-number">2.1.</span> <span class="nav-text">连接、确认与重传</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">2.1.1.</span> <span class="nav-text">三次握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8Btcp%E5%BB%B6%E6%97%B6%E5%BA%94%E7%AD%94"><span class="nav-number">2.1.2.</span> <span class="nav-text">三次挥手?TCP延时应答</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%B2%E5%BE%A1%E6%80%A7%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.2.</span> <span class="nav-text">防御性设计</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#tcp%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">TCP报文结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#tcp%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81"><span class="nav-number">4.</span> <span class="nav-text">TCP连接状态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#tcp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">5.</span> <span class="nav-text">TCP数据结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#tcp%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">6.</span> <span class="nav-text">TCP滑动窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3"><span class="nav-number">6.1.</span> <span class="nav-text">接收窗口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3"><span class="nav-number">6.2.</span> <span class="nav-text">发送窗口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3"><span class="nav-number">6.3.</span> <span class="nav-text">糊涂窗口？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#tcp%E6%8A%A5%E6%96%87%E6%AE%B5"><span class="nav-number">7.</span> <span class="nav-text">TCP报文段</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BC%93%E5%86%B2%E9%98%9F%E5%88%97"><span class="nav-number">7.1.</span> <span class="nav-text">报文段缓冲队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%A5%E6%96%87%E6%AE%B5%E5%8F%91%E9%80%81"><span class="nav-number">7.2.</span> <span class="nav-text">报文段发送</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%A5%E6%96%87%E6%AE%B5%E6%8E%A5%E6%94%B6"><span class="nav-number">7.3.</span> <span class="nav-text">报文段接收</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">8.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Youngs"
      src="/images/walk.png">
  <p class="site-author-name" itemprop="name">Youngs</p>
  <div class="site-description" itemprop="description">我等采石之人，当怀大教堂之愿景~</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/MicroPrism" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;MicroPrism" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2632688012@qq.com" title="E-Mail → mailto:2632688012@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/405856572?spm_id_from=333.1369.0.0" title="BiliBili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;405856572?spm_id_from&#x3D;333.1369.0.0" rel="noopener me" target="_blank"><i class="fab fa-bilibili fa-fw"></i>BiliBili</a>
      </span>
      <span class="links-of-author-item">
        <a href="/rss.xml" title="RSS → &#x2F;rss.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://csdiy.wiki/" title="https:&#x2F;&#x2F;csdiy.wiki&#x2F;" rel="noopener" target="_blank">CS自学指南</a>
            </li>
        </ul>
      </div>
    </div>

    
      <script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
      <script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
      <div class="widget-wrap">
        <h3 class="widget-title">Tags</h3>
        <div id="myCanvasContainer" class="widget tagcloud">
            <canvas width="250" height="250" id="resCanvas" style="width:100%">
                <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/873%E6%8E%A7%E5%88%B6%E5%B7%A5%E7%A8%8B/" rel="tag">873控制工程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Altium-Designer/" rel="tag">Altium Designer</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FPGA/" rel="tag">FPGA</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo%E5%8D%9A%E5%AE%A2/" rel="tag">Hexo博客</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PCB/" rel="tag">PCB</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpaceDesk/" rel="tag">SpaceDesk</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/" rel="tag">TCP&#x2F;IP</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Verilog/" rel="tag">Verilog</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ZYNQ/" rel="tag">ZYNQ</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7/" rel="tag">信号完整性</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%AF%E5%B1%8F%E6%89%A9%E5%B1%95/" rel="tag">副屏扩展</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%97%E6%98%8C%E5%A4%A7%E5%AD%A6/" rel="tag">南昌大学</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" rel="tag">常见问题</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88/" rel="tag">栈</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%81%E9%87%8F%E5%8D%A1/" rel="tag">流量卡</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%B9%E6%80%A7%E9%98%BB%E6%8A%97/" rel="tag">特性阻抗</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" rel="tag">线性表</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E5%8A%A8%E5%8D%8F%E5%95%86/" rel="tag">自动协商</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a><span class="tag-list-count">1</span></li></ul>
            </canvas>
        </div>
      </div>
    


  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://microprism.github.io/2025/07/19/TCP-Protocol/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/walk.png">
      <meta itemprop="name" content="Youngs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Young's Blog">
      <meta itemprop="description" content="我等采石之人，当怀大教堂之愿景~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="TCP/IP-协议详解 | Young's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          TCP/IP-协议详解
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    
    
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-07-19 15:23:23" itemprop="dateCreated datePublished" datetime="2025-07-19T15:23:23+08:00">2025-07-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2026-01-11 19:56:55" itemprop="dateModified" datetime="2026-01-11T19:56:55+08:00">2026-01-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%8D%8F%E8%AE%AE%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">协议类</span></a>
        </span>
          /
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%8D%8F%E8%AE%AE%E7%B1%BB/TCP-IP/" itemprop="url" rel="index"><span itemprop="name">TCP/IP</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>26 分钟</span>
    </span>



</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>本篇博文主要介绍TCP/IP协议特性…。</p>
<span id="more"></span>
<h1 id="osi模型">OSI模型</h1>
<p>TCP/IP协议族常用的应用层协议包括：</p>
<ul>
<li>HTTP(Hyper Text Transfer
Protocol)：超文本传输协议，<客户端-服务端>形式。<span style="color:red"><strong>属于单向同步协议，耗费资源多，不适合实时控制场合。</strong></span></客户端-服务端></li>
<li>FTP(File Transfer
Protocl):文件传输协议，多个设备间共享文件，如文件上传/下载、目录操作、权限设置等。</li>
<li>MQTT(Messege Queue Telemerty
Transport):消息队列遥测传输，用于推送消息，实时聊天等。</li>
</ul>
<p>按照OSI模型，TCP/IP协议被分为7层：物理层、网络层、链路层、传输层、会话层、表示层。<strong>但实际使用时常用5层表示，由下至上分别为：</strong></p>
<ul>
<li><strong>物理层: PHY</strong></li>
<li><strong>链路层: MAC</strong></li>
<li><strong>网络层: IP、ICMP、ARP</strong></li>
<li><strong>传输层: TCP、UDP</strong></li>
<li><strong>应用层: DNS、HTTP、FTP、SMTP</strong></li>
</ul>
<h1 id="tcp协议特性">TCP协议特性</h1>
<p><strong>TCP是采用数据流形式传输的全双工通信方式，传输过程中，发送方将数据起始编号与长度放在TCP报文中，接收方将所有数据按编号拼接后返回确认，传输双方的数据标号互相独立。</strong></p>
<h2 id="连接确认与重传">连接、确认与重传</h2>
<p>TCP是面向连接的协议，传输前必须有双方IP地址与端口号进行连接验证。传输中接收方在收到数据后必须返回确认结果，否则超时未确认后发送方认为发送失败，进行数据重传。由于IP层是无连接的。数据和确认都可能丢失，因此发送端在超时还未收到确认时进行重传。</p>
<blockquote>
<p>类似于IIC或者CAN协议穿插在数据流中的应答位，TCP为附在其他报文中的确认机制</p>
</blockquote>
<p>TCP协议连接包括传输层与应用层的连接，每个主机有IP的主机可以提供不同Web、FTP、SMTP等不同线程，通过不同端口来实现线程区分。</p>
<blockquote>
<p>类似RTOS中多个任务有各自独特的TCB</p>
</blockquote>
<ul>
<li>20/21：FTP，文件传输协议</li>
<li>23：Telnet，远程登录终端协议</li>
<li>25：SMTP，简单邮件传输协议</li>
<li>69：TFTP，普通文件传输协议</li>
<li>80：HTTP，超文本传输协议</li>
<li>110：POP3，邮局协议版本3</li>
</ul>
<h3 id="三次握手">三次握手</h3>
<p>两个主机连接以后，由客户端A建立连接。A首先向B发送空包，通过3个包判断A、B两端的seqno和ackno序号是否一致判断是否连接成功。过程如下：</p>
<ol type="1">
<li><p>A向B发序号，B收到并将其+1作为应答序号，回送给A;</p>
<p>====&gt; B知晓A-&gt;B连通</p></li>
<li><p>A判断B发送的应答序号，同时将B的序号+1作为应答序号，回送给B；</p>
<p>A的seqno = B的ackno ====&gt; A知晓A-&gt;B、B-&gt;A连通</p></li>
<li><p>B收到A的应答序号；</p>
<p>A的ackno = B的seqno ====&gt; B知晓B-&gt;A联通</p></li>
</ol>
<p>同时引入SYN同步头标志与ACK应答标志，附加自己窗口大小(用于流量控制)，得流程简图如下：</p>
<div>
<center>
<img src="build_link.jpg" alt="image can't load." style="zoom:100%"> <br> TCP三次握手<!--标题-->
</center>
</div>
实际抓包结果如下:
<div>
<center>
<img src="image-20250720181903491.png" alt="image can't load." style="zoom:60%"> <br> Wireshrak三次握手抓包
</center>
</div>
<ol type="1">
<li>PC-&gt;ZYNQ: SYN = 1，发起同步；seqno = ..0698</li>
<li>ZYNQ-&gt;PC: SYN = 1，发起同步；ACK = 1，应答上一报文； seqno =
16326，ackno = seqno + 1 = ..00699；</li>
<li>PC-&gt;ZYNQ: SYN = 0，同步结束；ACK = 1，应答上一报文； seqno =
..00699，ackno = seqno + 1 = 16327；</li>
</ol>
<p>执行无误后即同步完成，双方建立连接。</p>
<p>###　四次挥手</p>
<p>通常来说，TCP协议断开时是四次挥手，分别断开两个主机间的两条信号通路。大致过程如下：</p>
<ul>
<li><p>C向D发送断开连接报文，D接收并应答</p>
<p>====&gt; D端知晓C端主动断开发送的请求</p></li>
<li><p>C收到D端应答</p>
<p>====&gt; 断开C-&gt;D的报文发送流向</p></li>
<li><p>D向C发送断开连接报文，C接收并应答</p>
<p>====&gt; C端知晓D端主动断开发送的请求</p></li>
<li><p>D收到C端应答</p>
<p>====&gt; 断开D-&gt;C的报文流向</p></li>
</ul>
<p>类似SYN同步头，引入FIN标志作为中止连接表示。</p>
<div>
<center>
<img src="break_link.jpg" alt="image can't load." style="zoom:100%"> <br> TCP四次挥手
</center>
</div>
<p><strong>为什么是四次挥手？</strong></p>
<p>下方小节提到，TCP通信双方均会设置一个缓存区，例如本例中PC端为65535、ZYNQ端为2048。有可能ZYNQ在主动断开连接后PC端的数据尚未完全发送，仍然有PC-&gt;ZYNQ方向的报文帧，ZYNQ停止发送但仍保持接收。直到PC端数据发送完成，PC主动断开连接，ZYNQ发送应答。共计4次。</p>
<h3 id="三次挥手tcp延时应答">三次挥手?TCP延时应答</h3>
<p>在实际测试过程中PC端断开TCP连接只发现3次挥手？似乎与常说的4次不符合，如下图。</p>
<div>
<center>
<img src="image-20250720215038251.png" alt="image can't load." style="zoom:75%"> <br> TCP三次挥手
</center>
</div>
<p>查阅TCP协议标准参考文档<a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/rfc793">RFC 793</a>第3.5节有关Close
Connection的说明，其介绍了3种情况:</p>
<blockquote>
<p>There are essentially three cases: 1) The user initiates by telling
the TCP to CLOSE the connection 2) The remote TCP initiates by sending a
FIN control signal 3) Both users CLOSE simultaneously</p>
</blockquote>
<p>无论是单端关闭TCP还是双端同时关闭，均与实测结果不同。但网络上能查找到类似现象的解析，例如<a target="_blank" rel="noopener" href="https://zorrozou.github.io/docs/tcp/wavehand/TCP_Wavehand.html">参考资料5</a>中对Linux下的源码进行分析，其中提到了<strong>延时应答机制</strong>。所以LwIP协议栈应当有类似的措施或解决办法，查阅<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lizhuming/p/17438743.html">参考资料6</a>中对LwIP的源码分析。</p>
<p>找到<code>tcp.c</code>文件中的<code>tcp_fasttmr()</code>函数：该函数用于每250ms处理被应用层拒绝的数据并且发送延时应答。</p>
<blockquote>
<p>Is called every TCP_FAST_INTERVAL (250 ms) and process data
previously “refused” by upper layer (application) and sends delayed
ACKs.</p>
</blockquote>
<p>其中有以下代码段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pcb-&gt;flags &amp; TF_ACK_DELAY) <span class="comment">//到达延迟时间</span></span><br><span class="line">&#123;</span><br><span class="line">    LWIP_DEBUGF(TCP_DEBUG, (<span class="string">&quot;tcp_fasttmr: delayed ACK\n&quot;</span>));</span><br><span class="line">    tcp_ack_now(pcb);</span><br><span class="line">    tcp_output(pcb);</span><br><span class="line">    pcb-&gt;flags &amp;= ~(TF_ACK_DELAY | TF_ACK_NOW); <span class="comment">//ACK复位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即在每250ms时刻调用<code>tcp_ack_now(pcb)</code>函数使能立即发送延时ACK，并使用对外输出函数<code>tcp_output()</code>向外输出。函数<code>tcp_output()</code>中定义了延时ACK的处理方式：</p>
<ul>
<li><strong>如果TF_ACK_NOW使能且没有数据待发送，则组一个空的ACK报文立即发送</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If the TF_ACK_NOW flag is set and no data will be sent (either</span></span><br><span class="line"><span class="comment"> * because the -&gt;unsent queue is empty or because the window does</span></span><br><span class="line"><span class="comment"> * not allow it), construct an empty ACK segment and send it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If data is to be sent, we will just piggyback the ACK (see below).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (pcb-&gt;flags &amp; TF_ACK_NOW &amp;&amp;</span><br><span class="line">   (seg == <span class="literal">NULL</span> ||</span><br><span class="line">    lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len &gt; wnd)) &#123;</span><br><span class="line">   <span class="keyword">return</span> tcp_send_empty_ack(pcb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="防御性设计">防御性设计</h2>
<ul>
<li><p>缓存</p>
<p>由于发送方的数据大小、类型不定，TCP提供缓存机制处理数据。<strong>数据量过小时，TCP将数据存储在缓存中，等到数据量够大时发送，待接收方应答后再删除(便于无应答时重传)</strong>。</p>
<blockquote>
<p>​ 类似于CAN短帧以8字节为单位发送</p>
</blockquote></li>
<li><p>流量控制</p>
<p><strong>两种控制方式本质是希望匹配收发双方和中间路由的传输速度。</strong>TCP
提供了流量控制服务（flow-control
service）以消除发送方使接收方缓冲区溢出的可能性。</p>
<p><strong>流量控制是速度匹配，用于匹配收发双方读写速率。</strong>TCP
通过让发送方维护一个称为接收窗口（receive
window）的变量来提供流量控制，用于给发送方指示：接收方还能接收多少数据，接收方会将此窗口值放在TCP
报文的首部中的窗口字段传递给发送方，窗口大小是在发送数据时动态调整的。</p>
<blockquote>
<p>如果接收方窗口为0，则发送方发送只有1个字节的报文段，直到缓存清空并在确认报文中包含一个非0的接收窗口值。</p>
</blockquote>
<p><strong>在确定接收方窗口值之后，发送方可动态调整窗口大小对外发送数据。</strong></p>
<blockquote>
<p>滑动窗口思路</p>
</blockquote></li>
<li><p>拥塞控制</p>
<p>如果两个千兆主机之间经过百兆路由，即便双方主机均有能力处理500Mbps的数据，但仍收到路由的限制，因此发送方需要实现自适应机制，对发送方成为拥塞机制。<strong>流量控制限制单次通信数据量，拥塞控制协调设备间速率。</strong></p></li>
<li><p>差错控制</p>
<p>或者说是校验机制。<strong>TCP协议采用校验和进行校验，主机接收时丢弃重复报文、重组乱序报文、请求重发丢失报文。</strong></p></li>
</ul>
<h1 id="tcp报文结构">TCP报文结构</h1>
<p>TCP是基于字节流方式的传输，各个协议层之间数据传输均会增删各层的数据头：</p>
<div>
<center>
<img src="osi.jpg" alt="image can't load." style="zoom:75%"> <br> TCP/IP协议栈报文封装
</center>
</div>
<p>在LwIP协议栈中<code>lwip-2.0.2/src/include/lwip/port/tcp.h</code>中，<code>tcp_hdr</code>定义TCP报文帧的组成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_hdr</span> &#123;</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u16_t</span> src);	<span class="comment">/* 源端口 */</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u16_t</span> dest);<span class="comment">/* 目标端口 */</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u32_t</span> seqno);<span class="comment">/* 序号 */</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u32_t</span> ackno);<span class="comment">/* 确认序号 */</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u16_t</span> _hdrlen_rsvd_flags);<span class="comment">/* 首部长度+保留位+标志 */</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u16_t</span> wnd);<span class="comment">/* 窗口大小 */</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u16_t</span> chksum);<span class="comment">/* 校验和 */</span></span><br><span class="line">  PACK_STRUCT_FIELD(<span class="type">u16_t</span> urgp); <span class="comment">/* 紧急指针 */</span></span><br><span class="line">&#125; PACK_STRUCT_STRUCT;</span><br></pre></td></tr></table></figure>
<p>可以与下方的TCP报文结构对应：</p>
<div>
<center>
<img src="tcp_msg.jpg" alt="image can't load." style="zoom:100%"> <br> TCP报文
</center>
</div>
<ul>
<li>src、dst：源端、目标端的端口</li>
<li>seqno：发送端起始字节位置码，方便对数据进行管理</li>
<li>ackno：上次已成功收到数据的最后一个字节序号+1，ACK=1时有效。<strong>ackno通常会封装在反向数据报文中。</strong></li>
<li>wnd：窗口大小。起始端配置seqno确定发送字节数，实现流量控制。接收方返回wnd=0时，发送端停止发送。</li>
<li>chksum：校验值。覆盖TCP所有数据。</li>
<li>urgp：紧急指针。相对于seqno的正偏移量，表示前urgp个数据为紧急数据。</li>
</ul>
<p>标志位说明：</p>
<ul>
<li><p>hdrlen：首部字节数，4bit，单位为字。最大60Byte。</p></li>
<li><p>rsvd：保留值</p></li>
<li><p>URG：urgp使能</p></li>
<li><p>ACK：ackno使能</p></li>
<li><p>PSH：push使能。=1时尽快将报文端推送给应用层</p></li>
<li><p>RST：复位tcp连接</p></li>
<li><p>SYN：首次建立新连接时，SYN=1，序号字段包含主机随机的初始序号ISN。该主机发送数据的第一个字节序号为ISN+1。</p></li>
<li><p>FIN：中止连接</p></li>
</ul>
<blockquote>
<p>与CAN类似，源节点+目标节点+应答+数据+校验，但多了窗口值、序号、应答序号、紧急指针。CAN可以8Byte为单帧进行收发。</p>
</blockquote>
<p>PC与ZYNQ建立连接时首次的“握手”的帧为例：</p>
<div>
<center>
<img src="image-20250720175218054.png" alt="image can't load." style="zoom:60%"> <br> PC建立连接
</center>
</div>
<ul>
<li>src: 61816</li>
<li>dst: 7</li>
<li>seqno: ..1677</li>
<li>ackno: 0</li>
<li>hdrlen: 32</li>
<li>SYN: 1</li>
<li>wnd: 65535</li>
<li>chksum: 0x7407</li>
<li>urgp: 0</li>
</ul>
<h1 id="tcp连接状态">TCP连接状态</h1>
<p>LwIP协议中，<code>lwip-2.0.2/src/core/tcp.c</code>文件内定义了TCP协议中11种状态。</p>
<p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 限制初始报文发送段最大长度为536B，后续可在SYN连接里动态修改. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_MSS &gt; 536</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INITIAL_MSS 536</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INITIAL_MSS TCP_MSS</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* 11种连接状态 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> tcp_state_str[] = &#123;</span><br><span class="line">  <span class="string">&quot;CLOSED&quot;</span>,			<span class="comment">//关闭状态-无连接</span></span><br><span class="line">  <span class="string">&quot;LISTEN&quot;</span>,			<span class="comment">//监听态</span></span><br><span class="line">  <span class="string">&quot;SYN_SENT&quot;</span>,		<span class="comment">//发起SYN</span></span><br><span class="line">  <span class="string">&quot;SYN_RCVD&quot;</span>,		<span class="comment">//收到SYN</span></span><br><span class="line">  <span class="string">&quot;ESTABLISHED&quot;</span>, 	<span class="comment">//稳定连接</span></span><br><span class="line">  <span class="string">&quot;FIN_WAIT_1&quot;</span>,		<span class="comment">//单向终止</span></span><br><span class="line">  <span class="string">&quot;FIN_WAIT_2&quot;</span>,		<span class="comment">//对方应答终止</span></span><br><span class="line">  <span class="string">&quot;CLOSE_WAIT&quot;</span>,		<span class="comment">//等待终止</span></span><br><span class="line">  <span class="string">&quot;CLOSING&quot;</span>,		<span class="comment">//两端同时关闭</span></span><br><span class="line">  <span class="string">&quot;LAST_ACK&quot;</span>,		<span class="comment">//服务器等待对方关闭</span></span><br><span class="line">  <span class="string">&quot;TIME_WAIT&quot;</span>		<span class="comment">//关闭成功-2MSL等待状态</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>由于TCP为全双工通信，客户端与服务端的行为基本一致，通过以下流程图介绍客户端与服务器的状态变迁，其中，蓝色实线与红色实线是序号对应，可以组成一次完整的连接过程。红色虚线则表示特殊情况，即客户端与服务器同时发送SYN，使得客户端进入TCP_RSVD状态，如果此时：
+ 收到ACK，进入ESTABLISHED + 收到RST，恢复LISTEN +
内存不足导致客户端进程结束，或服务端ACK应答超时，进入FIN_WAIT_1</p>
<div>
<center>
<img src="tcp_state_change.jpg" alt="image can't load." style="zoom:60%"> <br> TCP状态切换
</center>
</div>
<h1 id="tcp数据结构">TCP数据结构</h1>
<p>类比FreeRTOS任务的任务控制块TCB，LwIP中有同样的协议控制块PCB：</p>
<p>IP块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IP_PCB \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* ip addresses in network byte order */</span> \</span></span><br><span class="line"><span class="meta">  ip_addr_t local_ip; \</span></span><br><span class="line"><span class="meta">  ip_addr_t remote_ip; \</span></span><br><span class="line"><span class="meta">   <span class="comment">/* Socket options */</span>  \</span></span><br><span class="line"><span class="meta">  u8_t so_options;      \</span></span><br><span class="line"><span class="meta">   <span class="comment">/* Type Of Service */</span> \</span></span><br><span class="line"><span class="meta">  u8_t tos;              \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* Time To Live */</span>     \</span></span><br><span class="line"><span class="meta">  u8_t ttl               \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* link layer address resolution hint */</span> \</span></span><br><span class="line"><span class="meta">  IP_PCB_ADDRHINT</span></span><br></pre></td></tr></table></figure>
<p>本地端口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* members common to struct tcp_pcb and struct tcp_listen_pcb */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_PCB_COMMON(type) \</span></span><br><span class="line"><span class="meta">  type *next; <span class="comment">/* for the linked list */</span> \</span></span><br><span class="line"><span class="meta">  void *callback_arg; \</span></span><br><span class="line"><span class="meta">  enum tcp_state state; <span class="comment">/* TCP state */</span> \</span></span><br><span class="line"><span class="meta">  u8_t prio; \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* ports are in host byte order */</span> \</span></span><br><span class="line"><span class="meta">  u16_t local_port</span></span><br></pre></td></tr></table></figure>
<p>TCP协议控制块定义(部分)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** TCP protocol control block */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> &#123;</span></span><br><span class="line"><span class="comment">/** 通用PCB成员 */</span></span><br><span class="line">  IP_PCB;</span><br><span class="line"><span class="comment">/** 特定PCB成员 */</span></span><br><span class="line">  TCP_PCB_COMMON(<span class="keyword">struct</span> tcp_pcb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 服务端口号 */</span></span><br><span class="line">  <span class="type">u16_t</span> remote_port;</span><br><span class="line">	...</span><br><span class="line">  <span class="comment">/* the rest of the fields are in host byte order</span></span><br><span class="line"><span class="comment">     as we have to do some math with them */</span></span><br><span class="line">  <span class="comment">/* Timers */</span></span><br><span class="line">  <span class="type">u8_t</span> polltmr, pollinterval;</span><br><span class="line">  <span class="type">u8_t</span> last_timer; <span class="comment">/* 控制块最后一次被处理的时间 */</span></span><br><span class="line">  <span class="type">u32_t</span> tmr;</span><br><span class="line">  <span class="comment">/* receiver variables */</span></span><br><span class="line">  <span class="type">u32_t</span> rcv_nxt;   <span class="comment">/* 下一次期望收到的seqno */</span></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> rcv_wnd;   <span class="comment">/* 接收窗口大小 */</span></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> rcv_ann_wnd; <span class="comment">/* 告知对方的接收窗大小 */</span></span><br><span class="line">  <span class="type">u32_t</span> rcv_ann_right_edge; <span class="comment">/* 通知窗口右边缘 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Retransmission timer. */</span></span><br><span class="line">  <span class="type">s16_t</span> rtime;</span><br><span class="line">  <span class="type">u16_t</span> mss;   <span class="comment">/* maximum segment size */</span></span><br><span class="line">	....</span><br><span class="line">  <span class="comment">/* fast retransmit/recovery */</span></span><br><span class="line">  <span class="type">u8_t</span> dupacks;	<span class="comment">/* 快速重传 */</span></span><br><span class="line">  <span class="type">u32_t</span> lastack;<span class="comment">/* 最近一次确认序号 */</span> <span class="comment">/* Highest acknowledged seqno. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* congestion avoidance/control variables */</span></span><br><span class="line">  <span class="comment">/* 避免拥塞/流量控制 */</span></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> cwnd;		<span class="comment">/* 连接当前的窗口大小*/</span></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> ssthresh;	<span class="comment">/* 拥塞避免算法启动的阈值 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* sender variables */</span> <span class="comment">/* 发送方变量 */</span></span><br><span class="line">  <span class="type">u32_t</span> snd_nxt;   <span class="comment">/* next new seqno to be sent */</span></span><br><span class="line">  <span class="type">u32_t</span> snd_wl1, snd_wl2; <span class="comment">/* Sequence and acknowledgement numbers of last</span></span><br><span class="line"><span class="comment">                             window update. */</span></span><br><span class="line">  <span class="type">u32_t</span> snd_lbb;       <span class="comment">/* Sequence number of next byte to be buffered. */</span></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> snd_wnd;   <span class="comment">/* sender window */</span></span><br><span class="line">  <span class="type">tcpwnd_size_t</span> snd_wnd_max; <span class="comment">/* the maximum sender window announced by the remote host */</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="comment">/* 保持空闲的控制变量 */</span></span><br><span class="line">  <span class="comment">/* idle time before KEEPALIVE is sent */</span></span><br><span class="line">  <span class="type">u32_t</span> keep_idle;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_TCP_KEEPALIVE</span></span><br><span class="line">  <span class="type">u32_t</span> keep_intvl;</span><br><span class="line">  <span class="type">u32_t</span> keep_cnt;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_TCP_KEEPALIVE */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Persist timer counter */</span></span><br><span class="line">  <span class="type">u8_t</span> persist_cnt;</span><br><span class="line">  <span class="comment">/* Persist timer back-off */</span></span><br><span class="line">  <span class="type">u8_t</span> persist_backoff;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* KEEPALIVE counter */</span> <span class="comment">/* 保活报文的发送次数 */</span></span><br><span class="line">  <span class="type">u8_t</span> keep_cnt_sent;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_WND_SCALE</span></span><br><span class="line">  <span class="type">u8_t</span> snd_scale;</span><br><span class="line">  <span class="type">u8_t</span> rcv_scale;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在两个ip的设备建立连接前，设备处于LISTEN监听态而非ESTABLISHED连接态，LwIP为节省资源定义了<code>tcp_pcb_listen</code>控制块，其中仅保留通用pcb块，在建立连接后将<code>tcp_pcb_listen</code>接入<code>tcp_pcb</code>即可。<code>tcp_pcb_listen</code>块定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** the TCP protocol control block for listening pcbs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb_listen</span> &#123;</span></span><br><span class="line"><span class="comment">/** Common members of all PCB types */</span></span><br><span class="line">  IP_PCB;</span><br><span class="line"><span class="comment">/** Protocol specific PCB members */</span></span><br><span class="line">  TCP_PCB_COMMON(<span class="keyword">struct</span> tcp_pcb_listen);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_CALLBACK_API</span></span><br><span class="line">  <span class="comment">/* Function to call when a listener has been connected. */</span></span><br><span class="line">  tcp_accept_fn accept;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LWIP_CALLBACK_API */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_LISTEN_BACKLOG</span></span><br><span class="line">  <span class="type">u8_t</span> backlog;</span><br><span class="line">  <span class="type">u8_t</span> accepts_pending;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_LISTEN_BACKLOG */</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>LwIP中管理各个PCB的链表如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The TCP PCB lists. */</span></span><br><span class="line"><span class="comment">/** List of all TCP PCBs bound but not yet (connected || listening) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">tcp_bound_pcbs</span>;</span></span><br><span class="line"><span class="comment">/** List of all TCP PCBs in LISTEN state */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">tcp_listen_pcbs_t</span> <span class="title">tcp_listen_pcbs</span>;</span></span><br><span class="line"><span class="comment">/** List of all TCP PCBs that are in a state in which</span></span><br><span class="line"><span class="comment"> * they accept or send data. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">tcp_active_pcbs</span>;</span></span><br><span class="line"><span class="comment">/** List of all TCP PCBs in TIME-WAIT state */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">tcp_tw_pcbs</span>;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>无连接时，<code>tcp_bound_pcbs</code>管理；</li>
<li>处于监听态时，<code>tcp_listen_pcbs</code>管理；</li>
<li>其他状态，<code>tcp_active_pcbs</code>管理；</li>
<li>Time-Wait态，<code>tcp_tw_pcbs</code>管理，主动关闭连接后进入；</li>
</ul>
<blockquote>
<p>同样类比FreeRTOS任务管理，阻塞态、就绪态、运行态、挂起态分别使用不同的链表控制，基本能按顺序一一对应。</p>
</blockquote>
<h1 id="tcp滑动窗口">TCP滑动窗口</h1>
<p>TCP是基于字节流的传输方式，每字节都有对应的seq号，窗口则是能发送/接收的segment字段。包括发送方窗口、接收方窗口，目的是利用收发双方的字节序号进行缓存区数据收发的流量控制与重传，设计上是一个滑动窗口。</p>
<h2 id="接收窗口">接收窗口</h2>
<div>
<center>
<img src="rcv_wnd.jpg" alt="image can't load." style="zoom:100%"> <br> TCP接收窗
</center>
</div>
<p>LwIP中关于接收窗的几个变量：</p>
<ul>
<li>rcv_wnd：received window，接收窗大小</li>
<li>rcv_ann_wnd：received annonce window，通知发送方接收窗大小</li>
<li>rcv_nxt：下次期望收到的seqno</li>
<li>rcv_ann_right_edge：通知发送方的窗口右边界</li>
</ul>
<p>收到对端数据后，接收窗口会减小；应用层读走数据后接收窗口会增加。但是窗口的每次增减并不总是会告知对方。</p>
<h2 id="发送窗口">发送窗口</h2>
<div>
<center>
<img src="snd_wnd.jpg" alt="image can't load." style="zoom:100%"> <br> TCP发送窗
</center>
</div>
<p>LwIP中关于发送窗的几个变量：</p>
<ul>
<li>lastack：接收方应答回来的seq序号</li>
<li>snd_wnd：发送方窗口大小</li>
<li>snd_nxt：待发送的下一字节的seq</li>
<li>snd_lbb：load byte to buffer，装载到缓冲区的下一字节seq</li>
</ul>
<p><strong>发送窗口会存在“飞行数据”的情况，即发送端已发送，但未收到确认/应答。<span style="color:red">此时发送窗并不会做出其他操作，直到收到接收方的ackno，随后更新lastack、snd_wnd、snd_nxt、snd_lbb等变量。</span></strong></p>
<h2 id="糊涂窗口">糊涂窗口？</h2>
<p>TCP的窗口采用动态刷新的滑动窗口机制，变量的更改不仅与己方有关，也需要对端的ackno。那么假设一种可能：</p>
<ol type="1">
<li>rcv端窗口接收后应用层一直未读取，直到rcv_wnd与rcv_ann_wnd缩小至20B</li>
<li>snd端收到rcv应答，snd_wnd设为20B，随后发送20B报文</li>
<li>rcv端应用层收到20B，rcv_wnd变为0，向snd应答</li>
<li>rcv端应用层读取20B，随后重复1-4。</li>
</ol>
<p><strong>简单说，当rcv端通告小窗，snd端立即填充小窗，应用层继续读取少量数据，则会出现糊涂窗口综合征SWS
(Silly WindowSyndrome)
。</strong>这种状况将导致大量TCP报文帧只有少量(20B)有效数据，而大量的小包会降低网络利用率甚至造成网络拥塞，降低网络性能。</p>
<p>产生原因有两个：</p>
<ul>
<li>接收端通告较小的rcv_wnd</li>
<li>发送端收到较小的rcv_wnd时，立即响应发出对应小包。</li>
</ul>
<p>按照RFC1122协议，避免SWS的措施：</p>
<ul>
<li><p>对于接收端要避免通告小窗口</p>
<p>避免以小的增量来推进接收窗的右边沿(rcv_nxt+rcv_wnd)，即使接收的数据包都是小包。只有当接收窗口的增量大于min(
Fr * rcv_buff, snd_mss
)的时候才通告新的窗口。其中Fr是一个分数因子，协议建议值为1/2，snd_mss为对端的发送最大段长。</p></li>
<li><p>对于发送端来说在不超出对端接收窗口的前提下至少满足下列三个条件中的一个才能发送数据：</p>
<ol type="1">
<li>一个full-sized的数据包(即大小满足snd_mss)可以被发送；</li>
<li>数据包的大小超过对端曾经通告过的rcv_ann_wnd的一半；</li>
<li>TCP发送端禁用了Nagle算法；</li>
<li>所有发出的数据都已经被对端ACK确认；</li>
</ol></li>
</ul>
<h1 id="tcp报文段">TCP报文段</h1>
<h2 id="报文段缓冲队列">报文段缓冲队列</h2>
<p>tcp_pcb块维护发送/接收端的缓冲区队列指针，定义tcp_seg管理所有未发送、已发送未确认、或已收到的无序报文。</p>
<p>tcp_seg的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This structure represents a TCP segment on the unsent, unacked and ooseq queues */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_seg</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_seg</span> *<span class="title">next</span>;</span>    <span class="comment">/* 链向下一个报文段 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">p</span>;</span>          <span class="comment">/* 报文段pbuf - buffer containing data + TCP header */</span></span><br><span class="line">  <span class="type">u16_t</span> len;               <span class="comment">/* the TCP length of this segment */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_OVERSIZE_DBGCHECK</span></span><br><span class="line">  <span class="type">u16_t</span> oversize_left;     <span class="comment">/* 当前 未发送数据队列（unsent） 中最后一个 pbuf 的 超出MSS（最大报文段大小）的字节数。 */</span> </span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_OVERSIZE_DBGCHECK */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_CHECKSUM_ON_COPY</span></span><br><span class="line">  <span class="type">u16_t</span> chksum;</span><br><span class="line">  <span class="type">u8_t</span>  chksum_swapped;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_CHECKSUM_ON_COPY */</span></span></span><br><span class="line">  <span class="type">u8_t</span>  flags;			<span class="comment">/* 报文段标志属性 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TF_SEG_OPTS_MSS         (u8_t)0x01U <span class="comment">/* Include MSS option. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TF_SEG_OPTS_TS          (u8_t)0x02U <span class="comment">/* Include timestamp option. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TF_SEG_DATA_CHECKSUMMED (u8_t)0x04U <span class="comment">/* ALL data (not the header) is</span></span></span><br><span class="line"><span class="comment"><span class="meta">                                               checksummed into &#x27;chksum&#x27; */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TF_SEG_OPTS_WND_SCALE   (u8_t)0x08U <span class="comment">/* Include WND SCALE option */</span></span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_hdr</span> *<span class="title">tcphdr</span>;</span>  <span class="comment">/* the TCP header */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>tcp_pcb块中需要维护三个指针，在其定义里有：</p>
<ul>
<li>unsent：未发送的报文段缓冲队列</li>
<li>unacked：已发送但未确认的缓冲队列</li>
<li>ooseq：已收到的无序报文队列</li>
</ul>
<p><strong>可以这么理解，最顶层的tcp_active_pcb变量管理CLOSED、LISTEN、Time-Wait以外状态的tcp_pcb块变量。各个tcp_pcb块包含不同的ip和port，管理各自的unsent、unacked、ooseq链表，每个链表又包含多个不同的tcp_seg报文段，同样用链表管理。</strong></p>
<div>
<center>
<img src="tcp_cache_queue.jpg" alt="image can't load." style="zoom:100%"> <br> TCP缓存队列
</center>
</div>
<h2 id="报文段发送">报文段发送</h2>
<p>若使用NETCONN
API编程，当数据到达传输层后，会调用<code>lwip_netconn_do_writemore()</code>函数对发送数据，处理TCP报文段缓存操作是在<code>tcp_write()</code>函数中。LwIP在将数据写入缓冲区，利用Nagle算法进行发送，最后调用<code>tcp_output()</code>
函数将数据传输至IP层，tcp_out源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">err_t</span></span><br><span class="line"><span class="title function_">tcp_output</span><span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_seg</span> *<span class="title">seg</span>, *<span class="title">useg</span>;</span></span><br><span class="line">  <span class="type">u32_t</span> wnd, snd_nxt;</span><br><span class="line">  <span class="type">err_t</span> err;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netif</span> *<span class="title">netif</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_CWND_DEBUG</span></span><br><span class="line">  <span class="type">s16_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_CWND_DEBUG */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* pcb-&gt;state LISTEN not allowed here */</span></span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;don&#x27;t call tcp_output for listen-pcbs&quot;</span>,</span><br><span class="line">    pcb-&gt;state != LISTEN);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 当前控制块正在处理输入数据，则退出 */</span></span><br><span class="line">  <span class="keyword">if</span> (tcp_input_pcb == pcb) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERR_OK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 获取发送窗snd_wnd与流量/拥塞控制窗cwnd中较小的 */</span></span><br><span class="line">  wnd = LWIP_MIN(pcb-&gt;snd_wnd, pcb-&gt;cwnd);</span><br><span class="line">  <span class="comment">/* 报文段切换为pcb中未发送的unsent链表 */</span></span><br><span class="line">  seg = pcb-&gt;unsent;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* flag中ACK被置位为立即发送，但是 </span></span><br><span class="line"><span class="comment">   * 1)无数据待发</span></span><br><span class="line"><span class="comment">   * 2)本次发送的报文段占据的序列号空间seqno-lastack +len大于接收方窗口大小wnd，接收方没有能力接收</span></span><br><span class="line"><span class="comment">   * 立即发送一个空包ACK</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;flags &amp; TF_ACK_NOW &amp;&amp;</span><br><span class="line">     (seg == <span class="literal">NULL</span> ||</span><br><span class="line">      lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len &gt; wnd)) &#123;</span><br><span class="line">     <span class="keyword">return</span> tcp_send_empty_ack(pcb);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* useg指向最近一次发送但未应答队列unacked报文段，便于超时重传 */</span></span><br><span class="line">  useg = pcb-&gt;unacked;</span><br><span class="line">  <span class="keyword">if</span> (useg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; useg-&gt;next != <span class="literal">NULL</span>; useg = useg-&gt;next);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 底层调用ip4_route函数进行路由查找，检查网口是否可用（UP+链路+IP），匹配子网或路由 */</span></span><br><span class="line">  netif = ip_route(&amp;pcb-&gt;local_ip, &amp;pcb-&gt;remote_ip);</span><br><span class="line">  <span class="keyword">if</span> (netif == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERR_RTE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 若pcb未绑定本地ip，调用ip_netif_get_local_ip从netif中获取ip */</span></span><br><span class="line">  <span class="keyword">if</span> (ip_addr_isany(&amp;pcb-&gt;local_ip)) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">ip_addr_t</span> *local_ip = ip_netif_get_local_ip(netif, &amp;pcb-&gt;remote_ip);</span><br><span class="line">    <span class="keyword">if</span> (local_ip == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ERR_RTE;</span><br><span class="line">    &#125;</span><br><span class="line">    ip_addr_copy(pcb-&gt;local_ip, *local_ip);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_OUTPUT_DEBUG</span></span><br><span class="line">  <span class="keyword">if</span> (seg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, (<span class="string">&quot;tcp_output: nothing to send (%p)\n&quot;</span>,</span><br><span class="line">                                   (<span class="type">void</span>*)pcb-&gt;unsent));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_OUTPUT_DEBUG */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_CWND_DEBUG</span></span><br><span class="line">  <span class="keyword">if</span> (seg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    LWIP_DEBUGF(TCP_CWND_DEBUG, (<span class="string">&quot;tcp_output: snd_wnd %&quot;</span>TCPWNDSIZE_F</span><br><span class="line">                                 <span class="string">&quot;, cwnd %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;, wnd %&quot;</span>U32_F</span><br><span class="line">                                 <span class="string">&quot;, seg == NULL, ack %&quot;</span>U32_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                                 pcb-&gt;snd_wnd, pcb-&gt;cwnd, wnd, pcb-&gt;lastack));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LWIP_DEBUGF(TCP_CWND_DEBUG,</span><br><span class="line">                (<span class="string">&quot;tcp_output: snd_wnd %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;, cwnd %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;, wnd %&quot;</span>U32_F</span><br><span class="line">                 <span class="string">&quot;, effwnd %&quot;</span>U32_F<span class="string">&quot;, seq %&quot;</span>U32_F<span class="string">&quot;, ack %&quot;</span>U32_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                 pcb-&gt;snd_wnd, pcb-&gt;cwnd, wnd,</span><br><span class="line">                 lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len,</span><br><span class="line">                 lwip_ntohl(seg-&gt;tcphdr-&gt;seqno), pcb-&gt;lastack));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_CWND_DEBUG */</span></span></span><br><span class="line">    <span class="comment">/* 处理不适合窗口的报文段 */</span></span><br><span class="line">  <span class="keyword">if</span> (seg != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">      lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len &gt; wnd &amp;&amp;</span><br><span class="line">      wnd &gt; <span class="number">0</span> &amp;&amp; wnd == pcb-&gt;snd_wnd &amp;&amp; pcb-&gt;unacked == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* 启动persist持久化定时器 */</span></span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;persist_backoff == <span class="number">0</span>) &#123;</span><br><span class="line">      pcb-&gt;persist_cnt = <span class="number">0</span>;</span><br><span class="line">      pcb-&gt;persist_backoff = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> output_done; <span class="comment">//跳转至最后</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 数据可用且窗口允许发送，while直到发送完成 */</span></span><br><span class="line">  <span class="keyword">while</span> (seg != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">         lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len &lt;= wnd) </span><br><span class="line">  &#123;</span><br><span class="line">        LWIP_ASSERT(<span class="string">&quot;RST not expected here!&quot;</span>,</span><br><span class="line">                    (TCPH_FLAGS(seg-&gt;tcphdr) &amp; TCP_RST) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* tcp_do_output_nagel(pcb)检查nagle算法是否允许发送,1允许，0禁止。在Nagle禁止时</span></span><br><span class="line"><span class="comment">       * 1)若Nagle内存出错，及时发送ACK</span></span><br><span class="line"><span class="comment">       * 2)FIN已在队列中，终端连接</span></span><br><span class="line"><span class="comment">       * RST不使用tcp_output发送</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">if</span> ((tcp_do_output_nagle(pcb) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">          ((pcb-&gt;flags &amp; (TF_NAGLEMEMERR | TF_FIN)) == <span class="number">0</span>)) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> TCP_CWND_DEBUG</span></span><br><span class="line">        LWIP_DEBUGF(TCP_CWND_DEBUG, (<span class="string">&quot;tcp_output: snd_wnd %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;, cwnd %&quot;</span>TCPWNDSIZE_F<span class="string">&quot;, wnd %&quot;</span>U32_F<span class="string">&quot;, effwnd %&quot;</span>U32_F<span class="string">&quot;, seq %&quot;</span>U32_F<span class="string">&quot;, ack %&quot;</span>U32_F<span class="string">&quot;, i %&quot;</span>S16_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                                pcb-&gt;snd_wnd, pcb-&gt;cwnd, wnd,</span><br><span class="line">                                lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) + seg-&gt;len -</span><br><span class="line">                                pcb-&gt;lastack,</span><br><span class="line">                                lwip_ntohl(seg-&gt;tcphdr-&gt;seqno), pcb-&gt;lastack, i));</span><br><span class="line">        ++i;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_CWND_DEBUG */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 未处于建立连接的SYN态，需要在tcp结构里置位ACK，捎带应答 */</span></span><br><span class="line">        <span class="keyword">if</span> (pcb-&gt;state != SYN_SENT) &#123;</span><br><span class="line">          TCPH_SET_FLAG(seg-&gt;tcphdr, TCP_ACK); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> TCP_OVERSIZE_DBGCHECK</span></span><br><span class="line">        seg-&gt;oversize_left = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_OVERSIZE_DBGCHECK */</span></span></span><br><span class="line">        <span class="comment">/* IP传输层使用ip_output_if函数，发送当前pcb块中的unsent报文段 */</span></span><br><span class="line">        err = tcp_output_segment(seg, pcb, netif);</span><br><span class="line">        <span class="keyword">if</span> (err != ERR_OK) &#123;</span><br><span class="line">          <span class="comment">/* 无论何种原因，报文段未发送 */</span></span><br><span class="line">          pcb-&gt;flags |= TF_NAGLEMEMERR; <span class="comment">/* Nagle 存储错误 */</span></span><br><span class="line">          <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pcb-&gt;unsent = seg-&gt;next; <span class="comment">/* 未发送链表指向下一个seg段 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pcb-&gt;state != SYN_SENT) &#123;</span><br><span class="line">          pcb-&gt;flags &amp;= ~(TF_ACK_DELAY | TF_ACK_NOW);<span class="comment">/* 发送完后设定延时应答状态 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 计算下一个snd_nxt新序列号 seq+length(seq) */</span></span><br><span class="line">        snd_nxt = lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) + TCP_TCPLEN(seg); </span><br><span class="line">        <span class="keyword">if</span> (TCP_SEQ_LT(pcb-&gt;snd_nxt, snd_nxt)) &#123;</span><br><span class="line">          pcb-&gt;snd_nxt = snd_nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 本段有效长度大于0放入unacked链表，等待rcv端ACK */</span></span><br><span class="line">        <span class="keyword">if</span> (TCP_TCPLEN(seg) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          seg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">          <span class="comment">/* unacked list is empty? */</span></span><br><span class="line">          <span class="keyword">if</span> (pcb-&gt;unacked == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pcb-&gt;unacked = seg;</span><br><span class="line">            useg = seg;</span><br><span class="line">          <span class="comment">/* unacked list is not empty? */</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 如果当前报文段seq序号小于未收到应答unacked链表最近的seq序号，需要对链表进行重排(按序) */</span></span><br><span class="line">            <span class="keyword">if</span> (TCP_SEQ_LT(lwip_ntohl(seg-&gt;tcphdr-&gt;seqno), lwip_ntohl(useg-&gt;tcphdr-&gt;seqno))) 			&#123;</span><br><span class="line">              <span class="comment">/* 将报文段按顺序增加在中间位置 */</span></span><br><span class="line">              <span class="keyword">struct</span> tcp_seg **cur_seg = &amp;(pcb-&gt;unacked);</span><br><span class="line">              <span class="comment">/* 找到unacked中第一个seqno ≥ 当前发送报文段seqno的节点 */</span></span><br><span class="line">              <span class="keyword">while</span> (*cur_seg &amp;&amp;</span><br><span class="line">                TCP_SEQ_LT(lwip_ntohl((*cur_seg)-&gt;tcphdr-&gt;seqno), lwip_ntohl(seg-&gt;tcphdr-&gt;seqno))) 	   &#123;</span><br><span class="line">                  cur_seg = &amp;((*cur_seg)-&gt;next );</span><br><span class="line">              &#125;</span><br><span class="line">              seg-&gt;next = (*cur_seg); <span class="comment">/*seg-&gt;next 指向原序列较大seq的节点（*cur_seg）*/</span></span><br><span class="line">              (*cur_seg) = seg; <span class="comment">/* 原序列较大seq的节点（*cur_seg）的前驱节点的 next 指针指向 seg */</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">/* seg插入unacked尾部 */</span></span><br><span class="line">              useg-&gt;next = seg;</span><br><span class="line">              useg = useg-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">/* 报文段len=0的空包 */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          tcp_seg_free(seg);</span><br><span class="line">        &#125;</span><br><span class="line">        seg = pcb-&gt;unsent; <span class="comment">/* 下一个报文段，直到循环结束所有seg发送完毕 */</span></span><br><span class="line">  &#125;</span><br><span class="line">output_done:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_OVERSIZE</span></span><br><span class="line">  <span class="keyword">if</span> (pcb-&gt;unsent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* last unsent has been removed, reset unsent_oversize */</span></span><br><span class="line">    pcb-&gt;unsent_oversize = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_OVERSIZE */</span></span></span><br><span class="line"></span><br><span class="line">  pcb-&gt;flags &amp;= ~TF_NAGLEMEMERR;</span><br><span class="line">  <span class="keyword">return</span> ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="报文段接收">报文段接收</h2>
<p>类似应用层向传输层发送接口<code>tcp_output()</code>,还有传输层(IP层)向应用层发送<code>tcp_input()</code>函数，其源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">tcp_input</span><span class="params">(<span class="keyword">struct</span> pbuf *p, <span class="keyword">struct</span> netif *inp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">pcb</span>, *<span class="title">prev</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb_listen</span> *<span class="title">lpcb</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SO_REUSE</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb</span> *<span class="title">lpcb_prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_pcb_listen</span> *<span class="title">lpcb_any</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SO_REUSE */</span></span></span><br><span class="line">  <span class="type">u8_t</span> hdrlen_bytes;</span><br><span class="line">  <span class="type">err_t</span> err;</span><br><span class="line"></span><br><span class="line">  LWIP_UNUSED_ARG(inp);</span><br><span class="line"></span><br><span class="line">  PERF_START;</span><br><span class="line"></span><br><span class="line">  TCP_STATS_INC(tcp.recv);</span><br><span class="line">  MIB2_STATS_INC(mib2.tcpinsegs);</span><br><span class="line"></span><br><span class="line">  tcphdr = (<span class="keyword">struct</span> tcp_hdr *)p-&gt;payload;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_INPUT_DEBUG</span></span><br><span class="line">  tcp_debug_print(tcphdr);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 报文段是否有有效数据 */</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;len &lt; TCP_HLEN) &#123;</span><br><span class="line">    <span class="comment">/* 没有就丢弃报文段 */</span></span><br><span class="line">    LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: short packet (%&quot;</span>U16_F<span class="string">&quot; bytes) discarded\n&quot;</span>, p-&gt;tot_len));</span><br><span class="line">    TCP_STATS_INC(tcp.lenerr);</span><br><span class="line">    <span class="keyword">goto</span> dropped;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 不处理传入的广播/多播报文段 */</span></span><br><span class="line">  <span class="keyword">if</span> (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||</span><br><span class="line">      ip_addr_ismulticast(ip_current_dest_addr())) &#123;</span><br><span class="line">    TCP_STATS_INC(tcp.proterr);</span><br><span class="line">    <span class="keyword">goto</span> dropped;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CHECKSUM_CHECK_TCP</span></span><br><span class="line">  IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_TCP) &#123;</span><br><span class="line">    <span class="comment">/* Verify TCP checksum. */</span></span><br><span class="line">    <span class="type">u16_t</span> chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p-&gt;tot_len,</span><br><span class="line">                               ip_current_src_addr(), ip_current_dest_addr());</span><br><span class="line">    <span class="keyword">if</span> (chksum != <span class="number">0</span>) &#123;</span><br><span class="line">        LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: packet discarded due to failing checksum 0x%04&quot;</span>X16_F<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">          chksum));</span><br><span class="line">      tcp_debug_print(tcphdr);</span><br><span class="line">      TCP_STATS_INC(tcp.chkerr);</span><br><span class="line">      <span class="keyword">goto</span> dropped;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CHECKSUM_CHECK_TCP */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* TCP报文段首部长度 */</span></span><br><span class="line">  hdrlen_bytes = TCPH_HDRLEN(tcphdr) * <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">if</span> ((hdrlen_bytes &lt; TCP_HLEN) || (hdrlen_bytes &gt; p-&gt;tot_len)) &#123;</span><br><span class="line">     <span class="comment">/* uint16 溢出，无法处理*/</span></span><br><span class="line">    LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: invalid header length (%&quot;</span>U16_F<span class="string">&quot;)\n&quot;</span>, (<span class="type">u16_t</span>)hdrlen_bytes));</span><br><span class="line">    TCP_STATS_INC(tcp.lenerr);</span><br><span class="line">    <span class="keyword">goto</span> dropped;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将pbuf指针从tcp header指向data区 */</span></span><br><span class="line">  tcphdr_optlen = hdrlen_bytes - TCP_HLEN;</span><br><span class="line">  tcphdr_opt2 = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;len &gt;= hdrlen_bytes) &#123;</span><br><span class="line">    <span class="comment">/* all options are in the first pbuf */</span></span><br><span class="line">    tcphdr_opt1len = tcphdr_optlen;</span><br><span class="line">    pbuf_header(p, -(<span class="type">s16_t</span>)hdrlen_bytes); <span class="comment">/* cannot fail */</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">u16_t</span> opt2len;</span><br><span class="line">    <span class="comment">/* TCP header fits into first pbuf, options don&#x27;t - data is in the next pbuf */</span></span><br><span class="line">    <span class="comment">/* there must be a next pbuf, due to hdrlen_bytes sanity check above */</span></span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;p-&gt;next != NULL&quot;</span>, p-&gt;next != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* advance over the TCP header (cannot fail) */</span></span><br><span class="line">    pbuf_header(p, -TCP_HLEN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* determine how long the first and second parts of the options are */</span></span><br><span class="line">    tcphdr_opt1len = p-&gt;len;</span><br><span class="line">    opt2len = tcphdr_optlen - tcphdr_opt1len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* options continue in the next pbuf: set p to zero length and hide the</span></span><br><span class="line"><span class="comment">        options in the next pbuf (adjusting p-&gt;tot_len) */</span></span><br><span class="line">    pbuf_header(p, -(<span class="type">s16_t</span>)tcphdr_opt1len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check that the options fit in the second pbuf */</span></span><br><span class="line">    <span class="keyword">if</span> (opt2len &gt; p-&gt;next-&gt;len) &#123;</span><br><span class="line">      <span class="comment">/* drop short packets */</span></span><br><span class="line">      LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: options overflow second pbuf (%&quot;</span>U16_F<span class="string">&quot; bytes)\n&quot;</span>, p-&gt;next-&gt;len));</span><br><span class="line">      TCP_STATS_INC(tcp.lenerr);</span><br><span class="line">      <span class="keyword">goto</span> dropped;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remember the pointer to the second part of the options */</span></span><br><span class="line">    tcphdr_opt2 = (<span class="type">u8_t</span>*)p-&gt;next-&gt;payload;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* advance p-&gt;next to point after the options, and manually</span></span><br><span class="line"><span class="comment">        adjust p-&gt;tot_len to keep it consistent with the changed p-&gt;next */</span></span><br><span class="line">    pbuf_header(p-&gt;next, -(<span class="type">s16_t</span>)opt2len);</span><br><span class="line">    p-&gt;tot_len -= opt2len;</span><br><span class="line"></span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;p-&gt;len == 0&quot;</span>, p-&gt;len == <span class="number">0</span>);</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;p-&gt;tot_len == p-&gt;next-&gt;tot_len&quot;</span>, p-&gt;tot_len == p-&gt;next-&gt;tot_len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 提取tcp头部各字段的值 */</span></span><br><span class="line">  tcphdr-&gt;src = lwip_ntohs(tcphdr-&gt;src);</span><br><span class="line">  tcphdr-&gt;dest = lwip_ntohs(tcphdr-&gt;dest);</span><br><span class="line">  seqno = tcphdr-&gt;seqno = lwip_ntohl(tcphdr-&gt;seqno);</span><br><span class="line">  ackno = tcphdr-&gt;ackno = lwip_ntohl(tcphdr-&gt;ackno);</span><br><span class="line">  tcphdr-&gt;wnd = lwip_ntohs(tcphdr-&gt;wnd);</span><br><span class="line"></span><br><span class="line">  flags = TCPH_FLAGS(tcphdr);</span><br><span class="line">  tcplen = p-&gt;tot_len + ((flags &amp; (TCP_FIN | TCP_SYN)) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Demultiplex an incoming segment. First, we check if it is destined</span></span><br><span class="line"><span class="comment">     for an active connection. */</span></span><br><span class="line">  prev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历活跃的tcp_active_pcbs寻找对应TCP控制块 */</span></span><br><span class="line">  <span class="keyword">for</span> (pcb = tcp_active_pcbs; pcb != <span class="literal">NULL</span>; pcb = pcb-&gt;next) &#123;</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;tcp_input: active pcb-&gt;state != CLOSED&quot;</span>, pcb-&gt;state != CLOSED);</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;tcp_input: active pcb-&gt;state != TIME-WAIT&quot;</span>, pcb-&gt;state != TIME_WAIT);</span><br><span class="line">    LWIP_ASSERT(<span class="string">&quot;tcp_input: active pcb-&gt;state != LISTEN&quot;</span>, pcb-&gt;state != LISTEN);</span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;remote_port == tcphdr-&gt;src &amp;&amp;</span><br><span class="line">        pcb-&gt;local_port == tcphdr-&gt;dest &amp;&amp;</span><br><span class="line">        ip_addr_cmp(&amp;pcb-&gt;remote_ip, ip_current_src_addr()) &amp;&amp;</span><br><span class="line">        ip_addr_cmp(&amp;pcb-&gt;local_ip, ip_current_dest_addr())) &#123;</span><br><span class="line">      <span class="comment">/* Move this PCB to the front of the list so that subsequent</span></span><br><span class="line"><span class="comment">         lookups will be faster (we exploit locality in TCP segment</span></span><br><span class="line"><span class="comment">         arrivals). */</span></span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;tcp_input: pcb-&gt;next != pcb (before cache)&quot;</span>, pcb-&gt;next != pcb);</span><br><span class="line">      <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        prev-&gt;next = pcb-&gt;next;</span><br><span class="line">        pcb-&gt;next = tcp_active_pcbs;</span><br><span class="line">        tcp_active_pcbs = pcb;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TCP_STATS_INC(tcp.cachehit);</span><br><span class="line">      &#125;</span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;tcp_input: pcb-&gt;next != pcb (after cache)&quot;</span>, pcb-&gt;next != pcb);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    prev = pcb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pcb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* 如果没找到active连接，则检查TW(Time-Wait)状态连接 */</span></span><br><span class="line">    <span class="keyword">for</span> (pcb = tcp_tw_pcbs; pcb != <span class="literal">NULL</span>; pcb = pcb-&gt;next) &#123;</span><br><span class="line">      LWIP_ASSERT(<span class="string">&quot;tcp_input: TIME-WAIT pcb-&gt;state == TIME-WAIT&quot;</span>, pcb-&gt;state == TIME_WAIT);</span><br><span class="line">      <span class="keyword">if</span> (pcb-&gt;remote_port == tcphdr-&gt;src &amp;&amp;</span><br><span class="line">          pcb-&gt;local_port == tcphdr-&gt;dest &amp;&amp;</span><br><span class="line">          ip_addr_cmp(&amp;pcb-&gt;remote_ip, ip_current_src_addr()) &amp;&amp;</span><br><span class="line">          ip_addr_cmp(&amp;pcb-&gt;local_ip, ip_current_dest_addr())) &#123;</span><br><span class="line">        <span class="comment">/* We don&#x27;t really care enough to move this PCB to the front</span></span><br><span class="line"><span class="comment">           of the list since we are not very likely to receive that</span></span><br><span class="line"><span class="comment">           many segments for connections in TIME-WAIT. */</span></span><br><span class="line">        LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: packed for TIME_WAITing connection.\n&quot;</span>));</span><br><span class="line">        tcp_timewait_input(pcb); <span class="comment">/* 有匹配的ip和端口 */</span></span><br><span class="line">        pbuf_free(p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若仍未找到，则在LISTENING态的网口中查找连接. */</span></span><br><span class="line">    prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != <span class="literal">NULL</span>; lpcb = lpcb-&gt;next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (lpcb-&gt;local_port == tcphdr-&gt;dest) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IP_IS_ANY_TYPE_VAL(lpcb-&gt;local_ip)) &#123;</span><br><span class="line">          <span class="comment">/* found an ANY TYPE (IPv4/IPv6) match */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SO_REUSE</span></span><br><span class="line">          lpcb_any = lpcb;</span><br><span class="line">          lpcb_prev = prev;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* SO_REUSE */</span></span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SO_REUSE */</span></span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IP_ADDR_PCB_VERSION_MATCH_EXACT(lpcb, ip_current_dest_addr())) &#123;</span><br><span class="line">          <span class="keyword">if</span> (ip_addr_cmp(&amp;lpcb-&gt;local_ip, ip_current_dest_addr())) &#123;</span><br><span class="line">            <span class="comment">/* found an exact match */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ip_addr_isany(&amp;lpcb-&gt;local_ip)) &#123;</span><br><span class="line">            <span class="comment">/* found an ANY-match */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SO_REUSE</span></span><br><span class="line">            lpcb_any = lpcb;</span><br><span class="line">            lpcb_prev = prev;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* SO_REUSE */</span></span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SO_REUSE */</span></span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      prev = (<span class="keyword">struct</span> tcp_pcb *)lpcb;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SO_REUSE</span></span><br><span class="line">    <span class="comment">/* first try specific local IP */</span></span><br><span class="line">    <span class="keyword">if</span> (lpcb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">/* only pass to ANY if no specific local IP has been found */</span></span><br><span class="line">      lpcb = lpcb_any;</span><br><span class="line">      prev = lpcb_prev;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SO_REUSE */</span></span></span><br><span class="line">    <span class="keyword">if</span> (lpcb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">/* Move this PCB to the front of the list so that subsequent</span></span><br><span class="line"><span class="comment">         lookups will be faster (we exploit locality in TCP segment</span></span><br><span class="line"><span class="comment">         arrivals). */</span></span><br><span class="line">      <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ((<span class="keyword">struct</span> tcp_pcb_listen *)prev)-&gt;next = lpcb-&gt;next;</span><br><span class="line">              <span class="comment">/* our successor is the remainder of the listening list */</span></span><br><span class="line">        lpcb-&gt;next = tcp_listen_pcbs.listen_pcbs;</span><br><span class="line">              <span class="comment">/* put this listening pcb at the head of the listening list */</span></span><br><span class="line">        tcp_listen_pcbs.listen_pcbs = lpcb;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TCP_STATS_INC(tcp.cachehit);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: packed for LISTENing connection.\n&quot;</span>));</span><br><span class="line">      tcp_listen_input(lpcb);</span><br><span class="line">      pbuf_free(p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_INPUT_DEBUG</span></span><br><span class="line">  LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;+-+-+-+-+-+-+-+-+-+-+-+-+-+- tcp_input: flags &quot;</span>));</span><br><span class="line">  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));</span><br><span class="line">  LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n&quot;</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_INPUT_DEBUG */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pcb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* The incoming segment belongs to a connection. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_INPUT_DEBUG</span></span><br><span class="line">    tcp_debug_print_state(pcb-&gt;state);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_INPUT_DEBUG */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up a tcp_seg structure. */</span></span><br><span class="line">    inseg.next = <span class="literal">NULL</span>;</span><br><span class="line">    inseg.len = p-&gt;tot_len;</span><br><span class="line">    inseg.p = p;</span><br><span class="line">    inseg.tcphdr = tcphdr;</span><br><span class="line"></span><br><span class="line">    recv_data = <span class="literal">NULL</span>;</span><br><span class="line">    recv_flags = <span class="number">0</span>;</span><br><span class="line">    recv_acked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; TCP_PSH) &#123;</span><br><span class="line">      p-&gt;flags |= PBUF_FLAG_PUSH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If there is data which was previously &quot;refused&quot; by upper layer */</span></span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;refused_data != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((tcp_process_refused_data(pcb) == ERR_ABRT) ||</span><br><span class="line">        ((pcb-&gt;refused_data != <span class="literal">NULL</span>) &amp;&amp; (tcplen &gt; <span class="number">0</span>))) &#123;</span><br><span class="line">        <span class="comment">/* pcb has been aborted or refused data is still refused and the new</span></span><br><span class="line"><span class="comment">           segment contains data */</span></span><br><span class="line">        <span class="keyword">if</span> (pcb-&gt;rcv_ann_wnd == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">/* this is a zero-window probe, we respond to it with current RCV.NXT</span></span><br><span class="line"><span class="comment">          and drop the data segment */</span></span><br><span class="line">          tcp_send_empty_ack(pcb);</span><br><span class="line">        &#125;</span><br><span class="line">        TCP_STATS_INC(tcp.drop);</span><br><span class="line">        MIB2_STATS_INC(mib2.tcpinerrs);</span><br><span class="line">        <span class="keyword">goto</span> aborted;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tcp_input_pcb = pcb;</span><br><span class="line">    err = tcp_process(pcb);</span><br><span class="line">    <span class="comment">/* A return value of ERR_ABRT means that tcp_abort() was called</span></span><br><span class="line"><span class="comment">       and that the pcb has been freed. If so, we don&#x27;t do anything. */</span></span><br><span class="line">    <span class="keyword">if</span> (err != ERR_ABRT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (recv_flags &amp; TF_RESET) &#123;</span><br><span class="line">        <span class="comment">/* TF_RESET means that the connection was reset by the other</span></span><br><span class="line"><span class="comment">           end. We then call the error callback to inform the</span></span><br><span class="line"><span class="comment">           application that the connection is dead before we</span></span><br><span class="line"><span class="comment">           deallocate the PCB. */</span></span><br><span class="line">        TCP_EVENT_ERR(pcb-&gt;state, pcb-&gt;errf, pcb-&gt;callback_arg, ERR_RST);</span><br><span class="line">        tcp_pcb_remove(&amp;tcp_active_pcbs, pcb);</span><br><span class="line">        memp_free(MEMP_TCP_PCB, pcb);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = ERR_OK;</span><br><span class="line">        <span class="comment">/* If the application has registered a &quot;sent&quot; function to be</span></span><br><span class="line"><span class="comment">           called when new send buffer space is available, we call it</span></span><br><span class="line"><span class="comment">           now. */</span></span><br><span class="line">        <span class="keyword">if</span> (recv_acked &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="type">u16_t</span> acked16;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LWIP_WND_SCALE</span></span><br><span class="line">          <span class="comment">/* recv_acked is u32_t but the sent callback only takes a u16_t,</span></span><br><span class="line"><span class="comment">             so we might have to call it multiple times. */</span></span><br><span class="line">          <span class="type">u32_t</span> acked = recv_acked;</span><br><span class="line">          <span class="keyword">while</span> (acked &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            acked16 = (<span class="type">u16_t</span>)LWIP_MIN(acked, <span class="number">0xffffu</span>);</span><br><span class="line">            acked -= acked16;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">          &#123;</span><br><span class="line">            acked16 = recv_acked;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            TCP_EVENT_SENT(pcb, (<span class="type">u16_t</span>)acked16, err);</span><br><span class="line">            <span class="keyword">if</span> (err == ERR_ABRT) &#123;</span><br><span class="line">              <span class="keyword">goto</span> aborted;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          recv_acked = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (recv_flags &amp; TF_CLOSED) &#123;</span><br><span class="line">          <span class="comment">/* The connection has been closed and we will deallocate the</span></span><br><span class="line"><span class="comment">             PCB. */</span></span><br><span class="line">          <span class="keyword">if</span> (!(pcb-&gt;flags &amp; TF_RXCLOSED)) &#123;</span><br><span class="line">            <span class="comment">/* Connection closed although the application has only shut down the</span></span><br><span class="line"><span class="comment">               tx side: call the PCB&#x27;s err callback and indicate the closure to</span></span><br><span class="line"><span class="comment">               ensure the application doesn&#x27;t continue using the PCB. */</span></span><br><span class="line">            TCP_EVENT_ERR(pcb-&gt;state, pcb-&gt;errf, pcb-&gt;callback_arg, ERR_CLSD);</span><br><span class="line">          &#125;</span><br><span class="line">          tcp_pcb_remove(&amp;tcp_active_pcbs, pcb);</span><br><span class="line">          memp_free(MEMP_TCP_PCB, pcb);</span><br><span class="line">          <span class="keyword">goto</span> aborted;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE</span></span><br><span class="line">        <span class="keyword">while</span> (recv_data != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">rest</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">          pbuf_split_64k(recv_data, &amp;rest);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE */</span></span></span><br><span class="line">        <span class="keyword">if</span> (recv_data != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE */</span></span></span><br><span class="line"></span><br><span class="line">          LWIP_ASSERT(<span class="string">&quot;pcb-&gt;refused_data == NULL&quot;</span>, pcb-&gt;refused_data == <span class="literal">NULL</span>);</span><br><span class="line">          <span class="keyword">if</span> (pcb-&gt;flags &amp; TF_RXCLOSED) &#123;</span><br><span class="line">            <span class="comment">/* received data although already closed -&gt; abort (send RST) to</span></span><br><span class="line"><span class="comment">               notify the remote host that not all data has been processed */</span></span><br><span class="line">            pbuf_free(recv_data);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE</span></span><br><span class="line">            <span class="keyword">if</span> (rest != <span class="literal">NULL</span>) &#123;</span><br><span class="line">              pbuf_free(rest);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE */</span></span></span><br><span class="line">            tcp_abort(pcb);</span><br><span class="line">            <span class="keyword">goto</span> aborted;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Notify application that data has been received. */</span></span><br><span class="line">          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);</span><br><span class="line">          <span class="keyword">if</span> (err == ERR_ABRT) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE</span></span><br><span class="line">            <span class="keyword">if</span> (rest != <span class="literal">NULL</span>) &#123;</span><br><span class="line">              pbuf_free(rest);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE */</span></span></span><br><span class="line">            <span class="keyword">goto</span> aborted;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* If the upper layer can&#x27;t receive this data, store it */</span></span><br><span class="line">          <span class="keyword">if</span> (err != ERR_OK) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE</span></span><br><span class="line">            <span class="keyword">if</span> (rest != <span class="literal">NULL</span>) &#123;</span><br><span class="line">              pbuf_cat(recv_data, rest);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE */</span></span></span><br><span class="line">            pcb-&gt;refused_data = recv_data;</span><br><span class="line">            LWIP_DEBUGF(TCP_INPUT_DEBUG, (<span class="string">&quot;tcp_input: keep incoming packet, because pcb is \&quot;full\&quot;\n&quot;</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Upper layer received the data, go on with the rest if &gt; 64K */</span></span><br><span class="line">            recv_data = rest;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_QUEUE_OOSEQ &amp;&amp; LWIP_WND_SCALE */</span></span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If a FIN segment was received, we call the callback</span></span><br><span class="line"><span class="comment">           function with a NULL buffer to indicate EOF. */</span></span><br><span class="line">        <span class="keyword">if</span> (recv_flags &amp; TF_GOT_FIN) &#123;</span><br><span class="line">          <span class="keyword">if</span> (pcb-&gt;refused_data != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Delay this if we have refused data. */</span></span><br><span class="line">            pcb-&gt;refused_data-&gt;flags |= PBUF_FLAG_TCP_FIN;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* correct rcv_wnd as the application won&#x27;t call tcp_recved()</span></span><br><span class="line"><span class="comment">               for the FIN&#x27;s seqno */</span></span><br><span class="line">            <span class="keyword">if</span> (pcb-&gt;rcv_wnd != TCP_WND_MAX(pcb)) &#123;</span><br><span class="line">              pcb-&gt;rcv_wnd++;</span><br><span class="line">            &#125;</span><br><span class="line">            TCP_EVENT_CLOSED(pcb, err);</span><br><span class="line">            <span class="keyword">if</span> (err == ERR_ABRT) &#123;</span><br><span class="line">              <span class="keyword">goto</span> aborted;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tcp_input_pcb = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">/* Try to send something out. */</span></span><br><span class="line">        tcp_output(pcb);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_INPUT_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCP_DEBUG</span></span><br><span class="line">        tcp_debug_print_state(pcb-&gt;state);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_DEBUG */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCP_INPUT_DEBUG */</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).</span></span><br><span class="line"><span class="comment">       Below this line, &#x27;pcb&#x27; may not be dereferenced! */</span></span><br><span class="line">aborted:</span><br><span class="line">    tcp_input_pcb = <span class="literal">NULL</span>;</span><br><span class="line">    recv_data = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* give up our reference to inseg.p */</span></span><br><span class="line">    <span class="keyword">if</span> (inseg.p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      pbuf_free(inseg.p);</span><br><span class="line">      inseg.p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If no matching PCB was found, send a TCP RST (reset) to the</span></span><br><span class="line"><span class="comment">       sender. */</span></span><br><span class="line">    LWIP_DEBUGF(TCP_RST_DEBUG, (<span class="string">&quot;tcp_input: no PCB match found, resetting.\n&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (!(TCPH_FLAGS(tcphdr) &amp; TCP_RST)) &#123;</span><br><span class="line">      TCP_STATS_INC(tcp.proterr);</span><br><span class="line">      TCP_STATS_INC(tcp.drop);</span><br><span class="line">      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),</span><br><span class="line">        ip_current_src_addr(), tcphdr-&gt;dest, tcphdr-&gt;src);</span><br><span class="line">    &#125;</span><br><span class="line">    pbuf_free(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LWIP_ASSERT(<span class="string">&quot;tcp_input: tcp_pcbs_sane()&quot;</span>, tcp_pcbs_sane());</span><br><span class="line">  PERF_STOP(<span class="string">&quot;tcp_input&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">dropped:</span><br><span class="line">  TCP_STATS_INC(tcp.drop);</span><br><span class="line">  MIB2_STATS_INC(mib2.tcpinerrs);</span><br><span class="line">  pbuf_free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>正常接收处理的数据，如果收到的报文段是复位报文或终止连接应答报文，则释放pbuf，终止连接；</li>
<li>TCP 协议确认报文段是新数据，调用带参宏TCP_EVENT_SENT（sent
的回调函数）处理；</li>
<li>如果报文段中包含有效的数据，就调用TCP_EVENT_RECV 去处理；</li>
<li>如果是收到FIN 报文，则调用TCP_EVENT_CLOSED 去处理；</li>
</ul>
<h1 id="参考资料">参考资料</h1>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/2301_76144863/article/details/139028540?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-139028540-blog-120524798.235%5Ev43%5Epc_blog_bottom_relevance_base5&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=3">TCP协议_tcp全双工-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zjcjava/article/details/103133607?ops_request_misc=&amp;request_id=&amp;biz_id=&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~es_rank~default-2-103133607.pc_search_all_es&amp;utm_term=为什么tcp挥手只有三次&amp;spm=1018.2226.3001.4187">tcp/ip
只有四次挥手？还有三次挥手_四次挥手中会出现只有3此的情况嘛-CSDN博客</a></li>
<li>[linux - What is the reason and how to avoid the <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/15182106/what-is-the-reason-and-how-to-avoid-the-fin-ack-rst-and-rst-ack">FIN,
ACK] , [RST] and [RST, ACK] - Stack Overflow</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40803011/article/details/121794141">Wireshark抓包分析TCP，发现居然只有三次挥手_只抓到三次挥手-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://zorrozou.github.io/docs/tcp/wavehand/TCP_Wavehand.html">Linux的TCP实现之：四次挥手
| Zorro’s Linux Book</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lizhuming/p/17438743.html">【lwip】14-TCP协议之可靠传输的实现（TCP干货）
- 李柱明 - 博客园</a></li>
<li><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/rfc793#section-3.5">RFC 793:
Transmission Control Protocol-S3.5</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lizhuming/p/16883586.html">【lwip】12-一文解决TCP原理
- 李柱明 - 博客园</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lshs/p/6038658.html">TCP系列33—窗口管理&amp;流控—7、Silly
Window Syndrome(SWS) - lshs - 博客园</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lizhuming/p/17438682.html">【lwip】13-TCP协议分析之源码篇
- 李柱明 - 博客园</a></li>
</ol>
<p align="center">
————————— End —————————
</p>
<blockquote>
<p>“江山如此多娇，引无数英雄竞折腰。” —— 《沁园春·雪》</p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>如果你愿意请我喝咖啡~</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpg" alt="Youngs 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="Youngs 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Youngs
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://microprism.github.io/2025/07/19/TCP-Protocol/" title="TCP&#x2F;IP-协议详解">https://microprism.github.io/2025/07/19/TCP-Protocol/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/TCP-IP/" rel="tag"># TCP/IP</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/07/19/LeetCode-02-GCD_Of_String/" rel="prev" title="LeetCode-02-字符串寻找最大公因子">
                  <i class="fa fa-angle-left"></i> LeetCode-02-字符串寻找最大公因子
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/07/19/ZYNQ-01-ZYNQ_TCP_Demo_Error/" rel="next" title="ZYNQ-01-ZYNQ7020 TCP例程自动协商失败解决办法">
                  ZYNQ-01-ZYNQ7020 TCP例程自动协商失败解决办法 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">



  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Youngs</span>
  </div>







<div>
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("04/09/2025 00:00:00");//在此处修改你的建站时间
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "已运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div><script color="0,0,255" opacity="0.5" zIndex="-1" count="150" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>
    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>

  <a href="https://github.com/MicroPrism" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
